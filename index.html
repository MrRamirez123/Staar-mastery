<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>STAAR Mastery Pathway</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    body { 
        font-family: 'Inter', sans-serif; 
        background-color: #e5e7eb; 
    }
/* --- Review Modal Layout Fix --- */
.review-item {
    /* This creates the two-column grid: left for canvas, right for controls */
    display: grid;
    grid-template-columns: repeat(1, minmax(0, 1fr)); /* Default to single column on small screens */
    gap: 1.5rem; /* 24px */
    border-top-width: 1px;
    padding-top: 1.5rem;
    align-items: start; 
}

/* This activates the two-column layout on medium screens and up */
@media (min-width: 768px) {
    .review-item {
        grid-template-columns: repeat(2, minmax(0, 1fr));
    }
}
.zoom-controls {
    position: absolute;
    top: 0.5rem; /* 8px */
    right: 0.5rem; /* 8px */
    z-index: 10;
    display: flex;
    gap: 0.5rem; /* 8px */
}
.review-canvas {
    width: 100%;
    height: auto;
    border: 1px solid #e5e7eb; /* Optional: adds a nice border */
    border-radius: 0.375rem;   /* Optional: rounds the corners */
}
.review-item .bg-gray-50 {
    /* Styles for the right-hand control panel inside the modal */
    background-color: #f9fafb; /* gray-50 */
    padding: 1rem;
    border-radius: 0.5rem;
    display: flex;
    flex-direction: column;
    gap: 1rem; /* Creates space between the tools */
}
.review-item .bg-gray-50 {
    /* Styles for the right-hand control panel inside the modal */
    background-color: #f9fafb; /* gray-50 */
    padding: 1rem;
    border-radius: 0.5rem;
    display: flex;
    flex-direction: column;
    gap: 1rem; /* Creates space between the tools */
}
/* --- END OF NEW CSS BLOCK --- */

/* --- NEW SIDE-BY-SIDE LAYOUT STYLES --- */
#problem-view-grid {
    display: grid;
    grid-template-columns: repeat(1, minmax(0, 1fr)); /* Single column on small screens */
    gap: 1.5rem; /* 24px */
}

@media (min-width: 768px) { /* This is the 'md' breakpoint in Tailwind */
    #problem-view-grid {
        grid-template-columns: repeat(2, minmax(0, 1fr)); /* Two equal columns on large screens */
    }
}

#passage-container {
    background-color: white;
    padding: 0.5rem;
    border-radius: 0.5rem;
    border: 1px solid #e2e8f0;
    max-height: 85vh; /* Makes the passage scrollable on its own */
    overflow-y: auto;
    position: sticky; /* Makes it "sticky" */
    top: 1rem; /* Adjust as needed */
}

#passage-container canvas {
    width: 100%;
    height: auto;
}

#question-container {
    background-color: white;
    padding: 1.5rem; /* 24px */
    border-radius: 0.5rem;
    border: 1px solid #e2e8f0;
    /* This container will grow naturally */
}
/* --- END OF SIDE-BY-SIDE STYLES --- */


/* --- Review Modal Editor Styles --- */

/* --- Review Modal Editor Styles --- */
.layout-editor-active { cursor: crosshair; }
.layout-editor-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; }
.drawn-box { position: absolute; background-color: rgba(59, 130, 246, 0.4); border: 2px solid #2563eb; border-radius: 0.25rem; cursor: move; }
.drawn-box:hover .delete-btn { display: flex; }
.delete-btn { display: none; position: absolute; top: -10px; right: -10px; width: 20px; height: 20px; background-color: #ef4444; color: white; border-radius: 50%; align-items: center; justify-content: center; cursor: pointer; font-size: 12px; font-weight: bold; }
.selection-box { position: absolute; border: 2px dashed #10b981; background-color: rgba(167, 243, 208, 0.4); pointer-events: none; }
.crop-box-overlay { position: absolute; border: 2px dashed #f59e0b; background-color: rgba(245, 158, 11, 0.2); pointer-events: none; }
.key-drop-zone { border: 2px dashed #d1d5db; border-radius: 0.5rem; padding: 0.5rem; min-height: 3.5rem; display: flex; flex-direction: column; align-items: center; justify-content: center; background-color: #f9fafb; transition: background-color 0.2s ease; flex: 1; min-width: 100px; }
.key-drop-zone.dragover { background-color: #eef2ff; }
.drag-item { cursor: grab; padding: 0.5rem 1rem; border: 1px solid #d1d5db; background-color: white; border-radius: 0.5rem; box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05); transition: all 0.2s ease-in-out; touch-action: none; }
.drag-item:active { cursor: grabbing; }
.drag-item.dragged { opacity: 0.4; }
.drag-item.invisible { display: none; }
.touch-drag-ghost { position: fixed; pointer-events: none; z-index: 1000; transform: translate(-50%, -50%); }
.drop-zone { position: absolute; border: 2px dashed #4f46e5; border-radius: 0.5rem; background-color: rgba(239, 246, 255, 0.5); display: flex; align-items: center; justify-content: center; }
.drop-zone.dragover { background-color: rgba(191, 219, 254, 0.7); }
.drop-zone .drag-item { font-size: 0.875rem; padding: 0.25rem 0.5rem;}
    /* --- HEADER --- */
    .main-header {
        background: linear-gradient(90deg, #4f46e5, #7c3aed); /* Modern Indigo/Violet Gradient */
        color: white;
        padding: 1rem 1.5rem;
        border-radius: 0.75rem;
        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    .main-header p { color: #d1d5db; }

    /* --- PANELS & CARDS --- */
    .control-panel > div,
    #dashboard-content,
    .pathway-card {
        background-color: white;
        border: 1px solid #e5e7eb;
    }
    <div class="mb-4">
    <label for="pdf-upload" class="block text-lg font-medium text-gray-700 mb-2">1. Upload Exam PDF</label>
    <input type="file" id="pdf-upload" accept=".pdf" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100"/>
</div>

<div class="mb-4 p-4 bg-purple-50 rounded-lg border border-purple-200">
    <label for="rationale-upload" class="block text-lg font-medium text-purple-900 mb-2">2. Upload Rationales PDF</label>
    <p class="text-xs text-purple-700 mb-2">Upload the "Item Rationales" file to auto-fill explanations and correct answers.</p>
    <input type="file" id="rationale-upload" accept=".pdf" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-purple-100 file:text-purple-700 hover:file:bg-purple-200"/>
</div>
    .pathway-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
    }
    .teks-title { color: #1e3a8a; font-weight: 700; }
    .pathway-card .reset-pathway-btn { color: #ef4444; }
    
    /* --- BUTTONS --- */
    .practice-pathway-btn { background-color: #4f46e5; color: white; }
    .practice-pathway-btn:hover { background-color: #4338ca; }
    
    .start-quiz-btn { background-color: white; color: #4f46e5; border: 1px solid #4f46e5; }
    .start-quiz-btn:hover { background-color: #eef2ff; }
    
    .review-btn { background-color: #f3f4f6; color: #4b5563; border: 1px solid #d1d5db; }
    .review-btn:hover { background-color: #e5e7eb; }

    #review-all-btn { background-color: #f59e0b; color: white; }
    #review-all-btn:hover { background-color: #d97706; }
.print-btn { background-color: #059669; color: white; }
    .print-btn:hover { background-color: #047857; }
    
    .print-modal-loader {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background-color: rgba(255, 255, 255, 0.8);
        z-index: 10;
    }
    /* --- FORM ELEMENTS --- */
    .control-panel h2 { color: #1f2937; }
    .control-panel label { color: #4b5563; }
    .control-panel input[type="file"] { color: #4b5563; }
    .control-panel input[type="file"]::file-selector-button { background-color: #eef2ff; color: #4338ca; }
    #subject-dropdown { background-color: white; color: #1f2937; border-color: #d1d5db; }
    .control-panel .select-all-btn { color: #4f46e5; }
    .control-panel .filter-group { border-color: #e5e7eb; }
    .control-panel .filter-group span { color: #374151; }

    /* --- ALL OTHER STYLES (UNCHANGED) --- */
    .icon-btn { display: inline-flex; align-items: center; justify-content: center; gap: 0.5rem; }
    .student-view-bg { background-color:#e5e7eb; background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='80' height='80' viewBox='0 0 80 80'%3E%3Cg fill='%23e5e7eb' fill-opacity='0.4'%3E%3Cpath fill-rule='evenodd' d='M11 0l5 20H6l5-20zm42 31a3 3 0 100-6 3 3 0 000 6zM0 72h40v4H0v-4zm0-8h31.05a15.993 15.993 0 00-30.05 8H0v-4zm20-4h20v4H20v-4zm0-8h20v4H20v-4zm0-8h20v4H20v-4zm0-8h20v4H20v-4zm-20 0h20v4H0v-4zm0 8h20v4H0v-4zm0 8h20v4H0v-4zm0 8h20v4H0v-4z'/%3E%3C/g%3E%3C/svg%3E"); }
    .question-grid { display: flex; flex-wrap: wrap; gap: 4px; margin-top: 8px; }
    .question-box { width: 20px; height: 20px; border-radius: 4px; border: 1px solid rgba(0,0,0,0.1); transition: transform 0.2s ease, box-shadow 0.2s ease; cursor: pointer; }
    .question-box:hover { transform: scale(1.2); box-shadow: 0 0 5px rgba(0,0,0,0.3); }
    .status-box { width: 1.5rem; height: 1.5rem; border-radius: 0.375rem; margin: 0.125rem; transition: all 0.3s ease; position: relative; border: 1px solid rgba(0,0,0,0.1); transform-style: preserve-3d; perspective: 1000px; }
    .clickable-status-box { cursor: pointer; }
    .clickable-status-box:hover { transform: scale(1.1); }
    .clickable-status-box.current { box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.7); border-color: #3b82f6; }
    .status-not-started { background-color: #e5e7eb; }
    .status-correct { background-color: #10b981; }
    .status-incorrect { background-color: #ef4444; }
    .status-partial { background-color: #f59e0b; }
    .status-flagged::after { content: '⚑'; position: absolute; top: -5px; right: -5px; color: #db2777; font-size: 14px; font-weight: bold; }
    .status-box.flipping { animation: flip 0.6s ease-in-out forwards; }
    .status-box-face { position: absolute; width: 100%; height: 100%; border-radius: 0.375rem; backface-visibility: hidden; }
    .status-box-back { transform: rotateY(180deg); }
    @keyframes flip { from { transform: rotateY(0deg); } to { transform: rotateY(180deg); } }
.scalable-content {
    position: relative;
    transform-origin: top left;
    transition: transform 0.2s ease;
}
.main-header {
        background: linear-gradient(90deg, #1e3a8a, #3b82f6);
        padding: 1rem 1.5rem;
        border-radius: 0.75rem;
        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .pathway-card {
        background-color: white;
        border-radius: 0.75rem;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        transition: box-shadow 0.3s ease-in-out, transform 0.3s ease-in-out;
    }
    .pathway-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
    }

    .teks-title {
        color: #1e3a8a;
        font-weight: 700;
    }

    .icon-btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 0.5rem;
    }

    .student-view-bg {
         background-color: #e5e7eb;
         background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='80' height='80' viewBox='0 0 80 80'%3E%3Cg fill='%23e5e7eb' fill-opacity='0.4'%3E%3Cpath fill-rule='evenodd' d='M11 0l5 20H6l5-20zm42 31a3 3 0 100-6 3 3 0 000 6zM0 72h40v4H0v-4zm0-8h31.05a15.993 15.993 0 00-30.05 8H0v-4zm20-4h20v4H20v-4zm0-8h20v4H20v-4zm0-8h20v4H20v-4zm0-8h20v4H20v-4zm-20 0h20v4H0v-4zm0 8h20v4H0v-4zm0 8h20v4H0v-4zm0 8h20v4H0v-4z'/%3E%3C/g%3E%3C/svg%3E");
    }
    
    .content-transition {
        transition: opacity 0.3s ease-in-out;
    }
    .fade-out { opacity: 0; }
    .fade-in { opacity: 1; }

    #confetti-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 9999;
        overflow: hidden;
    }

    .confetti {
        position: absolute;
        width: 8px;
        height: 16px;
        background-color: #facc15;
        opacity: 0;
        animation: confetti-fall 2s ease-out forwards;
    }

    @keyframes confetti-fall {
        0% {
            transform: translateY(-100vh) rotate(0deg);
            opacity: 1;
        }
        100% {
            transform: translateY(100vh) rotate(720deg);
            opacity: 0;
        }
    }

    .canvas-container {
        width: 100%;
        max-width: 800px;
        overflow: auto;
        border-radius: 0.5rem;
        position: relative;
    }
    .scalable-content {
        position: relative;
        transform-origin: top left;
        transition: transform 0.2s ease;
    }
    #problem-canvas, .review-canvas, #graphing-canvas {
        display: block;
        width: 100%;
        height: auto;
        border: 1px solid #e2e8f0;
        border-radius: 0.5rem;
        image-rendering: -moz-crisp-edges;
        image-rendering: -webkit-crisp-edges;
        image-rendering: pixelated;
        image-rendering: crisp-edges;
    }
    .status-box {
        width: 1.5rem; height: 1.5rem; border-radius: 0.375rem;
        margin: 0.125rem; transition: all 0.3s ease;
        position: relative;
        border: 1px solid rgba(0,0,0,0.1);
    }
    .clickable-status-box {
        cursor: pointer;
    }
    .clickable-status-box:hover {
        transform: scale(1.1);
    }
    .clickable-status-box.current {
        box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.7);
        border-color: #3b82f6;
    }
    .status-not-started { background-color: #e5e7eb; }
    .status-correct { background-color: #10b981; }
    .status-incorrect { background-color: #ef4444; }
    .status-partial { background-color: #f59e0b; }
    .status-flagged::after {
        content: '⚑';
        position: absolute;
        top: -5px;
        right: -5px;
        color: #db2777;
        font-size: 14px;
        font-weight: bold;
    }
    #review-modal { transition: opacity 0.3s ease-in-out; }
    .loader {
        border: 4px solid #f3f3f3;
        border-radius: 50%;
        border-top: 4px solid #4f46e5;
        width: 24px;
        height: 24px;
        animation: spin 1s linear infinite;
    }
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
    
    .answer-button {
        transition: all 0.2s ease-in-out;
        background: #f3f4f6;
        border: 1px solid #d1d5db;
    }
    .answer-button:not(.disabled):hover {
        transform: scale(1.03);
        box-shadow: 0 4px 14px 0 rgba(0, 0, 0, 0.1);
        border-color: #9ca3af;
    }
    .answer-button.correct { 
        background: linear-gradient(45deg, #10b981, #6ee7b7);
        color: white !important; 
        animation: glow 1s ease-in-out;
        border-color: #059669;
    }
    .answer-button.incorrect { 
        background: linear-gradient(45deg, #ef4444, #f87171);
        color: white !important; 
        animation: shake 0.5s ease-in-out;
        border-color: #b91c1c;
    }
    .answer-button.selected { 
        background: linear-gradient(45deg, #3b82f6, #60a5fa);
        color: white;
        border-color: #1d4ed8;
        box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.4);
    }
    .answer-button.disabled, .disabled { 
        background-color: #d1d5db; 
        cursor: not-allowed; 
        opacity: 0.7; 
    }

    #feedback-message.animate-fade-in-scale {
        animation: fade-in-scale 0.4s ease-out forwards;
    }

    @keyframes shake {
        0%, 100% { transform: translateX(0); }
        25% { transform: translateX(-5px); }
        75% { transform: translateX(5px); }
    }

    @keyframes glow {
        0%, 100% { box-shadow: 0 0 5px #10b981; }
        50% { box-shadow: 0 0 20px #10b981; }
    }

    @keyframes fade-in-scale {
        from { opacity: 0; transform: scale(0.9); }
        to { opacity: 1; transform: scale(1); }
    }
    
    .hotspot-click-marker {
        position: absolute;
        width: 15px;
        height: 15px;
        border-radius: 50%;
        background-color: #3b82f6;
        border: 2px solid white;
        transform: translate(-50%, -50%);
        pointer-events: none;
        box-shadow: 0 0 5px rgba(0,0,0,0.5);
    }
    .hotspot-answer-reveal {
        position: absolute;
        background-color: rgba(16, 185, 129, 0.4);
        border: 2px solid #059669;
        border-radius: 0.25rem;
        pointer-events: none;
    }
    
    #graphing-canvas { cursor: crosshair; background-color: #fff; }
   .graph-type-selector { display: flex; justify-content: center; gap: 0.5rem; margin-bottom: 1rem; }
    .graph-type-btn { padding: 0.5rem 1rem; border: 1px solid #d1d5db; background-color: #f9fafb; border-radius: 0.375rem; font-weight: 500; cursor: pointer; transition: all 0.2s ease; }
    .graph-type-btn.active { background-color: #4f46e5; color: white; border-color: #4f46e5; }
    .graph-type-btn:disabled { background-color: #e5e7eb; cursor: not-allowed; color: #9ca3af; }
    .inline-choice-select {
        display: inline-block;
        width: auto;
        padding: 0.25rem 1.5rem 0.25rem 0.5rem;
        margin: 0 0.25rem;
        border: 1px solid #d1d5db;
        border-radius: 0.375rem;
        background-color: white;
        -webkit-appearance: none;
        -moz-appearance: none;
        appearance: none;
        background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
        background-position: right 0.5rem center;
        background-repeat: no-repeat;
        background-size: 1.5em 1.5em;
    }
    .filter-group { max-height: 150px; overflow-y: auto; border: 1px solid #e5e7eb; padding: 0.5rem; border-radius: 0.5rem; }
    details > summary { 
        cursor: pointer; 
        font-weight: 600; 
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0.5rem;
        list-style: none; /* Hide default marker */
    }
    details > summary::-webkit-details-marker {
        display: none; /* Hide default marker for Chrome/Safari */
    }
    details > summary::before {
        content: '▼';
        margin-right: 0.5rem;
        font-size: 0.6em;
        transition: transform 0.2s;
    }
    details[open] > summary::before {
        transform: rotate(180deg);
    }
    details { padding-left: 1rem; margin-bottom: 0.5rem; }
    #subject-dropdown {
        width: 100%;
        padding: 0.5rem;
        border-radius: 0.375rem;
        border: 1px solid #d1d5db;
        background-color: white;
        margin-bottom: 1rem;
    }
</style>
</head>
<body class="bg-gray-100">
    <div id="confetti-container"></div>
    <div class="container mx-auto p-4 sm:p-6 lg:p-8">
        <header class="main-header text-center mb-8">
            <div class="text-left">
                <h1 class="text-3xl sm:text-4xl font-bold text-white">STAAR Mastery Pathway</h1>
                <p class="text-md text-blue-200 mt-2">Upload, Analyze, and Assign Targeted Pathways.</p>
            </div>
           <button id="home-btn" class="hidden px-4 py-2 bg-white text-blue-700 font-semibold rounded-md hover:bg-blue-50">
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-house-door-fill inline-block mr-2" viewBox="0 0 16 16"><path d="M6.5 14.5v-3.505c0-.245.25-.495.5-.495h2c.25 0 .5.25.5.5v3.5a.5.5 0 0 0 .5.5h4a.5.5 0 0 0 .5-.5v-7a.5.5 0 0 0-.146-.354L13 5.793V2.5a.5.5 0 0 0-.5-.5h-1a.5.5 0 0 0-.5.5v1.293L8.354 1.146a.5.5 0 0 0-.708 0l-6 6A.5.5 0 0 0 1.5 7.5v7a.5.5 0 0 0 .5.5h4a.5.5 0 0 0 .5-.5z"/></svg>
    Home
</button>
           
        </header>

        <!-- Main Content Area -->
        <div id="app-content">
            <!-- Dashboard / Teacher View -->
            <div id="dashboard-view">
                <div class="grid grid-cols-1 lg:grid-cols-12 gap-8">
                    <!-- Left Column: Controls -->
<div class="lg:col-span-4 space-y-6 control-panel">
                        <div class="bg-white p-6 rounded-lg shadow-lg border border-gray-200 h-fit">
                            <h2 class="text-xl font-bold text-gray-800 mb-4">Controls</h2>
                             <div class="mb-4">
                                <label for="subject-dropdown" class="block text-sm font-medium text-gray-700 mb-1">Select Subject</label>
                                <select id="subject-dropdown"></select>
                             </div>
                            <div class="mb-4">
                                <label for="pdf-upload" class="block text-lg font-medium text-gray-700 mb-2">1. Upload PDF</label>
                                <input type="file" id="pdf-upload" accept=".pdf" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100"/>
                            </div>
                            <div class="mb-4 p-4 bg-purple-50 rounded-lg border border-purple-200">
    <label for="rationale-upload" class="block text-lg font-medium text-purple-900 mb-2">2. Upload Rationales PDF</label>
    <p class="text-xs text-purple-700 mb-2">Upload the "Item Rationales" file to auto-fill explanations.</p>
    <input type="file" id="rationale-upload" accept=".pdf" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-purple-100 file:text-purple-700 hover:file:bg-purple-200"/>
</div>
                            <div id="status" class="text-center text-sm my-2"></div>
                            <div id="review-all-container" class="mt-4 hidden">
                                <button id="review-all-btn" class="w-full px-4 py-2 bg-yellow-500 text-white font-semibold rounded-md hover:bg-yellow-600">Review Questions</button>
                            </div>
                        </div>
                        <div class="mb-4">
    <label for="pathway-sort-dropdown" class="block text-sm font-medium text-gray-700 mb-1">Sort Order</label>
    <select id="pathway-sort-dropdown" class="w-full p-2 border rounded-md border-gray-300 shadow-sm">
        <option value="logical">Logical (Year Newest → Q# Ascending)</option>
        <option value="numerical">Numerical (Q# Ascending → Year Oldest)</option>
        <option value="random">Random</option>
    </select>
</div>
                        <div id="custom-pathway-builder" class="bg-white p-6 rounded-lg shadow-lg border border-gray-200 h-fit hidden">
                            <h2 class="text-xl font-bold text-gray-800 mb-4">Custom Pathway Generator</h2>
                            <div class="space-y-4">
                                <div id="filter-container"></div>
                                <button id="generate-pathway-btn" class="w-full px-4 py-2 bg-indigo-600 text-white font-semibold rounded-md hover:bg-indigo-700">Generate Custom Pathway</button>
                            </div>
                        </div>
                    </div>
                    <!-- Right Column: Pathways -->
                    <div id="dashboard-content" class="lg:col-span-8 space-y-4 bg-white p-6 rounded-lg shadow-lg border border-gray-200">
                           <div class="flex justify-end mb-4">
                               <button id="view-toggle-btn" class="px-4 py-2 bg-gray-200 text-sm font-semibold rounded-md">Group by: Year</button>
                           </div>
                           <div id="pathway-display"></div>
                           <div id="placeholder-view" class="flex items-center justify-center h-full">
                               <div class="text-center">
                                   <svg class="mx-auto h-12 w-12 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 21a4 4 0 01-4-4V5a2 2 0 012-2h4l2 2h4a2 2 0 012 2v12a4 4 0 01-4 4H7z"></path></svg>
                                   <h3 class="mt-2 text-sm font-medium text-gray-900">Upload a File to Begin</h3>
                                   <p class="mt-1 text-sm text-gray-500">Your mastery pathway will appear here.</p>
                               </div>
                           </div>
                    </div>
                </div>
            </div>

            <!-- Problem / Student View -->
         <div id="problem-view" class="hidden student-view-bg content-transition">
                <div class="w-full p-4 bg-white rounded-lg shadow-md border border-gray-200 mb-4">
                    <div class="flex justify-between items-center">
                        <div id="progress-indicator" class="font-semibold text-gray-700"></div>
                        <div id="timer-display" class="font-bold text-xl text-blue-600"></div>
                        <div class="flex items-center space-x-4">
                            <button id="edit-question-btn" title="Review and Edit this Question" class="px-3 py-1 bg-purple-100 text-purple-700 text-sm rounded-full hover:bg-purple-200">✎ Edit</button>
                            <button id="flag-question-btn" ...>⚑ Flag</button>
                            <button id="toggle-teks-btn" ...>Show Standard</button>
                        </div>
                    </div>
                    <div id="clickable-progress-bar" class="flex flex-wrap items-center justify-center p-2 bg-gray-100 rounded-lg mt-4"></div>
                    <div id="teks-context" class="w-full p-3 mt-4 bg-gray-50 rounded-md border border-gray-200 hidden">
                        <p class="font-semibold" id="teks-context-new"></p>
                        <p class="text-sm italic text-gray-600" id="teks-context-old"></p>
                    </div>
                </div>

                <div id="problem-view-grid">
                  <div id="passage-container">
                        <div class="zoom-controls">
                            <button id="passage-zoom-in-btn" class="px-2 py-1 bg-gray-200 rounded-md">+</button>
                            <button id="passage-zoom-out-btn" class="px-2 py-1 bg-gray-200 rounded-md">-</button>
                        </div>
                        <div id="passage-content-wrapper">
                        
                    </div>
                    </div>

                    <div id="question-container">
                        <div class="canvas-container mx-auto relative">
                            <div class="zoom-controls">
                                <button id="zoom-in-btn" class="px-2 py-1 bg-gray-200 rounded-md">+</button>
                                <button id="zoom-out-btn" class="px-2 py-1 bg-gray-200 rounded-md">-</button>
                            </div>
                            <div id="scalable-content" class="scalable-content">
                                </div>
                        </div>
                        <div id="feedback-message" class="mt-4 text-center text-lg font-bold"></div>
                        <div id="correct-answer-container" class="mt-4 p-4 bg-green-50 border-l-4 border-green-300 rounded-r-lg hidden">
                            <div id="correct-answer-display" class="text-sm font-bold text-green-800"></div>
                        </div>
                        <div id="explanation-box" class="mt-2 p-4 bg-gray-50 border-l-4 border-gray-300 rounded-r-lg hidden">
                            <h4 class="font-bold text-gray-800">Analysis & Explanation</h4>
                            <p id="explanation-text" class="text-sm text-gray-700 mt-1"></p>
                        </div>
                        <div id="answer-interface" class="mt-4 w-full"></div>
                        <div id="navigation-controls" class="w-full flex justify-between items-center mt-6 space-x-2">
                            <button id="previous-problem-btn" class="px-4 py-2 bg-gray-500 text-white rounded-md hover:bg-gray-600">Previous</button>
                            <div id="quiz-nav-center" class="flex-grow flex justify-center">
                                <button id="skip-problem-btn" class="px-4 py-2 bg-gray-500 text-white rounded-md hover:bg-gray-600 hidden">Skip for Now</button>
                            </div>
                            <button id="retry-problem-btn" class="px-4 py-2 bg-yellow-500 text-white rounded-md hover:bg-yellow-600 hidden">Retry Problem</button>
                            <button id="back-to-dashboard-btn" class="px-4 py-2 bg-gray-500 text-white rounded-md hover:bg-gray-600">Back to Pathway</button>
                            <button id="next-problem-btn" class="px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700">Next</button>
                        </div>
                    </div>
                
            </div>
            
            <!-- Results View -->
            <div id="results-view" class="hidden">
                <div class="w-full bg-white p-6 rounded-lg shadow-lg border border-gray-200">
                    <div id="results-header">
                        <h2 id="results-title" class="text-3xl font-bold text-gray-800 mb-2"></h2>
                        <p id="results-summary" class="text-lg text-gray-600 mb-6"></p>
                    </div>
                    <div id="missed-questions-container" class="mb-6">
                        <h3 class="text-xl font-semibold mb-4 border-b pb-2">Questions for Review</h3>
                        <div id="missed-questions-grid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4"></div>
                    </div>
                    <div id="results-analysis-container" class="space-y-4"></div>
                    <div class="w-full flex justify-end items-center mt-8 space-x-4">
                         <button id="print-results-btn" class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700">Print Results</button>
                         <button id="download-results-btn" class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700">Download Results</button>
                         <button id="results-back-btn" class="px-4 py-2 bg-gray-500 text-white rounded-md hover:bg-gray-600">Back to Dashboard</button>
                    </div>
                </div>
            </div>

        </div>

        <!-- Review Modal -->
        <div id="review-modal" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center p-4 hidden z-50">
            <div class="bg-white rounded-lg shadow-xl w-full max-w-6xl max-h-[90vh] overflow-y-auto p-6">
                <div class="flex justify-between items-center border-b pb-3 mb-4 sticky top-0 bg-white z-10">
                    <h2 id="review-modal-title" class="text-2xl font-bold">Review Questions</h2>
                    <div class="flex items-center space-x-4">
                        <button id="filter-review-btn" class="px-4 py-2 bg-yellow-400 text-yellow-800 text-sm font-semibold rounded-md hover:bg-yellow-500">Show Only Questions Needing Review</button>
                        <button id="close-review-modal-btn" class="text-3xl font-bold text-gray-500 hover:text-gray-800">&times;</button>
                    </div>
                </div>
                <div id="review-modal-content" class="space-y-8"></div>
            </div>
        </div>

        <!-- Quiz Setup Modal -->
        <div id="quiz-setup-modal" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center p-4 hidden z-50">
            <div class="bg-white rounded-lg shadow-xl w-full max-w-md p-6">
                <h2 class="text-2xl font-bold mb-4">Quiz Setup</h2>
                <div class="space-y-4">
                    <div class="flex items-center justify-between">
                        <label for="enable-timer-toggle" class="font-medium text-gray-700">Enable Timer?</label>
                        <input type="checkbox" id="enable-timer-toggle" class="h-6 w-11 rounded-full bg-gray-300 relative inline-flex items-center cursor-pointer transition-colors duration-300 ease-in-out focus:outline-none" />
                    </div>
                    <div id="timer-options" class="hidden">
                        <label for="time-per-question" class="block text-sm font-medium text-gray-700">Time per question (minutes)</label>
                        <input type="number" id="time-per-question" value="2" min="1" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm">
                    </div>
                </div>
                <div class="mt-6 flex justify-end space-x-4">
                    <button id="cancel-quiz-btn" class="px-4 py-2 bg-gray-200 text-gray-700 rounded-md hover:bg-gray-300">Cancel</button>
                    <button id="begin-quiz-btn" class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700">Begin Quiz</button>
                </div>
            </div>
        </div>
    </div>
<div id="print-options-modal" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center p-4 hidden z-50">
    <div class="bg-white rounded-lg shadow-xl w-full max-w-md p-6 relative">
        <div id="print-modal-loader" class="print-modal-loader hidden">
            <div class="loader"></div>
        </div>
        
        <h2 class="text-2xl font-bold mb-4">Print Options</h2>
        <div class="space-y-4">
            <div class="flex items-center justify-between">
                <label for="include-answers-toggle" class="font-medium text-gray-700">Include Answer Key?</label>
                <input type="checkbox" id="include-answers-toggle" class="h-6 w-11 rounded-full bg-gray-300 relative inline-flex items-center cursor-pointer transition-colors duration-300 ease-in-out focus:outline-none" />
            </div>
            
            <div class="flex items-center justify-between">
                <label for="include-rationales-toggle" class="font-medium text-gray-700">Include Item Rationales?</label>
                <input type="checkbox" id="include-rationales-toggle" class="h-6 w-11 rounded-full bg-gray-300 relative inline-flex items-center cursor-pointer transition-colors duration-300 ease-in-out focus:outline-none" />
            </div>
        </div>

        <div class="mt-6 flex justify-end space-x-4">
            <button id="cancel-print-btn" class="px-4 py-2 bg-gray-200 text-gray-700 rounded-md hover:bg-gray-300">Cancel</button>
            <button id="generate-print-btn" class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700">Generate Printable</button>
        </div>
    </div>
</div>
    <script>
        // This script runs when the entire window has loaded, ensuring all HTML elements are available.
        window.onload = function() {
            // --- App Initialization ---
            // Check if the PDF.js library is loaded. If not, log an error and stop.
            if (typeof pdfjsLib === 'undefined') {
                console.error("PDF.js library not loaded. Please check the script link.");
                return;
            }
            // Set the location of the PDF.js worker script, which is necessary for the library to run in the background.
            pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.worker.min.js';
// ADD THIS ENTIRE NEW OBJECT
// This object holds the specific parsing "recipes" for each subject.
const ParserSchemas = {
    'Biology': {
        // Regex to find the start of a question block
        questionStartRegex: /(\d{4})\s*[-–—]\s*Q\d+/,
        // Regex to extract the specific Q#
        questionIdRegex: /\d{4}\s*[-–—]\s*(Q\d+)/,
        // Regex to find TEKS and RC in the header (if available)
        teksRcRegex: /([A-Z0-9\.]+\([A-Z]\))\s+RC\s*(\d+)/,
        // Regex to find the main TEKS description
        teksRegex: /([A-Zλ0-9\.]+\([A-Z0-9]\))\s*([\s\S]+?)\s*Analysis of Assessed Standards/im,
        // Regex to find Item Type
        itemTypeMatch: /Item Type\s*([\s\S]+?)\s*Stimulus/,
        // Regex to find the Cluster
        clusterMatch: /Cluster\s*([\s\S]+?)\s*Subcluster/,
        // Keywords for auto-cropping
        analysisAnchor: 'Analysis of Assessed Standards',
        bottomAnchor: 'Correct Answer'
    },
    'Algebra 1': {
        // We'll assume Algebra 1 uses the same flexible format
        questionStartRegex: /(\d{4})\s*[-–—]?\s*Q\d+/, // Flexible: allows dash, hyphen, or nothing
        questionIdRegex: /\d{4}\s*[-–—]?\s*(Q\d+)/,    // Flexible
        teksRcRegex: /([A-Z0-9\.]+\([A-Z]\))\s+RC\s*(\d+)/,
        teksRegex: /([A-Zλ0-9\.]+\([A-Z0-9]\))\s*([\s\S]+?)\s*Analysis of Assessed Standards/im,
        itemTypeMatch: /Item Type\s*([\s\S]+?)\s*Stimulus/,
        clusterMatch: /Cluster\s*([\s\S]+?)\s*Subcluster/,
        analysisAnchor: 'Analysis of Assessed Standards',
        bottomAnchor: 'Correct Answer'
    },
    'English 1': {
        // This is the NEW, CORRECTED schema based on your PDF
        questionStartRegex: /(\d{4})\s*[-–—]?\s*Q\d+/, // Flexible: catches "2025-Q11", "2025Q32", and "2025 – Q46"
        questionIdRegex: /\d{4}\s*[-–—]?\s*(Q\d+)/,    // Flexible
        teksRcRegex: /([A-Z0-9\.]+\([A-Z]\))\s+RC\s*(\d+)/, // This won't find anything, which is correct for English
        teksRegex: /([A-Zλ0-9\.]+\([A-Z0-9]\))\s*([\s\S]+?)\s*Analysis of Assessed Standards/im,
        itemTypeMatch: /Item Type\s*([\s\S]+?)\s*Stimulus/,
        clusterMatch: /Cluster\s*([\s\S]+?)\s*Subcluster/, // Your PDF confirms it uses "Cluster" [cite: 3066]
        analysisAnchor: 'Analysis of Assessed Standards', // [cite: 3065]
        bottomAnchor: 'Correct Answer' // [cite: 3083]
    },
    'English 2': {
        // We'll use the same correct schema for English 2
        questionStartRegex: /(\d{4})\s*[-–—]?\s*Q\d+/, 
        questionIdRegex: /\d{4}\s*[-–—]?\s*(Q\d+)/,    
        teksRcRegex: /([A-Z0-9\.]+\([A-Z]\))\s+RC\s*(\d+)/,
        teksRegex: /([A-Zλ0-9\.]+\([A-Z0-9]\))\s*([\s\S]+?)\s*Analysis of Assessed Standards/im,
        itemTypeMatch: /Item Type\s*([\s\S]+?)\s*Stimulus/,
        clusterMatch: /Cluster\s*([\s\S]+?)\s*Subcluster/,
        analysisAnchor: 'Analysis of Assessed Standards',
        bottomAnchor: 'Correct Answer'
    },
    'U.S. History': {
        // We'll assume USH also uses the flexible format
        questionStartRegex: /(\d{4})\s*[-–—]?\s*Q\d+/, 
        questionIdRegex: /\d{4}\s*[-–—]?\s*(Q\d+)/,    
        teksRcRegex: /([A-Z0-9\.]+\([A-Z]\))\s+RC\s*(\d+)/,
        teksRegex: /([A-Zλ0-9\.]+\([A-Z0-9]\))\s*([\s\S]+?)\s*Analysis of Assessed Standards/im,
        itemTypeMatch: /Item Type\s*([\s\S]+?)\s*Stimulus/,
        clusterMatch: /Cluster\s*([\s\S]+?)\s*Subcluster/,
        analysisAnchor: 'Analysis of Assessed Standards',
        bottomAnchor: 'Correct Answer'
    }
};
 // --- Encapsulated State ---
            // This object holds all the dynamic data for the application.
            const AppState = {
                currentSubject: 'Biology', // Default subject
                subjects: {
                    'Algebra 1': { pdfDoc: null, rationalePdfDoc: null, allQuestions: [], masteryState: {}, teksToRcMap: {}, customPathways: [] },
                    'Biology': { pdfDoc: null, rationalePdfDoc: null, allQuestions: [], masteryState: {}, teksToRcMap: {}, customPathways: [] },
                    'English 1': { pdfDoc: null, rationalePdfDoc: null, allQuestions: [], masteryState: {}, teksToRcMap: {}, customPathways: [] },
                    'English 2': { pdfDoc: null, rationalePdfDoc: null, allQuestions: [], masteryState: {}, teksToRcMap: {}, customPathways: [] },
                    'U.S. History': { pdfDoc: null, rationalePdfDoc: null, allQuestions: [], masteryState: {}, teksToRcMap: {}, customPathways: [] },
                },
                difficultySettings: {
                    mastersThreshold: 40, // If state % < 40, it's Masters
                    meetsThreshold: 65,   // If state % < 65 (and > 40), it's Meets
                    targets: { approaches: 38, meets: 60, masters: 82 } // Student Score Goals
                },
                currentPathway: { // Holds data for the currently active quiz or practice session.
                    teks: null,
                    questions: [],
                    currentIndex: 0,
                    activeQuestion: null,
                    userSelections: [],
                    graphingPoints: [], 
                    flagged: {}, 
                    isQuiz: false,
                    timerSettings: null,
                    startTime: null,
                },
                questionTimer: null, // Holds the interval for the quiz timer.
                draggedItem: null, // Tracks the element being dragged in a drag-and-drop question.
                touchDragGhost: null, // Ghost element for touch dragging
                zoomLevel: 1.0, // Tracks the zoom level for the question canvas.
                passageZoomLevel: 1.0, // Tracks the zoom level for the passage canvas.
                unparsedPages: 0, // Counts pages that couldn't be parsed into questions.
                dashboardViewMode: 'cluster', // Toggles between 'year' and 'cluster' view on the dashboard.
                isDraggingBox: false, // State for dragging interactive zones in the review modal.
                draggedBoxElement: null,
                draggedBoxZone: null,
                draggedBoxQuestion: null,
                dragStartX: 0,
                dragStartY: 0,
            };
            // --- DOM Elements ---
            // Caching all necessary DOM elements for quick access.
            
            const fileInput = document.getElementById('pdf-upload');
            const statusDiv = document.getElementById('status');
            const dashboardContent = document.getElementById('dashboard-content');
            const pathwayDisplay = document.getElementById('pathway-display');
            const placeholderView = document.getElementById('placeholder-view');
            const answerInterface = document.getElementById('answer-interface');
            const backToDashboardBtn = document.getElementById('back-to-dashboard-btn');
            const toggleTeksBtn = document.getElementById('toggle-teks-btn');
            const teksContextDiv = document.getElementById('teks-context');
            const teksContextNew = document.getElementById('teks-context-new');
            const teksContextOld = document.getElementById('teks-context-old');
            const dashboardView = document.getElementById('dashboard-view');
            const problemView = document.getElementById('problem-view');
            const resultsView = document.getElementById('results-view');
            const progressIndicator = document.getElementById('progress-indicator');
            const clickableProgressBar = document.getElementById('clickable-progress-bar');
            const reviewModal = document.getElementById('review-modal');
            const reviewModalTitle = document.getElementById('review-modal-title');
            const reviewModalContent = document.getElementById('review-modal-content');
            const closeReviewModalBtn = document.getElementById('close-review-modal-btn');
            const customPathwayBuilder = document.getElementById('custom-pathway-builder');
            const filterContainer = document.getElementById('filter-container');
            const generatePathwayBtn = document.getElementById('generate-pathway-btn');
            const explanationBox = document.getElementById('explanation-box');
            const explanationText = document.getElementById('explanation-text');
            const previousProblemBtn = document.getElementById('previous-problem-btn');
            const nextProblemBtn = document.getElementById('next-problem-btn');
            const retryProblemBtn = document.getElementById('retry-problem-btn');
            const skipProblemBtn = document.getElementById('skip-problem-btn');
            const correctAnswerContainer = document.getElementById('correct-answer-container');
            const correctAnswerDisplay = document.getElementById('correct-answer-display');
            const feedbackMessage = document.getElementById('feedback-message');
            const zoomInBtn = document.getElementById('zoom-in-btn');
            const zoomOutBtn = document.getElementById('zoom-out-btn');
            const scalableContent = document.getElementById('scalable-content');
            const resultsBackBtn = document.getElementById('results-back-btn');
            const printResultsBtn = document.getElementById('print-results-btn');
            const downloadResultsBtn = document.getElementById('download-results-btn');
            const viewToggleBtn = document.getElementById('view-toggle-btn');
            const flagQuestionBtn = document.getElementById('flag-question-btn');
            const filterReviewBtn = document.getElementById('filter-review-btn');
            const reviewAllContainer = document.getElementById('review-all-container');
            const reviewAllBtn = document.getElementById('review-all-btn');
            const resultsTitle = document.getElementById('results-title');
            const resultsSummary = document.getElementById('results-summary');
            const missedQuestionsGrid = document.getElementById('missed-questions-grid');
            const resultsAnalysisContainer = document.getElementById('results-analysis-container');
            const quizSetupModal = document.getElementById('quiz-setup-modal');
            const enableTimerToggle = document.getElementById('enable-timer-toggle');
            const timerOptions = document.getElementById('timer-options');
            const timePerQuestionInput = document.getElementById('time-per-question');
            const cancelQuizBtn = document.getElementById('cancel-quiz-btn');
            const beginQuizBtn = document.getElementById('begin-quiz-btn');
            const timerDisplay = document.getElementById('timer-display');
            const homeBtn = document.getElementById('home-btn');
            const subjectDropdown = document.getElementById('subject-dropdown');
            const editQuestionBtn = document.getElementById('edit-question-btn');
            const printOptionsModal = document.getElementById('print-options-modal');
            const cancelPrintBtn = document.getElementById('cancel-print-btn');
            const generatePrintBtn = document.getElementById('generate-print-btn');
            const includeAnswersToggle = document.getElementById('include-answers-toggle');
            const printModalLoader = document.getElementById('print-modal-loader');
function handleEditCurrentQuestion() {
    const currentQuestion = AppState.currentPathway.activeQuestion;
    if (currentQuestion) {
        showReviewModal(`Editing: ${currentQuestion.id}`, currentQuestion);
    }
}

            // --- Event Listeners ---
            // Assigning functions to be called when specific events occur on elements.
            fileInput.addEventListener('change', handleFileSelect);
            editQuestionBtn.addEventListener('click', handleEditCurrentQuestion);
            backToDashboardBtn.addEventListener('click', showDashboard);
            homeBtn.addEventListener('click', showDashboard);
            resultsBackBtn.addEventListener('click', showDashboard);
            toggleTeksBtn.addEventListener('click', toggleTeksVisibility);
            closeReviewModalBtn.addEventListener('click', () => {
                reviewModal.classList.add('hidden');
                updateReviewAllButton();
                renderDashboard(); 
                saveState();
            });
            generatePathwayBtn.addEventListener('click', generateCustomPathway);
        // Question Zoom Buttons
            zoomInBtn.addEventListener('click', () => updateZoom(0.2, 'question'));
            zoomOutBtn.addEventListener('click', () => updateZoom(-0.2, 'question'));
            
            // Passage Zoom Buttons
            document.getElementById('passage-zoom-in-btn').addEventListener('click', () => updateZoom(0.2, 'passage'));
            document.getElementById('passage-zoom-out-btn').addEventListener('click', () => updateZoom(-0.2, 'passage'));
            printResultsBtn.addEventListener('click', printResults);
            downloadResultsBtn.addEventListener('click', downloadResults);
            viewToggleBtn.addEventListener('click', toggleDashboardView);
            flagQuestionBtn.addEventListener('click', toggleFlagCurrentQuestion);
            filterReviewBtn.addEventListener('click', toggleReviewFilter);
            reviewAllBtn.addEventListener('click', reviewAllNeedingSetup);
            resultsAnalysisContainer.addEventListener('click', (e) => {
                if (e.target.matches('.practice-topic-btn')) {
                    const topic = e.target.dataset.topic;
                    startTopicPractice(topic);
                }
            });
     missedQuestionsGrid.addEventListener('click', (e) => {
    const reviewButton = e.target.closest('.review-missed-btn');
    if (reviewButton) {
        const questionId = reviewButton.dataset.questionId;
        // Find the index in the CURRENT pathway so we can jump to it
        const index = AppState.currentPathway.questions.findIndex(q => q.id === questionId);
        
        if (index !== -1) {
            // 1. Switch back to student view
            showProblemView();
            // 2. Jump to the question and Force Reveal the answer
            reviewMissedQuestion(index);
        }
    }
});
  /**
 * Jumps to a question and immediately reveals the answer/rationale.
 * UPDATED: Changes "Back" button to return to Results.
 */
async function reviewMissedQuestion(index) {
    // 1. Render the problem normally
    AppState.currentPathway.currentIndex = index;
    await renderProblem(AppState.currentPathway.questions[index]);

    // 2. HIJACK THE NAVIGATION BUTTONS
    const backBtn = document.getElementById('back-to-dashboard-btn');
    const originalText = backBtn.textContent;
    const originalOnClick = backBtn.onclick;

    // Change button to "Back to Results"
    backBtn.textContent = "⬅ Back to Results";
    backBtn.onclick = () => {
        // Restore original state
        backBtn.textContent = "Back to Pathway";
        backBtn.onclick = showDashboard; // Restore original dashboard link
        renderResultsScreen(); // Go back to results
    };
    
    // Hide 'Next/Finish' to force them to use the 'Back to Results' button
    // (Optional: keeps flow simple so they don't get lost)
    document.getElementById('next-problem-btn').classList.add('hidden');

    // 3. Force the "Reveal" state (Existing Logic)
    const question = AppState.currentPathway.questions[index];
    const pathway = AppState.currentPathway;
    
    // Lock Interface
    answerInterface.querySelectorAll('button, textarea, select, canvas').forEach(el => {
        el.classList.add('disabled');
        el.onclick = null;
    });
    
    // Show Correct Answer
    correctAnswerContainer.classList.remove('hidden');
    const answerString = question.answerText?.join(', ') || 'N/A';
    correctAnswerDisplay.textContent = `The correct answer is: ${answerString}`;

    // Highlight Buttons
    answerInterface.querySelectorAll('.answer-button').forEach(btn => {
        const btnText = btn.textContent.trim();
        if (question.answerText && question.answerText.includes(btnText)) {
            btn.classList.add('correct');
        } 
        pathway.userSelections.flat().forEach(userSel => {
            if (userSel === btnText && !question.answerText.includes(userSel)) {
                btn.classList.add('incorrect');
            }
        });
    });

    // Generate Rationale HTML
    let feedbackHTML = "";
    if (question.answerText && question.rationaleMap) {
        question.answerText.forEach(ans => {
            if (question.rationaleMap[ans]) {
                feedbackHTML += `
                    <div class="mt-2 p-3 rounded border bg-green-50 border-green-200 text-green-800 text-left text-sm">
                        <span class="font-bold block mb-1">✅ Correct Rationale (Option ${ans}):</span>
                        ${question.rationaleMap[ans]}
                    </div>`;
            }
        });
    }
    if (question.rationaleMap && question.rationaleMap['Solution']) {
        feedbackHTML += `
            <div class="mt-2 p-3 rounded border bg-blue-50 border-blue-200 text-blue-800 text-left text-sm">
                <span class="font-bold block mb-1">📘 General Analysis:</span>
                ${question.rationaleMap['Solution']}
            </div>`;
    }
    feedbackMessage.innerHTML = feedbackHTML;
}

            enableTimerToggle.addEventListener('change', () => {
                timerOptions.classList.toggle('hidden', !enableTimerToggle.checked);
            });
            cancelQuizBtn.addEventListener('click', () => quizSetupModal.classList.add('hidden'));
            subjectDropdown.addEventListener('change', (e) => switchSubject(e.target.value));


         nextProblemBtn.addEventListener('click', () => {
                const pathway = AppState.currentPathway;
                const isLastQuestion = pathway.currentIndex === pathway.questions.length - 1;

                if (pathway.isQuiz) {
                    // In a quiz, always evaluate the answer before moving on or finishing.
                    evaluateAndAdvanceQuiz(false, isLastQuestion);
                } else {
                    // --- PRACTICE MODE ---
                    if (!isLastQuestion) {
                        pathway.currentIndex++;
                        renderProblem(pathway.questions[pathway.currentIndex]);
                    } else {
                        // LOGGING THE TRANSITION ATTEMPT
                        console.log(`%c[PATHWAY] Final question submitted. Attempting to render results screen.`, "color: blue; font-weight: bold;");
                        renderResultsScreen();
                    }
                }
            });

            skipProblemBtn.addEventListener('click', () => {
                const pathway = AppState.currentPathway;
                const subjectData = getCurrentSubjectData();
                const mastery = subjectData.masteryState[pathway.teks];
                const hasUnanswered = Object.values(mastery).some(s => s === 'not-started');
                const isLastQuestion = pathway.currentIndex === pathway.questions.length - 1;

                if (isLastQuestion && !hasUnanswered) {
                     renderResultsScreen();
                } else if (isLastQuestion && hasUnanswered) {
                     showFinishConfirmationModal();
                }
                else if (pathway.currentIndex < pathway.questions.length - 1) {
                    pathway.currentIndex++;
                    renderProblem(pathway.questions[pathway.currentIndex]);
                }
            });

            previousProblemBtn.addEventListener('click', () => {
                if (AppState.currentPathway.currentIndex > 0) {
                    AppState.currentPathway.currentIndex--;
                    renderProblem(AppState.currentPathway.questions[AppState.currentPathway.currentIndex]);
                }
            });

            retryProblemBtn.addEventListener('click', () => {
                renderProblem(AppState.currentPathway.questions[AppState.currentPathway.currentIndex]);
            });

            // --- Core Logic ---

            /**
             * Handles the PDF file selection. This is the entry point for the app's main functionality.
             * @param {Event} e The file input change event.
             */
            function handleFileSelect(e) {
                const file = e.target.files[0];
                if (!file || file.type !== 'application/pdf') return;
                
                const subjectData = getCurrentSubjectData();
                subjectData.allQuestions = [];
                subjectData.masteryState = {};
                subjectData.teksToRcMap = {};
                
                statusDiv.innerHTML = '<div class="flex items-center justify-center"><div class="loader mr-2"></div>Processing PDF...</div>';
                const fileReader = new FileReader();
                fileReader.onload = async function() {
                    const typedarray = new Uint8Array(this.result);
                    // Use PDF.js to load the document.
                    subjectData.pdfDoc = await pdfjsLib.getDocument(typedarray).promise;
                    // Pre-process the PDF to build a map of TEKS to RC for later use.
                    subjectData.teksToRcMap = await buildTeksToRcMap(subjectData.pdfDoc);
                    // Parse all pages to extract question data.
                    subjectData.allQuestions = await parseAllPages();
                    let statusMessage = `Processing complete. Found ${subjectData.allQuestions.length} questions.`;
                    if (AppState.unparsedPages > 0) {
                        statusMessage += ` <span class="font-bold text-red-600">Warning: ${AppState.unparsedPages} page(s) could not be parsed.</span>`;
                    }
                    statusDiv.innerHTML = statusMessage;
                    
                    updateReviewAllButton();
                    renderDashboard();
                    populateCustomFilters();
                    saveState();
                };
                fileReader.readAsArrayBuffer(file);
            }

// --- IMPROVED RATIONALE UPLOADER (Year-First Safety + Structure Parsing) ---

// Ensure the listener is attached safely
const rationaleInput = document.getElementById('rationale-upload');
if (rationaleInput) {
    // Remove any existing listeners to prevent duplicates if you reload script
    rationaleInput.replaceWith(rationaleInput.cloneNode(true));
    document.getElementById('rationale-upload').addEventListener('change', handleRationaleSelect);
}

/**
 * Handles the selection of the Rationale PDF.
 * UPDATED: Stores the PDF doc and maps questions to specific page numbers.
 */
function handleRationaleSelect(e) {
    const file = e.target.files[0];
    if (!file || file.type !== 'application/pdf') return;

    statusDiv.innerHTML = '<div class="flex items-center justify-center"><div class="loader mr-2"></div>Scanning Rationales & Mapping Pages...</div>';
    
    const fileReader = new FileReader();
    fileReader.onload = async function() {
        const typedarray = new Uint8Array(this.result);
        const pdfDoc = await pdfjsLib.getDocument(typedarray).promise;
        
        // 1. SAVE THE DOC FOR LATER VIEWING
        const subjectData = getCurrentSubjectData();
        subjectData.rationalePdfDoc = pdfDoc;

        let fullText = "";
        const pageMap = {}; // Maps "Item Number" -> Page Number

        // 2. Scan pages to build text AND map locations
        for (let i = 1; i <= pdfDoc.numPages; i++) {
            const page = await pdfDoc.getPage(i);
            const textContent = await page.getTextContent();
            const pageText = textContent.items.map(item => item.str).join('\n');
            
            fullText += pageText + "\n";

            // Simple check: If we see "Item 5" on this page, map 5 to this page.
            // Regex looks for "Item" followed by a number, or just a number at start of line
            const itemMatches = pageText.match(/(?:Item\s+|Position\s+|^)\s*(\d+)/g);
            if (itemMatches) {
                itemMatches.forEach(match => {
                    const num = match.replace(/\D/g, '');
                    if (!pageMap[num]) pageMap[num] = i; // Store first occurrence
                });
            }
        }

        // 3. Detect Year (Safety Check)
        const headerText = fullText.substring(0, 1000); 
        const yearMatch = headerText.match(/20\d{2}/);
        let detectedYear = yearMatch ? yearMatch[0] : null;

        if (!detectedYear) {
          await new Promise(resolve => {
        showCustomModal(
            "Year Missing",
            "Could not automatically detect the exam year (e.g., 2023) from the file header. Please enter the year manually to continue:",
            (confirmed, inputYear) => {
                if (confirmed && inputYear) {
                    detectedYear = inputYear; // Update detectedYear with user's input
                    resolve();
                } else {
                    // User canceled, or provided no input
                    statusDiv.innerHTML = `<span class="text-red-600 font-bold">Upload canceled by user.</span>`;
                    resolve(); // Resolve to exit the promise wait
                }
            },
            true, // Show cancel button
            true // Indicate that input field is needed
        );
    });

    if (!detectedYear) {
        // This means the user cancelled the modal, so we exit the handler.
        return;
    }
}
        // 4. Parse Text Logic (Existing Logic)
        const rationales = parseRationalesText(fullText);
        
        // 5. Update Questions with Data AND Page Location
        let matchCount = 0;
        rationales.forEach(rat => {
            const targetQ = subjectData.allQuestions.find(q => 
                q.year === detectedYear && 
                (q.id.endsWith(`-Q${rat.number}`) || q.id.endsWith(`-Q0${rat.number}`))
            );

            if (targetQ) {
                targetQ.rationaleMap = rat.rationaleMap;
                // SAVE THE PAGE NUMBER
                targetQ.rationalePage = pageMap[rat.number] || 1; 
                matchCount++;
            }
        });

        statusDiv.innerHTML = `Success! Mapped rationales to <strong>${matchCount}</strong> questions for <span class="text-blue-600 font-bold">${detectedYear}</span>.`;
        saveState();
    };
    fileReader.readAsArrayBuffer(file);
}

/**
 * UNIVERSAL PARSER v9: The "Polished Math" Edition
 
 */
function parseRationalesText(text) {
    const rationalesMap = new Map();

    const cleanText = (str) => {
        return str
            .replace(/\$/g, "")
            .replace(/\\sqrt\{(\d+)\}/g, "√$1")
            .replace(/\\sqrt/g, "√")
            .replace(/\\frac\{(.+?)\}\{(.+?)\}/g, "($1/$2)")
            .replace(/\\cdot/g, "•")
            .replace(/\\approx/g, "≈")
            .replace(/\\le/g, "≤")
            .replace(/\\ge/g, "≥")
            .replace(/\s+/g, " ").trim();
    };

    // 1. CHUNKING
    const chunks = text.split(/Item\s*(?:Position|#)/gi);

    chunks.forEach((chunk) => {
        if (!chunk || chunk.trim().length === 0) return;

        // --- 2. SMART ID FINDER ---
        const detectionText = chunk.replace(/["',]/g, " ");

        let numMatch = detectionText.match(/\b(\d+)\b(?=[\s\S]{0,600}\b(?:Option|Rationale|Correct|Score|Part|pts?|SCR|scoring|guide|To\b)\b)/i);
        
        if (!numMatch) {
             numMatch = chunk.match(/^[\s\n"']*(\d+)/); 
        }
        
        if (!numMatch) return;

        const itemNumber = parseInt(numMatch[1], 10);

        if (itemNumber > 200 || itemNumber < 1) return;

        const strNum = itemNumber.toString();

        // 3. PARSE CONTENT
        const rawContent = chunk; 
        
        const optionMap = {};

        const optionRegex = /Option[\s.,-]+(?:["']?([A-Z0-9])["']?|["'](.+?)["'])\s*(?:is\s+|:\s*|[\s.-]+)(correct|incorrect|in\s+correct)?/gi;
        
        const hasOptions = optionRegex.test(rawContent);

        if (!hasOptions) {
            // --- RUBRIC / MATH TEXT ENTRY HANDLING ---
            let clean = cleanText(rawContent);
            
            clean = clean
                .replace(new RegExp(`^\\W*${strNum}\\W*`), "") // Remove question number
                .replace(/Rationales?/gi, "")
                .replace(/Correct\s+Answer/gi, "")
                .replace(/For\s+SCR\s+items.*guide/i, "See Scoring Guide in Source PDF.")
                // NEW: Remove leading math answers (digits, fractions, coordinates)
                // Matches "3/2, -1 " or "15 " at the start
                .replace(/^[\d\s,./-]+\s+(?=To\b)/i, "") 
                .trim();
            
            if (clean.length > 0) {
                optionMap[`Solution`] = clean;
            }
        } else {
            optionRegex.lastIndex = 0;
            let matches = [...rawContent.matchAll(optionRegex)];

            matches.forEach((m, i) => {
                const key = m[1] ? m[1].toUpperCase() : (m[2] ? m[2].trim() : "Unknown");
                
                const startIdx = m.index + m[0].length;
                const endIdx = (i < matches.length - 1) ? matches[i+1].index : rawContent.length;
                
                let explanation = rawContent.substring(startIdx, endIdx);
                
                explanation = explanation
                    .replace(/in\s+correct/gi, "incorrect")
                    .replace(/^[.,;:\s]+/, "")
                    .replace(/^(is\s+)?(correct|incorrect)[\s.:]*/i, "");
                
                optionMap[`${key}`] = cleanText(explanation); 
            });
        }

        // Handle Multipart Splits
        if (rawContent.match(/Part\s+B/i)) {
            const parts = rawContent.split(/Part\s+B/i);
            const extractFromPart = (partText, prefix) => {
                let partMatches = [...partText.matchAll(optionRegex)];
                partMatches.forEach((m, i) => {
                    const key = m[1] ? m[1].toUpperCase() : (m[2] ? m[2].trim() : "Unknown");
                    const startIdx = m.index + m[0].length;
                    const endIdx = (i < partMatches.length - 1) ? partMatches[i+1].index : partText.length;
                    let exp = cleanText(partText.substring(startIdx, endIdx));
                    exp = exp.replace(/^(is\s+)?(correct|incorrect)[\s.:]*/i, "");
                    optionMap[`${prefix}${key}`] = exp;
                });
            };
            extractFromPart(parts[0], "PartA_");
            extractFromPart(parts[1] || "", "PartB_");
        }

        // 4. MERGE
        if (Object.keys(optionMap).length > 0) {
            if (rationalesMap.has(strNum)) {
                const existing = rationalesMap.get(strNum);
                rationalesMap.set(strNum, { ...existing, ...optionMap });
            } else {
                rationalesMap.set(strNum, optionMap);
            }
        }
    });

    return Array.from(rationalesMap, ([number, rationaleMap]) => ({ number, rationaleMap }));
}
function finalizeItem(number, content, rationalesArray) {
    let correctOption = null;
    
    // Extract Answer Key
    const optionMatch = content.match(/Option\s+([A-Z])\s+is\s+correct/i);
    if (optionMatch) correctOption = optionMatch[1];

    // Clean Text for Display
    let cleanExplanation = content
        .replace(/Option\s+[A-Z]\s+is\s+correct/gi, "") 
        .replace(/Option\s+[A-Z]\s+is\s+incorrect/gi, "")
        .replace(/\d+\s*pts?/gi, "") // Remove "2 pts" text
        .replace(/^\d+\s*/, "") // Remove leading numbers
        .replace(/\s+/g, " ")
        .trim();

    if (number && cleanExplanation.length > 0) {
        rationalesArray.push({
            number: number,
            text: cleanExplanation,
            correctOption: correctOption
        });
    }
}
            /**
             * Scans the PDF to create a mapping between TEKS standards and their Reporting Category (RC).
             * This helps categorize questions correctly.
             * @param {pdfjs.PDFDocumentProxy} pdfDoc The loaded PDF document.
             * @returns {Promise<Object>} A map of TEKS codes to RC strings.
             */
      // ADD THIS REPLACEMENT FUNCTION
            async function buildTeksToRcMap(pdfDoc) {
                const map = {};
                // Select the correct regex from our new schema object
                const schema = ParserSchemas[AppState.currentSubject] || ParserSchemas['Biology'];
                const teksRcRegex = schema.teksRcRegex;

                // This regex might not find anything for English, and that's OK.
                // The map will just be empty.
                for (let i = 1; i <= pdfDoc.numPages; i++) {
                    const page = await pdfDoc.getPage(i);
                    const textContent = await page.getTextContent();
                    const text = textContent.items.map(item => item.str).join(' ');
                    const match = text.match(teksRcRegex);
                    if (match) {
                        const teksCode = match[1].trim();
                        const rc = `RC ${match[2].trim()}`;
                        if (!map[teksCode]) {
                            map[teksCode] = rc;
                        }
                    }
                }
                return map;
            }
// ADD THIS REPLACEMENT FUNCTION
            async function parseAllPages() {
                console.clear();
                console.log("%c--- STARTING PDF PARSING PROCESS (v6) ---", "color: blue; font-weight: bold; font-size: 14px;");
                
                statusDiv.innerHTML = '<div class="flex items-center justify-center"><div class="loader mr-2"></div>Processing PDF...</div>';

                const questions = [];
                AppState.unparsedPages = 0;
                const subjectData = getCurrentSubjectData();

                // This is our single, reliable rule:
                const questionBlockAnchor = "Analysis of Assessed Standards";

                let currentPassagePageNum = null; // Our "memory"
                let currentQuestionItems = [];
                let currentQuestionPageNums = [];
                let firstQuestionFound = false;

                // This function processes the buffered question items
                const processAndAddQuestion = async (items, pageNums) => {
                    if (items.length === 0 || pageNums.length === 0) return;
                    
                    console.log(`-> Processing buffered items for page(s) [${pageNums.join(', ')}]...`);
                    const firstPageNum = pageNums[0];
                    const page = await subjectData.pdfDoc.getPage(firstPageNum);
                    
                    // Pass the "remembered" passage page number to the parser
                    const question = parsePageContent(items, firstPageNum, page, currentPassagePageNum); 
                    
                    if (question) {
                        console.log(`%c  -> SUCCESS: Parsed ${question.id}. Linked to Passage on Page ${question.passagePageNum}`, "color: green; font-weight: bold;");
                        question.rawItems = items;
                        // This handles multi-page questions by storing all their page numbers
                        if (pageNums.length > 1) {
                            question.pageNums = [...new Set(pageNums)];
                            question.cropBox = null; // Disable cropping for multi-page questions
                        }
                        questions.push(question);
                    } else {
                        console.log(`%c  -> FAILED to parse items from page(s) [${pageNums.join(', ')}]`, "color: red; font-weight: bold;");
                        AppState.unparsedPages += [...new Set(pageNums)].length;
                    }
                };

                // Loop through every page
                for (let i = 1; i <= subjectData.pdfDoc.numPages; i++) {
                    console.log(`%c--- Page ${i} ---`, "font-weight: bold;");

                    const page = await subjectData.pdfDoc.getPage(i);
                    const textContent = await page.getTextContent();
                    const items = textContent.items;
                    
                    // --- NEW LOGIC: Check each item, not the whole page text ---
                    let hasQuestionBlock = false;
                    for (const item of items) {
                        if (item.str.includes(questionBlockAnchor)) {
                            hasQuestionBlock = true;
                            break; // Found it, no need to keep looking
                        }
                    }
                    console.log(`  -> Has "Analysis..." block: ${hasQuestionBlock}`);

                    // 1. Is it a Passage Page (or Intro)?
                    // (It does NOT have the "Analysis..." block)
                    if (!hasQuestionBlock) {
                        console.log("  -> This is a non-question page.");

                        // --- NEW SUBJECT CHECK ---
                        // Only treat this as a passage page if we are in an English course.
                        if (AppState.currentSubject === 'English 1' || AppState.currentSubject === 'English 2') {
                            console.log("  -> Subject is English. Treating as a Passage Page.");
                            
                            // Process any lingering question buffer first
                            if (firstQuestionFound && currentQuestionItems.length > 0) {
                                 console.log("  -> Found new passage. Processing previous question buffer...");
                                 await processAndAddQuestion(currentQuestionItems, currentQuestionPageNums);
                            }
                            
                            // Reset buffer and set memory
                            console.log(`%c  -> ACTION: Setting memory. New Passage Page is ${i}.`, "color: purple;");
                            currentPassagePageNum = i; // Update our "memory"
                            currentQuestionItems = [];
                            currentQuestionPageNums = [];
                            firstQuestionFound = false;

                        } else {
                            // For Bio, Alg, etc., this is just a title/junk page. Ignore it.
                            console.log("  -> Subject is NOT English. Ignoring as a title/junk page.");
                            // We DO NOT update the passage memory. It stays null.
                        }
                        // --- END SUBJECT CHECK ---

                        continue; // Move to the next page
                    }
                    
                    // 2. Is it a Question Page?
                    // (It HAS the "Analysis..." block)
                    if (hasQuestionBlock) {
                        // This is the *first* question found in a new buffer
                        if (!firstQuestionFound || currentQuestionItems.length === 0) {
                             console.log("  -> Starting new question buffer.");
                             firstQuestionFound = true;
                             currentQuestionItems = items;
                             currentQuestionPageNums = [i];
                        } else {
                            // This page has an "Analysis" block, but we are already building a question.
                            // This means the previous page was a continuation page that spilled over.
                            // We must process the old buffer *before* starting the new one.
                            console.log("  -> New question page found. Processing previous buffer...");
                            await processAndAddQuestion(currentQuestionItems, currentQuestionPageNums);
                            
                            // Start the new question buffer for this page
                            console.log("  -> Starting new question buffer.");
                            currentQuestionItems = items;
                            currentQuestionPageNums = [i];
                        }
                        continue;
                    }
                }

                // --- End of PDF ---
                console.log("%c--- End of PDF. ---", "font-weight: bold;");
                if (currentQuestionItems.length > 0) {
                    console.log("  -> Processing final question buffer...");
                    await processAndAddQuestion(currentQuestionItems, currentQuestionPageNums);
                }

                console.log(`%c--- PARSING COMPLETE. Found ${questions.length} questions. ---`, "color: blue; font-weight: bold; font-size: 14px;");
                
                let statusMessage = `Processing complete. Found ${questions.length} questions.`;
                if (AppState.unparsedPages > 0) {
                    statusMessage += ` <span class="font-bold text-red-600">Warning: ${AppState.unparsedPages} page(s) could not be parsed. Check console (F12) for details.</span>`;
                }
                statusDiv.innerHTML = statusMessage;
                statusDiv.style = ""; // Clear all the debug styles

                return questions;
            }
            /**
             * Extracts the automatic crop box coordinates from a page's text content.
             * @param {Array} items - The text items from a PDF page.
             * @param {pdfjs.PDFPageProxy} page - The PDF page object.
             * @returns {Object|null} A percentage-based crop box object or null.
             */
          // ADD THIS REPLACEMENT FUNCTION
            function detectCropBox(items, page) {
                // Select the correct schema
                const schema = ParserSchemas[AppState.currentSubject] || ParserSchemas['Biology'];

                // Find anchors based on the schema's keywords
                // This is flexible for all subjects now.
                const topAnchorItem = items.find(item => schema.questionStartRegex.test(item.str));
                const analysisAnchor = items.find(item => item.str.includes(schema.analysisAnchor));
                const bottomAnchor = items.find(item => item.str.includes(schema.bottomAnchor));

                if (topAnchorItem && analysisAnchor && bottomAnchor) {
                    const pageHeight = page.view[3];
                    const pageWidth = page.view[2];

                    const leftX = 25; // Must be positive to be a valid coordinate
                    const rightX = analysisAnchor.transform[4] - 25;
                    const topY_fromBottom = topAnchorItem.transform[5] + topAnchorItem.height + 10;
                    const bottomY_fromBottom = bottomAnchor.transform[5] + 10;
                    const cropX = leftX / pageWidth;
                    const cropY = (pageHeight - topY_fromBottom) / pageHeight;
                    const cropWidth = (rightX - leftX) / pageWidth;
                    const cropHeight = (topY_fromBottom - bottomY_fromBottom) / pageHeight;
                    
                    if (cropWidth > 0 && cropHeight > 0 && cropX >= 0 && cropY >= 0) {
                        return { x: cropX, y: cropY, width: cropWidth, height: cropHeight };
                    }
                }
                return null;
            }
            
            /**
             * Parses the text content of a single PDF page to extract question details.
             * @param {Array} items The text items from a PDF page.
             * @param {number} pageNum The page number.
             * @param {pdfjs.PDFPageProxy} page The PDF page object.
             * @returns {Object|null} A question object or null if parsing fails.
             */
    function parsePageContent(items, pageNum, page, currentPassagePageNum) { 
    try {
        const text = items.map(i => i.str).join(' ');
        const lowerText = text.toLowerCase();

        // 1. Basic Metadata Extraction
        const schema = ParserSchemas[AppState.currentSubject] || ParserSchemas['Biology'];
        const yearMatch = text.match(schema.questionStartRegex);
        if (!yearMatch) return null; 

        const teksMatch = text.match(schema.teksRegex);
        const itemTypeMatch = text.match(schema.itemTypeMatch);
        const clusterMatch = text.match(schema.clusterMatch);
        const rcMatchOnPage = text.match(/RC\s*(\d+)/);
        const questionIdMatch = text.match(schema.questionIdRegex);

        const questionNum = questionIdMatch ? questionIdMatch[1] : `P${pageNum}`;
        let itemType = itemTypeMatch ? itemTypeMatch[1].trim().replace(/\n/g, ' ') : 'Multiple Choice (1 pt)';
        
        let needsReview = false; 
        let teksCode, teksDescription, reportingCategory, cluster;

        if (teksMatch) {
            teksCode = teksMatch[1].trim();
            teksDescription = teksMatch[2].trim().replace(/\s+/g, ' ');
            reportingCategory = rcMatchOnPage ? `RC ${rcMatchOnPage[1]}` : (getCurrentSubjectData().teksToRcMap[teksCode] || null);
            cluster = clusterMatch ? clusterMatch[1].trim().replace(/\n/g, ' ') : 'Uncategorized';
        } else {
            teksCode = 'NEEDS_REVIEW';
            teksDescription = 'TEKS data not found.';
            reportingCategory = 'RC ?';
            cluster = 'Uncategorized';
            needsReview = true;
        }

        // 2. Answer Extraction
        let answerText = null, dragAndDropAnswers = null, hotspotAnswer = null, textEntryAnswer = null, inlineChoiceAnswer = null, graphingAnswer = null;
        const correctAnsMatch = text.match(/\*?\s*Correct\s*Answer\s*[:]?\s*\((.*?)\)/i);
        const typeLower = itemType.toLowerCase();

        if (correctAnsMatch && correctAnsMatch[1]) {
            const answerString = correctAnsMatch[1];
            if (typeLower.includes('multiple choice') || typeLower.includes('multipart') || typeLower.includes('multiselect')) {
                answerText = answerString.split(',').map(s => s.trim());
            } else if (typeLower.includes('hot spot')) {
                hotspotAnswer = answerString.trim();
                needsReview = true;
            } else if (typeLower.includes('drag and drop')) {
                dragAndDropAnswers = answerString.split(/[,;]/).map(s => s.replace(/\[.*?\]\s*/g, '').trim());
                needsReview = true;
            } else if (typeLower.includes('inline choice')) {
                inlineChoiceAnswer = answerString.split(',').map(s => s.trim());
            } else if (typeLower.includes('graphing')) {
                 graphingAnswer = answerString.match(/\(-?\d+,\s*-?\d+\)/g);
            } else if (typeLower.includes('short constructed response') || typeLower.includes('text entry') || typeLower.includes('equation editor')) {
                textEntryAnswer = answerString.trim();
                if (textEntryAnswer.toLowerCase() === 'see scoring guide') {
                    textEntryAnswer = "Enter correct answer in review mode."; 
                    needsReview = true;
                }
            }
        } else {
             if (!typeLower.includes('hot spot') && !typeLower.includes('drag and drop')) needsReview = true;
        }

        const cropBox = detectCropBox(items, page);

        // --- 3. AUTO-DIFFICULTY DETECTION ---
        let stateCorrectPct = null;
        let difficulty = 'Unrated';
        
        // Define what row label we are looking for (e.g. "A", "B", or "Full Credit")
        let targetLabel = "Full Credit"; // Default
        if (answerText && answerText.length > 0) {
             const rawLetter = answerText[0];
             const letterMatch = rawLetter.match(/\b([A-HJ-K])\b/); 
             targetLabel = letterMatch ? letterMatch[1] : rawLetter.charAt(0);
        }

        // Scan for Data Analysis Table
        const dataAnalysisIndex = items.findIndex(i => i.str.includes('Data Analysis'));
        if (dataAnalysisIndex !== -1) {
            // Look at next 100 items
            for (let i = dataAnalysisIndex; i < Math.min(items.length, dataAnalysisIndex + 100); i++) {
                const str = items[i].str.trim().replace('*', ''); 
                
                if (str.toUpperCase() === targetLabel.toUpperCase()) {
                    // Found the row! Look ahead for the State %
                    for (let j = 1; j <= 4; j++) {
                        if (i + j >= items.length) break;
                        const potentialNumStr = items[i+j].str.trim();
                        if (/^\d+$/.test(potentialNumStr)) {
                            const num = parseInt(potentialNumStr, 10);
                            if (num >= 0 && num <= 100) {
                                stateCorrectPct = num;
                                break; 
                            }
                        }
                    }
                }
                if (stateCorrectPct !== null) break; 
            }
        }

        // Apply Difficulty Thresholds
        if (stateCorrectPct !== null) {
            const settings = AppState.difficultySettings || { mastersThreshold: 40, meetsThreshold: 65 };
            if (stateCorrectPct < settings.mastersThreshold) {
                difficulty = 'Masters';
            } else if (stateCorrectPct < settings.meetsThreshold) {
                difficulty = 'Meets';
            } else {
                difficulty = 'Approaches';
            }
        }

        return {
            id: `${yearMatch[1]}-${questionNum}`, year: yearMatch[1], teks: teksCode,
            teksDescription: teksDescription,
            reportingCategory: reportingCategory,
            cluster: cluster,
            answerText, dragAndDropAnswers, hotspotAnswer, textEntryAnswer, inlineChoiceAnswer, graphingAnswer,
            itemType, pageNum, cropBox, explanation: '',
            interactiveZones: [], 
            draggableOptions: dragAndDropAnswers ? [...new Set(dragAndDropAnswers)] : [],
            needsReview: needsReview,
            passagePageNums: currentPassagePageNum ? [currentPassagePageNum] : [], 
            pageDimensions: { width: page.view[2], height: page.view[3] },
            rawItems: items,
            stateCorrectPct: stateCorrectPct,
            difficulty: difficulty
        };
    } catch (e) {
        console.error("Error in parsePageContent:", e, items);
        return null;
    }
}

            /**
             * Toggles the dashboard view between grouping by year and grouping by cluster.
             */
            function toggleDashboardView() {
                AppState.dashboardViewMode = AppState.dashboardViewMode === 'year' ? 'cluster' : 'year';
                viewToggleBtn.textContent = AppState.dashboardViewMode === 'year' ? 'Group by: Cluster' : 'Group by: Year';
                renderDashboard();
            }

            /**
             * Renders the main dashboard view.
             */
            function renderDashboard() {
                pathwayDisplay.innerHTML = '';
                placeholderView.classList.add('hidden');
                const subjectData = getCurrentSubjectData();
                if (subjectData.customPathways && subjectData.customPathways.length > 0) {
                    const customPathwayHeader = document.createElement('h2');
                    customPathwayHeader.className = 'text-xl font-bold text-gray-700 mb-2 mt-4';
                    customPathwayHeader.textContent = 'My Custom Pathways';
                    pathwayDisplay.appendChild(customPathwayHeader);

                    subjectData.customPathways.forEach(pathway => {
                        const row = createCustomPathwayRow(pathway);
                        if (row) {
                            pathwayDisplay.appendChild(row);
                        }
                    });
                }
                if (AppState.dashboardViewMode === 'year') {
                    renderDashboardByYear();
                } else {
                    renderDashboardByCluster();
                }
            }
            
      /**
 * Creates a single row in the dashboard for a TEKS standard.
 * FIX: Updated status display logic to handle numerical scores.
 * @param {string} teksName The name of the TEKS.
 * @param {Array<Object>} questions An array of questions for that TEKS.
 * @returns {HTMLElement} The created row element.
 */
function createTeksRow(teksName, questions) {
    const subjectData = getCurrentSubjectData();
    if (!subjectData.masteryState[teksName]) {
        subjectData.masteryState[teksName] = {};
        questions.forEach((_, i) => subjectData.masteryState[teksName][i] = 'not-started');
    }
    const teksRow = document.createElement('div');
    teksRow.className = 'p-4 rounded-lg border bg-gray-50 my-2 pathway-card';
    teksRow.dataset.teksId = teksName;
    
    const pathwayNeedsReview = questions.some(q => q.needsReview);
    const reviewIconHTML = pathwayNeedsReview ? `<span title="Some questions in this pathway need teacher setup." class="ml-2 text-yellow-500 font-bold">⚠️</span>` : '';

    const progressMade = Object.values(subjectData.masteryState[teksName]).some(s => s !== 'not-started');
    const resetBtnHTML = progressMade ? `<button class="reset-pathway-btn text-xs text-red-500 hover:underline">Reset</button>` : '';

    teksRow.innerHTML = `
        <div class="flex justify-between items-start">
            <div>
                <p class="font-semibold flex items-center teks-title text-lg">${teksName} ${reviewIconHTML}</p>
          </div>
            ${resetBtnHTML}
        </div>
        <div class="flex flex-col sm:flex-row space-y-2 sm:space-y-0 sm:space-x-2 mt-4">
            <button class="practice-pathway-btn icon-btn flex-1 px-3 py-2 bg-green-600 text-white text-sm font-semibold rounded-md hover:bg-green-700 transition-all">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M10.804 8 5 4.633v6.734L10.804 8zm.792-.696a.802.802 0 0 1 0 1.392l-6.363 3.692C4.713 12.69 4 12.345 4 11.692V4.308c0-.653.713-.998 1.233-.696l6.363 3.692z"/></svg>
                <span>Practice Pathway</span>
            </button>
            <button class="start-quiz-btn icon-btn flex-1 px-3 py-2 bg-blue-600 text-white text-sm font-semibold rounded-md hover:bg-blue-700 transition-all">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-stopwatch" viewBox="0 0 16 16"><path d="M8.5 5.6a.5.5 0 1 0-1 0v2.9h-3a.5.5 0 0 0 0 1H8a.5.5 0 0 0 .5-.5V5.6z"/><path d="M6.5 1A.5.5 0 0 1 7 .5h2a.5.5 0 0 1 0 1v.57c1.36.196 2.594.78 3.584 1.64a.715.715 0 0 1 .012-.013l.354-.354-.354-.353a.5.5 0 0 1 .707-.707l1.414 1.415a.5.5 0 1 1-.707.707l-.353-.354-.354.354a.715.715 0 0 1-.013.012A7.001 7.001 0 0 1 7 2.071V1.5a.5.5 0 0 1-.5-.5zM8 3a6 6 0 1 0 .001 12A6 6 0 0 0 8 3z"/></svg>
                <span>Start Quiz</span>
            </button>
            <button class="review-btn icon-btn flex-1 px-3 py-2 bg-gray-200 text-gray-700 text-sm font-semibold rounded-md hover:bg-gray-300 transition-all">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M15.502 1.94a.5.5 0 0 1 0 .706L14.459 3.69l-2-2L13.502.646a.5.5 0 0 1 .707 0l1.293 1.293zm-1.75 2.456-2-2L4.939 9.21a.5.5 0 0 0-.121.196l-.805 2.414a.25.25 0 0 0 .316.316l2.414-.805a.5.5 0 0 0 .196-.12l6.813-6.814z"/><path fill-rule="evenodd" d="M1 13.5A1.5 1.5 0 0 0 2.5 15h11a1.5 1.5 0 0 0 1.5-1.5v-6a.5.5 0 0 0-1 0v6a.5.5 0 0 1-.5.5h-11a.5.5 0 0 1-.5-.5v-11a.5.5 0 0 1 .5-.5H9a.5.5 0 0 0 0-1H2.5A1.5 1.5 0 0 0 1 2.5v11z"/></svg>
                <span>Review & Edit</span>
            </button>
            <button class="print-btn icon-btn flex-1 px-3 py-2 text-sm font-semibold rounded-md transition-all">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M.5 1a.5.5 0 0 0 0 1h5a.5.5 0 0 0 0-1H.5zM9 1a.5.5 0 0 0 0 1h5a.5.5 0 0 0 0-1H9z"/><path d="M2.5 3a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-1 0v-1a.5.5 0 0 1 .5-.5z"/><path d="M4 3.5a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7a.5.5 0 0 1-.5-.5z"/><path d="M2.5 5a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-1 0v-1a.5.5 0 0 1 .5-.5z"/><path d="M4 5.5a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7a.5.5 0 0 1-.5-.5zM.5 7a.5.5 0 0 0 0 1h5a.5.5 0 0 0 0-1H.5zM9 7a.5.5 0 0 0 0 1h5a.5.5 0 0 0 0-1H9z"/><path d="M2.5 9a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-1 0v-1a.5.5 0 0 1 .5-.5z"/><path d="M4 9.5a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7a.5.5 0 0 1-.5-.5z"/><path d="M2.5 11a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-1 0v-1a.5.5 0 0 1 .5-.5z"/><path d="M4 11.5a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7a.5.5 0 0 1-.5-.5zM.5 13a.5.5 0 0 0 0 1h5a.5.5 0 0 0 0-1H.5zM9 13a.5.5 0 0 0 0 1h5a.5.5 0 0 0 0-1H9z"/><path d="M2.5 15a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-1 0v-1a.5.5 0 0 1 .5-.5z"/><path d="M4 15.5a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7a.5.5 0 0 1-.5-.5z"/></svg>
                <span>Print</span>
            </button>
        </div>`;

    teksRow.querySelector('.practice-pathway-btn').onclick = () => startPathway(teksName, questions, { isQuiz: false });
    teksRow.querySelector('.start-quiz-btn').onclick = () => showQuizSetupModal(teksName, questions);
    teksRow.querySelector('.review-btn').onclick = () => showReviewModal(teksName, questions);
    teksRow.querySelector('.print-btn').onclick = () => showPrintOptionsModal(questions, teksName);
    if(resetBtnHTML) {
        teksRow.querySelector('.reset-pathway-btn').onclick = () => resetPathwayProgress(teksName, questions.length);
    }

    // Helper function to map score to status string for display
    const getDisplayStatus = (score, pointsPossible) => {
        // Handle unattempted questions
        if (score === undefined || score === 'not-started' || isNaN(score)) return { className: 'not-started', title: 'Not started' };
        
        if (score === pointsPossible) return { className: 'correct', title: 'Correct' };
        if (score > 0) return { className: 'partial', title: `Partial (${score}/${pointsPossible} pts)` };
        return { className: 'incorrect', title: 'Incorrect' };
    };

    const questionGrid = document.createElement('div');
    questionGrid.className = 'question-grid';

    questions.forEach((question, index) => {
        const score = parseFloat(subjectData.masteryState[teksName]?.[index]);
        const pointsPossible = getQuestionPointsPossible(question);
        const { className, title } = getDisplayStatus(score, pointsPossible);

        const box = document.createElement('button');
        box.className = `question-box status-${className}`; // Uses the calculated class name
        box.dataset.index = index;
        box.title = `Question ${index + 1}: ${title}`; // Uses the calculated title
        
        // Check for flag (assuming AppState.currentPathway.flagged is available on the dashboard load)
        const isFlagged = AppState.currentPathway.flagged[index] && AppState.currentPathway.teks === teksName;
        if (isFlagged) { 
            box.classList.add('status-flagged');
        }

        questionGrid.appendChild(box);
    });

    // Find the main div inside teksRow to append the grid to.
    teksRow.querySelector('div').appendChild(questionGrid);

    // Add the click listener for the new boxes
    teksRow.addEventListener('click', (e) => {
        if (e.target.matches('.question-box')) {
            const index = parseInt(e.target.dataset.index, 10);
            startPathwayAtIndex(teksName, questions, index);
        }
    });

    return teksRow;
}

     /**
 * Creates a single row in the dashboard for a custom pathway.
 * FIX: Updated status display logic to handle numerical scores.
 * @param {Object} pathwayObject The saved custom pathway object.
 * @returns {HTMLElement} The created row element.
 */
function createCustomPathwayRow(pathwayObject) {
    const subjectData = getCurrentSubjectData();
    
    // "Re-hydrate" the questions array from the saved IDs
    const questions = pathwayObject.questionIds.map(id => 
        subjectData.allQuestions.find(q => q.id === id)
    ).filter(Boolean); 

    if (questions.length === 0) return null;

    const pathwayName = pathwayObject.name;
    
    const customPathwayDiv = document.createElement('div');
    customPathwayDiv.className = 'p-4 border rounded-lg bg-indigo-50 border-indigo-200 pathway-card mb-4';

    // 1. Build Main Card HTML (Grid moved to top-right)
    customPathwayDiv.innerHTML = `
        <div class="flex justify-between items-start mb-4">
            <div class="flex-grow pr-4">
                <h3 class="text-lg font-bold text-indigo-800">${pathwayName}</h3>
                <p class="text-xs text-gray-600 italic mt-1">${pathwayObject.filterDescription}</p>
            </div>

            <div class="flex flex-col items-end gap-2">
                <button class="delete-custom-pathway-btn text-xs text-red-500 hover:underline">Delete</button>
                <div class="question-grid-container flex justify-end"></div>
            </div>
        </div>
        
        <div class="flex flex-col sm:flex-row space-y-2 sm:space-y-0 sm:space-x-2">
            <button class="practice-pathway-btn flex-1 px-3 py-1 bg-green-600 text-white text-sm font-semibold rounded-md hover:bg-green-700">Practice Pathway</button>
             <button class="start-quiz-btn flex-1 px-3 py-1 bg-blue-600 text-white text-sm font-semibold rounded-md hover:bg-blue-700">Start Quiz</button>
            <button class="review-btn flex-1 px-3 py-1 bg-gray-200 text-gray-700 text-sm font-semibold rounded-md hover:bg-gray-300">Review & Edit</button>
            <button class="print-btn flex-1 px-3 py-1 text-sm font-semibold rounded-md">Print</button>
        </div>
    `;
    
    // Helper function to map score to status string for display
    const getDisplayStatus = (score, pointsPossible) => {
        // Handle unattempted questions
        if (score === undefined || score === 'not-started' || isNaN(score)) return { className: 'not-started', title: 'Not started' };
        
        if (score === pointsPossible) return { className: 'correct', title: 'Correct' };
        if (score > 0) return { className: 'partial', title: `Partial (${score}/${pointsPossible} pts)` };
        return { className: 'incorrect', title: 'Incorrect' };
    };
    
    // 2. Build the Visual Progress Grid Logic
    const questionGrid = document.createElement('div');
    questionGrid.className = 'question-grid';
    // Force right alignment for the grid flex container
    questionGrid.style.justifyContent = 'flex-end';
    
    // Ensure mastery tracking exists for this custom pathway name
    if (!subjectData.masteryState[pathwayName]) {
        subjectData.masteryState[pathwayName] = {};
        questions.forEach((_, i) => subjectData.masteryState[pathwayName][i] = 'not-started');
    }

    questions.forEach((question, index) => {
        const score = parseFloat(subjectData.masteryState[pathwayName]?.[index]);
        const pointsPossible = getQuestionPointsPossible(question);
        const { className, title } = getDisplayStatus(score, pointsPossible);

        const box = document.createElement('button');
        box.className = `question-box status-${className}`; // Uses the calculated class name
        box.dataset.index = index;
        box.title = `Question ${index + 1}: ${title}`; // Uses the calculated title
        
        // Add flag if set
        if (AppState.currentPathway.flagged[index]) { 
            box.classList.add('status-flagged');
        }

        questionGrid.appendChild(box);
    });

    // Append grid to the new top-right container
    customPathwayDiv.querySelector('.question-grid-container').appendChild(questionGrid);

    // 3. Attach Listeners
    customPathwayDiv.querySelector('.practice-pathway-btn').onclick = () => startPathway(pathwayName, questions, { isQuiz: false });
    customPathwayDiv.querySelector('.start-quiz-btn').onclick = () => showQuizSetupModal(pathwayName, questions);
    customPathwayDiv.querySelector('.review-btn').onclick = () => showReviewModal(pathwayName, questions);
    customPathwayDiv.querySelector('.print-btn').onclick = () => showPrintOptionsModal(questions, pathwayName);
    
    // Delete Listener
    customPathwayDiv.querySelector('.delete-custom-pathway-btn').onclick = () => {
        if (confirm(`Are you sure you want to delete the pathway "${pathwayName}"?`)) {
            subjectData.customPathways = subjectData.customPathways.filter(p => p.id !== pathwayObject.id);
            saveState();
            renderDashboard();
        }
    };

    // Grid Click Listener (Jump to Question)
    customPathwayDiv.addEventListener('click', (e) => {
        if (e.target.matches('.question-box')) {
            const index = parseInt(e.target.dataset.index, 10);
            startPathwayAtIndex(pathwayName, questions, index);
        }
    });
    
    return customPathwayDiv;
}
             
            function createCategorySummary(title, questions) {
                const summary = document.createElement('summary');
                const pathwayKey = `Category: ${title}`;
                const subjectData = getCurrentSubjectData();
                const progressMade = subjectData.masteryState[pathwayKey] && Object.values(subjectData.masteryState[pathwayKey]).some(s => s !== 'not-started');
                const resetBtnHTML = progressMade ? `<button class="reset-pathway-btn text-xs text-red-500 hover:underline">Reset</button>` : '';

                summary.innerHTML = `
                    <span class="flex-grow">${title}</span>
                    <div class="flex items-center space-x-2">
                        ${resetBtnHTML}
                        <button class="practice-all-btn px-2 py-1 bg-green-100 text-green-800 text-xs font-semibold rounded-md hover:bg-green-200">Practice All</button>
                        <button class="quiz-all-btn px-2 py-1 bg-blue-100 text-blue-800 text-xs font-semibold rounded-md hover:bg-blue-200">Quiz All</button>
                    </div>
                `;
                summary.querySelector('.practice-all-btn').onclick = (e) => { e.stopPropagation(); startPathway(pathwayKey, questions, { isQuiz: false }); };
                summary.querySelector('.quiz-all-btn').onclick = (e) => { e.stopPropagation(); showQuizSetupModal(pathwayKey, questions); };
                if (resetBtnHTML) {
                    summary.querySelector('.reset-pathway-btn').onclick = (e) => { e.stopPropagation(); resetPathwayProgress(pathwayKey, questions.length); };
                }
                return summary;
            }

            
            function renderDashboardByYear() {
                const subjectData = getCurrentSubjectData();
                const grouped = subjectData.allQuestions.reduce((acc, q) => {
                    const { year, reportingCategory, cluster, teks } = q;
                    if (!year || !reportingCategory || !cluster || !teks) return acc;
                    if (!acc[year]) acc[year] = {};
                    if (!acc[year][reportingCategory]) acc[year][reportingCategory] = {};
                    if (!acc[year][reportingCategory][cluster]) acc[year][reportingCategory][cluster] = {};
                    if (!acc[year][reportingCategory][cluster][teks]) acc[year][reportingCategory][cluster][teks] = [];
                    acc[year][reportingCategory][cluster][teks].push(q);
                    return acc;
                }, {});

                const years = Object.keys(grouped).sort((a,b) => b - a);
                years.forEach(year => {
                    const yearQuestions = Object.values(grouped[year]).flatMap(rc => Object.values(rc).flatMap(c => Object.values(c).flat()));
                    const yearDetails = document.createElement('details');
                    yearDetails.open = true;
                    const yearSummary = createCategorySummary(year, yearQuestions);
                    yearSummary.classList.add('text-xl', 'font-bold', 'text-gray-700');
                    yearDetails.appendChild(yearSummary);
                    pathwayDisplay.appendChild(yearDetails);

                    const rcs = Object.keys(grouped[year]).sort();
                    rcs.forEach(rc => {
                        const rcQuestions = Object.values(grouped[year][rc]).flatMap(c => Object.values(c).flat());
                        const rcDetails = document.createElement('details');
                        rcDetails.open = true;
                        const rcSummary = createCategorySummary(rc, rcQuestions);
                        rcSummary.classList.add('text-lg', 'font-semibold', 'text-gray-600');
                        rcDetails.appendChild(rcSummary);
                        yearDetails.appendChild(rcDetails);

                        const clusters = Object.keys(grouped[year][rc]).sort();
                        clusters.forEach(clusterName => {
                            const clusterQuestions = Object.values(grouped[year][rc][clusterName]).flat();
                            const clusterDetails = document.createElement('details');
                            clusterDetails.open = true;
                            const clusterSummary = createCategorySummary(clusterName, clusterQuestions);
                            clusterSummary.classList.add('font-medium', 'text-gray-500');
                            clusterDetails.appendChild(clusterSummary);
                            rcDetails.appendChild(clusterDetails);

                            const teksList = Object.keys(grouped[year][rc][clusterName]).sort();
                            teksList.forEach(teksName => {
                                const questions = grouped[year][rc][clusterName][teksName];
                                const teksRow = createTeksRow(teksName, questions);
                                teksRow.classList.add('ml-4');
                                clusterDetails.appendChild(teksRow);
                            });
                        });
                    });
                });
            }

           
            function renderDashboardByCluster() {
                const subjectData = getCurrentSubjectData();
                const groupedByCluster = subjectData.allQuestions.reduce((acc, q) => {
                    (acc[q.cluster || 'Uncategorized'] = acc[q.cluster || 'Uncategorized'] || {})[q.teks] = (acc[q.cluster || 'Uncategorized'][q.teks] || []).concat(q);
                    return acc;
                }, {});

                for (const clusterName in groupedByCluster) {
                    const clusterQuestions = Object.values(groupedByCluster[clusterName]).flat();
                    const clusterDetails = document.createElement('details');
                    clusterDetails.open = true;
                    
                    const clusterSummary = createCategorySummary(clusterName, clusterQuestions);
                    clusterSummary.classList.add('text-xl', 'font-bold', 'text-gray-800', 'p-0');
                    clusterDetails.appendChild(clusterSummary);
                    
                    const teksContainer = document.createElement('div');
                    teksContainer.className = 'space-y-3 mt-2';
                    clusterDetails.appendChild(teksContainer);

                    for (const teksName in groupedByCluster[clusterName]) {
                        const questions = groupedByCluster[clusterName][teksName];
                        const teksRow = createTeksRow(teksName, questions);
                        teksContainer.appendChild(teksRow);
                    }
                    pathwayDisplay.appendChild(clusterDetails);
                }
            }


            /**
             * Starts a practice or quiz pathway.
             * @param {string} teks The TEKS standard for the pathway.
             * @param {Array<Object>} questions The questions in the pathway.
             * @param {Object} options Configuration options (isQuiz, timerSettings).
             */
        /**
             * Starts a practice or quiz pathway.
             * UPDATED: Now accepts a 'startIndex' to prevent double-loading glitches.
             */
            function startPathway(teks, questions, options = {}, startIndex = 0) {
                const { isQuiz = false, timerSettings = null } = options;
                const subjectData = getCurrentSubjectData();
                if (!subjectData.masteryState[teks]) {
                    subjectData.masteryState[teks] = {};
                }

                questions.forEach((q, i) => {
                    if (subjectData.masteryState[teks][i] === undefined) {
                        subjectData.masteryState[teks][i] = 'not-started';
                    }
                });

                AppState.currentPathway = { 
                    teks, 
                    questions, 
                    currentIndex: startIndex, // <--- Use the specific start index
                    activeQuestion: null, 
                    userSelections: [], 
                    graphingPoints: [], 
                    flagged: {}, 
                    isQuiz,
                    timerSettings,
                    startTime: new Date()
                };
                showProblemView();
                // Only render ONE problem (the requested one)
                renderProblem(questions[startIndex]); 
            }
            
            /**
             * Switches the view to the main dashboard.
             */
            function showDashboard() {
                problemView.classList.add('hidden');
                resultsView.classList.add('hidden');
                dashboardView.classList.remove('hidden');
                homeBtn.classList.add('hidden');
                renderDashboard(); 
            }

            /**
             * Switches the view to the problem/student view.
             */
            function showProblemView() {
                dashboardView.classList.add('hidden');
                resultsView.classList.add('hidden');
                problemView.classList.remove('hidden');
                homeBtn.classList.remove('hidden');
            }

           
function startPathwayAtIndex(teksName, questions, startIndex) {
                // Pass the index directly so it loads ONCE, correctly.
                startPathway(teksName, questions, { isQuiz: false }, startIndex);
            }

            /**
             * Renders a single problem/question for the student.
             * @param {Object} question The question object to render.
             */
async function renderProblem(question) {
    // Get our containers
    const passageContainer = document.getElementById('passage-container');
    const passageWrapper = document.getElementById('passage-content-wrapper');
    const questionContent = document.getElementById('scalable-content');
    const problemViewContainer = document.getElementById('problem-view');
    
    problemViewContainer.classList.add('fade-out');
    if(AppState.questionTimer) clearInterval(AppState.questionTimer);
    AppState.zoomLevel = 1.0; 
    AppState.passageZoomLevel = 1.0; 
    timerDisplay.textContent = '';

    // --- Paired Passage Logic (Preserved) ---
    const newPassagePages = question.passagePageNums || [];
    const oldPassagePages = AppState.currentPathway.activeQuestion?.passagePageNums || [];
    const passagesHaveChanged = JSON.stringify(newPassagePages) !== JSON.stringify(oldPassagePages);

    const gridEl = document.getElementById('problem-view-grid');

    if (passagesHaveChanged) {
        passageWrapper.innerHTML = ''; 

        if (newPassagePages.length > 0) {
            // English/Reading Mode
            passageContainer.style.display = 'block';
            gridEl.style.gridTemplateColumns = ''; 

            try {
                const subjectData = getCurrentSubjectData();
                for (const pageNum of newPassagePages) {
                    const page = await subjectData.pdfDoc.getPage(pageNum);
                    const viewport = page.getViewport({ scale: 2.5 });
                    const passageCanvas = document.createElement('canvas');
                    passageCanvas.width = viewport.width;
                    passageCanvas.height = viewport.height;
                    passageCanvas.style.marginBottom = '1rem'; 
                    await page.render({ canvasContext: passageCanvas.getContext('2d'), viewport }).promise;
                    passageWrapper.appendChild(passageCanvas);
                }
            } catch (e) {
                console.error("Failed to render passage canvas(es):", e);
                passageWrapper.innerHTML = '<p>Error loading passage(s).</p>';
            }
        } else {
            // Math/Science Mode
            passageContainer.style.display = 'none'; 
            gridEl.style.gridTemplateColumns = 'repeat(1, minmax(0, 1fr))';
        }
    } else if (newPassagePages.length > 0) {
        passageContainer.style.display = 'block';
        gridEl.style.gridTemplateColumns = ''; 
    } else {
        passageContainer.style.display = 'none';
        gridEl.style.gridTemplateColumns = 'repeat(1, minmax(0, 1fr))';
    }
    // ----------------------------------------

    setTimeout(async () => {
        AppState.currentPathway.activeQuestion = question;
        AppState.currentPathway.userSelections = [];
        AppState.currentPathway.graphingPoints = [];
        
        // --- NEW: Difficulty Badge Logic ---
        const diff = question.difficulty || 'Unrated';
        let badgeColor = 'bg-gray-100 text-gray-800 border-gray-200'; // Default/Unrated
        
        if (diff === 'Masters') badgeColor = 'bg-purple-100 text-purple-800 border-purple-200';
        else if (diff === 'Meets') badgeColor = 'bg-blue-100 text-blue-800 border-blue-200';
        else if (diff === 'Approaches') badgeColor = 'bg-green-100 text-green-800 border-green-200';

        // Update the header with the counter AND the badge
        progressIndicator.innerHTML = `
            <span class="mr-3">Problem ${AppState.currentPathway.currentIndex + 1} of ${AppState.currentPathway.questions.length}</span>
            <span class="px-2 py-1 text-xs font-bold rounded border ${badgeColor}">${diff}</span>
        `;
        // -----------------------------------

        explanationBox.classList.add('hidden');
        correctAnswerContainer.classList.add('hidden');
        feedbackMessage.textContent = ''; 
        feedbackMessage.className = 'mt-4 text-center text-lg font-bold'; 
        answerInterface.innerHTML = '';
        retryProblemBtn.classList.add('hidden');
        
        renderClickableProgressBar();
        updateNavButtons();

        if (AppState.currentPathway.isQuiz && AppState.currentPathway.timerSettings) {
            startQuestionTimer();
        }

        const subjectData = getCurrentSubjectData();
        if (!subjectData.pdfDoc) {
            showCustomModal("PDF Missing", "Please re-upload the PDF for this subject to view questions.", showDashboard);
            return;
        }

        questionContent.innerHTML = ''; 

        const canvases = await createQuestionCanvases(question, 8.0);
        canvases.forEach((canvas, index) => {
            if (index === 0 && canvases.length === 1) {
                canvas.id = 'problem-canvas';
            }
            questionContent.appendChild(canvas);
        });
        
        await renderDynamicAnswerInterface(question);
        updateTeksContext(question);
        problemViewContainer.classList.remove('fade-out');
    }, 150); 
}
            
       /**
 * Renders the clickable progress bar at the top of the student view.
 * FIX: Updated logic to correctly map numerical scores (0, 1, 2) to status strings for CSS.
 */
function renderClickableProgressBar() {
    clickableProgressBar.innerHTML = '';
    const pathway = AppState.currentPathway;
    const subjectData = getCurrentSubjectData();
    const mastery = subjectData.masteryState[pathway.teks];
    
    // Helper to safely convert score (number) to CSS status class (string)
    const getDisplayStatusClass = (score, pointsPossible) => {
        if (score === undefined || score === 'not-started' || isNaN(score)) return 'not-started';
        if (score === pointsPossible) return 'correct';
        if (score > 0) return 'partial';
        return 'incorrect';
    };

    pathway.questions.forEach((q, index) => {
        const score = parseFloat(mastery[index]); // Read the numerical score
        const pointsPossible = getQuestionPointsPossible(q); // Get max points for this question
        const statusClass = getDisplayStatusClass(score, pointsPossible); // Get the CSS class string

        const box = document.createElement('div');
        box.className = 'status-box clickable-status-box';
        box.innerHTML = `
            <div class="status-box-face status-box-front status-${statusClass}"></div>
            <div class="status-box-face status-box-back"></div>
        `;
        if (index === pathway.currentIndex) {
            box.classList.add('current');
        }
        if (pathway.flagged[index]) { 
            box.classList.add('status-flagged');
        }
        box.dataset.index = index;
        
        // Allow clicking not-started questions in quiz mode to navigate
        if (pathway.isQuiz && statusClass === 'not-started') {
            box.onclick = () => jumpToProblem(index);
        } else if (!pathway.isQuiz) {
            box.onclick = () => jumpToProblem(index);
        } else {
            box.style.cursor = 'default';
        }
        clickableProgressBar.appendChild(box);
    });
}
            /**
             * Allows jumping to a specific problem in practice mode.
             * @param {number} index The index of the problem to jump to.
             */
            function jumpToProblem(index) {
                AppState.currentPathway.currentIndex = index;
                renderProblem(AppState.currentPathway.questions[index]);
            }

            /**
             * Updates the text and visibility of navigation buttons (e.g., "Next", "Finish").
             */
            function updateNavButtons() {
                const { currentIndex, questions, isQuiz } = AppState.currentPathway;
                previousProblemBtn.classList.toggle('hidden', isQuiz);
                skipProblemBtn.classList.toggle('hidden', !isQuiz);
                backToDashboardBtn.classList.toggle('hidden', isQuiz);

                if (currentIndex === questions.length - 1) {
                    nextProblemBtn.textContent = "Finish";
                } else {
                    nextProblemBtn.textContent = "Next";
                }
            }

            /**
             * Renders the appropriate answer interface based on the question type.
             * @param {Object} question The question object.
             */
            async function renderDynamicAnswerInterface(question) {
                answerInterface.innerHTML = '';
                const type = question.itemType.toLowerCase();
                
              if (type.includes('multiple choice') || type.includes('multipart') || type.includes('multiselect')) {
    renderMultipleChoiceInterface(question);
                } else if (type.includes('hot spot')) {
                    renderHotspotInterface(question);
                } else if (type.includes('drag and drop')) {
                    renderDragAndDropInterface(question);
                } else if (type.includes('short constructed response') || type.includes('text entry') || type.includes('equation editor')) {
                    renderTextEntryInterface(question);
                } else if (type.includes('inline choice')) {
                    renderInlineChoiceInterface(question);
                } else if (type.includes('graphing')) {
                    renderGraphingInterface(question);
                } else {
                     answerInterface.innerHTML = `<p class="text-center text-gray-600 font-semibold">This question type is not yet interactive.</p>`;
                }
            }

   /**
             * Renders the interface for multiple choice questions.
             * @param {Object} question The question object.
             */
            function renderMultipleChoiceInterface(question) {
                if (!question.answerText || question.answerText.length === 0) {
                    answerInterface.innerHTML = `<p class="text-center text-gray-500">This question is not yet configured. Please set the correct answer in the Review & Edit screen.</p>`;
                    return;
                }

                const createAndAppend = (tag, parent, text = '', classes = []) => {
                    const el = document.createElement(tag);
                    if (text) el.textContent = text;
                    if (classes.length) el.classList.add(...classes);
                    parent.appendChild(el);
                    return el;
                };

                const isMultipart = question.itemType.toLowerCase().includes('multipart');
                const isMultiSelect = question.answerText.length > 1 && !isMultipart;

                if (isMultiSelect) {
                    const instructionText = question.answerText.length === 2 ? "Select TWO correct answers." : `Select ${question.answerText.length} correct answers.`;
                    createAndAppend('p', answerInterface, instructionText, ['font-bold', 'text-lg', 'mb-4', 'text-center']);
                    const options = ['A', 'B', 'C', 'D'].some(opt => question.answerText.includes(opt)) ? ['A', 'B', 'C', 'D', 'E'] : ['F', 'G', 'H', 'J', 'K'];
                    renderOptions(options, 0);
                } else if (isMultipart) {
                    createAndAppend('p', createAndAppend('div', answerInterface), 'Part A', ['font-bold', 'text-lg', 'mb-2']);
                    const partAOptions = ['A', 'B', 'C', 'D'].includes((question.answerText[0] || '').toUpperCase()) ? ['A', 'B', 'C', 'D'] : ['F', 'G', 'H', 'J'];
                    renderOptions(partAOptions, 0);
                    
                    const partBContainer = createAndAppend('div', answerInterface, '', ['mt-4']);
                    createAndAppend('p', partBContainer, 'Part B', ['font-bold', 'text-lg', 'mb-2']);
                    const partBOptions = ['A', 'B', 'C', 'D'].includes((question.answerText[1] || '').toUpperCase()) ? ['A', 'B', 'C', 'D'] : ['F', 'G', 'H', 'J'];
                    renderOptions(partBOptions, 1); 
                } else {
                    const options = ['A', 'B', 'C', 'D'].includes((question.answerText[0] || '').toUpperCase()) ? ['A', 'B', 'C', 'D'] : ['F', 'G', 'H', 'J'];
                    renderOptions(options, 0);
                }

                function renderOptions(opts, partIndex) {
                    const buttonContainer = createAndAppend('div', answerInterface, '', ['grid', 'grid-cols-2', 'md:grid-cols-4', 'gap-4']);
                    buttonContainer.dataset.partIndex = partIndex;

                    opts.forEach(opt => {
                        const button = createAndAppend('button', buttonContainer, opt, ['answer-button', 'px-6', 'py-3', 'text-gray-800', 'font-semibold', 'rounded-lg']);
                        button.onclick = () => handleAnswerSelection(opt, partIndex, button);
                    });
                }
            }
/**
             * Handles the logic when a user clicks a multiple choice answer.
             * @param {string} selectedOption The selected answer (e.g., 'A').
             * @param {number} partIndex The part of the question (for multipart).
             * @param {HTMLElement} buttonElement The button element that was clicked.
             */
            function handleAnswerSelection(selectedOption, partIndex, buttonElement) {
                const question = AppState.currentPathway.activeQuestion;
                const maxSelections = (question.answerText || []).length;
                const isMultiSelect = maxSelections > 1 && !question.itemType.toLowerCase().includes('multipart');
                
                // Initialize user selections array if it doesn't exist for the part
                if (!Array.isArray(AppState.currentPathway.userSelections[partIndex])) {
                    AppState.currentPathway.userSelections[partIndex] = [];
                }

                const currentSelections = AppState.currentPathway.userSelections[partIndex];
                const isSelected = buttonElement.classList.contains('selected');

                if (isMultiSelect) {
                    // --- MULTI-SELECT LOGIC (e.g., "Select TWO") ---
                    if (isSelected) {
                        // Deselect it
                        buttonElement.classList.remove('selected');
                        const indexToRemove = currentSelections.indexOf(selectedOption);
                        if (indexToRemove > -1) {
                            currentSelections.splice(indexToRemove, 1);
                        }
                    } else {
                        // Select it if not at max
                        if (currentSelections.length < maxSelections) {
                            buttonElement.classList.add('selected');
                            currentSelections.push(selectedOption);
                        }
                    }
                } else {
                    // --- SINGLE-SELECT LOGIC (Standard MCQs and Part A/B) ---
                    const parentContainer = buttonElement.parentElement;
                    parentContainer.querySelectorAll('.answer-button').forEach(btn => btn.classList.remove('selected'));
                    buttonElement.classList.add('selected');
                    AppState.currentPathway.userSelections[partIndex] = [selectedOption];
                }

                // Check if ready to submit
                const totalSelections = AppState.currentPathway.userSelections.flat().length;
                const existingSubmitBtn = document.getElementById('submit-mc-btn');
                if (existingSubmitBtn) existingSubmitBtn.remove();

                if (!AppState.currentPathway.isQuiz && totalSelections === maxSelections) {
                    const submitBtn = document.createElement('button');
                    submitBtn.id = 'submit-mc-btn';
                    submitBtn.textContent = 'Submit Answer';
                    submitBtn.className = 'w-full mt-6 px-6 py-3 bg-green-600 text-white font-semibold rounded-lg shadow-md hover:bg-green-700';
                    submitBtn.onclick = evaluateMCAnswer;
                    answerInterface.appendChild(submitBtn);
                }
            }

           /**
             * Evaluates the selected multiple choice answers.
             */
            function evaluateMCAnswer() {
                const question = AppState.currentPathway.activeQuestion;
                const userAnswers = AppState.currentPathway.userSelections.flat(); // Flatten array for easy comparison
                const correctAnswers = question.answerText;
                const isMultiSelect = correctAnswers.length > 1 && !question.itemType.toLowerCase().includes('multipart');

                let isFullyCorrect = false;
                let correctCount = 0;

                if (isMultiSelect) {
                    // For "Select TWO", sort both arrays to compare them regardless of order
                    isFullyCorrect = userAnswers.length === correctAnswers.length && 
                                     userAnswers.sort().toString() === correctAnswers.sort().toString();
                    if (isFullyCorrect) correctCount = correctAnswers.length;
                } else {
                    // For standard MCQs and Part A/B questions
                    (userAnswers || []).forEach((answer, index) => {
                        if (answer === correctAnswers[index]) {
                            correctCount++;
                        }
                    });
                    isFullyCorrect = correctCount === correctAnswers.length;
                }
                
                showFeedback(isFullyCorrect, correctCount);
            }
/**
 * Determines the maximum possible point value for a given question.
 * CRITICAL FIX: Added null check to prevent crashing the results screen if a question object is missing.
 * @param {Object} question The question object.
 * @returns {number} The max points possible (0, 1, or 2).
 */
function getQuestionPointsPossible(question) {
    // --- CRITICAL NULL CHECK: If the question object is null or invalid, return 0 points ---
    if (!question) {
        return 0;
    }
    // --- END FIX ---
    
    const type = (question.itemType || '').toLowerCase();
    // Check for question types that typically award multiple points
    if (type.includes('multipart') || type.includes('multiselect')) {
        return 2; 
    }
    // All other question types (MC, Hotspot, Text Entry) are assumed to be 1 point
    return 1;
}

         /**
             * Handles the click event for hotspot questions.
             * This is now a separate function so zoom can use it.
             */
            function handleHotspotClick(e) {
                // Don't do anything if a button is clicked
                if (e.target.tagName === 'BUTTON' || e.target.closest('button')) return;

                const canvasContainer = scalableContent;
                const rect = canvasContainer.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                // Store the user's click coordinates as a percentage of the canvas size.
                AppState.currentPathway.userSelections[0] = {
                    x: x / rect.width,
                    y: y / rect.height
                };
                
                // Show a marker where the user clicked.
                canvasContainer.querySelectorAll('.hotspot-click-marker').forEach(m => m.remove());
                const marker = document.createElement('div');
                marker.className = 'hotspot-click-marker';
                marker.style.left = `${x}px`;
                marker.style.top = `${y}px`;
                canvasContainer.appendChild(marker);

                // Add the submit button if it's not there
                if (!AppState.currentPathway.isQuiz && !document.getElementById('submit-hotspot-btn')) {
                    const submitBtn = document.createElement('button');
                    submitBtn.id = 'submit-hotspot-btn';
                    submitBtn.textContent = 'Submit Answer';
                    submitBtn.className = 'w-full px-6 py-3 mt-4 bg-blue-500 text-white font-semibold rounded-lg shadow-md hover:bg-blue-600';
                    submitBtn.onclick = evaluateHotspotAnswer;
                    answerInterface.appendChild(submitBtn);
                }
            }

            /**
             * Renders the interface for hotspot questions.
             * @param {Object} question The question object.
             */
            function renderHotspotInterface(question) {
                // Check if the teacher has defined the clickable zone yet.
                if (!question.interactiveZones || question.interactiveZones.length === 0) {
                    answerInterface.innerHTML = `<p class="text-center text-gray-500">This hotspot question is not yet configured. Please define the clickable area in the Review & Edit screen.</p>`;
                    return;
                }

                const canvasContainer = scalableContent;
                canvasContainer.style.cursor = 'pointer';

                // Remove any old listener before adding a new one
                canvasContainer.removeEventListener('click', handleHotspotClick);
                // Add the new, reusable listener
                canvasContainer.addEventListener('click', handleHotspotClick);
            }
            
// REPLACE your current evaluateHotspotAnswer function with this one

function evaluateHotspotAnswer() {
    const question = AppState.currentPathway.activeQuestion;
    const userClick = AppState.currentPathway.userSelections[0]; 
    
    let isCorrect = false;
    // Loop through ALL defined zones for the question
    if (userClick && question.interactiveZones && question.interactiveZones.length > 0) {
        for (const zone of question.interactiveZones) {
            const translatedZone = translateZoneCoordinates(zone, question);
            if (userClick.x >= translatedZone.x &&
                userClick.x <= translatedZone.x + translatedZone.width &&
                userClick.y >= translatedZone.y &&
                userClick.y <= translatedZone.y + translatedZone.height) {
                
                isCorrect = true;
                break; // Found a match, no need to check other zones
            }
        }
    }
    
    showFeedback(isCorrect);
}

            /**
             * Renders the interface for text entry questions.
             * @param {Object} question The question object.
             */
            function renderTextEntryInterface(question) {
                const textInput = document.createElement('textarea');
                textInput.id = 'text-entry-input';
                textInput.className = 'w-full p-2 border rounded-md text-lg';
                textInput.rows = 4;
                textInput.placeholder = 'Type your answer here...';
                answerInterface.appendChild(textInput);

                if (!AppState.currentPathway.isQuiz) {
                    const submitBtn = document.createElement('button');
                    submitBtn.textContent = 'Submit Answer';
                    submitBtn.className = 'w-full mt-4 px-6 py-3 bg-green-600 text-white font-semibold rounded-lg shadow-md hover:bg-green-700';
                    submitBtn.onclick = () => {
                        const userAnswer = textInput.value.toLowerCase().trim();
                        const correctAnswer = (question.textEntryAnswer || "").toLowerCase().trim();
                        const isCorrect = userAnswer === correctAnswer;
                        showFeedback(isCorrect);
                    };
                    answerInterface.appendChild(submitBtn);
                }
            }
            
            /**
             * Renders the interface for drag-and-drop questions.
             * @param {Object} question The question object.
             */
            function renderDragAndDropInterface(question) {
                // Check for teacher setup.
                if (question.interactiveZones && question.interactiveZones.length > 0 && question.draggableOptions && question.draggableOptions.length > 0) {
                    // Create the drop zones on the canvas.
                    question.interactiveZones.forEach((zone) => {
                        const dropZone = document.createElement('div');
                        dropZone.className = 'drop-zone';
                        dropZone.dataset.zoneId = zone.id;

                        const translatedZone = translateZoneCoordinates(zone, question);
                        
                        dropZone.style.left = `${translatedZone.x * 100}%`;
                        dropZone.style.top = `${translatedZone.y * 100}%`;
                        dropZone.style.width = `${translatedZone.width * 100}%`;
                        dropZone.style.height = `${translatedZone.height * 100}%`;
                        
                        scalableContent.appendChild(dropZone);
                    });

                    // Create the bank of draggable items.
                    const dragItemsContainer = document.createElement('div');
                    dragItemsContainer.className = 'flex flex-wrap gap-2 justify-center p-4 bg-gray-100 rounded-lg mt-4';
                    question.draggableOptions.forEach(opt => {
                        const item = document.createElement('div');
                        item.className = 'drag-item';
                        item.textContent = opt;
                        item.draggable = true;
                        dragItemsContainer.appendChild(item);
                    });
                    answerInterface.appendChild(dragItemsContainer);
                    
                    if (!AppState.currentPathway.isQuiz) {
                        const submitBtn = document.createElement('button');
                        submitBtn.textContent = 'Check Answer';
                        submitBtn.className = 'w-full px-6 py-3 mt-4 bg-blue-500 text-white font-semibold rounded-lg shadow-md hover:bg-blue-600';
                        submitBtn.onclick = evaluateDragAndDropAnswer;
                        answerInterface.appendChild(submitBtn);
                    }

                    // --- Mouse Drag and Drop Events ---
                    answerInterface.addEventListener('dragstart', e => {
                        if (e.target.classList.contains('drag-item')) {
                            AppState.draggedItem = e.target;
                            setTimeout(() => e.target.classList.add('invisible'), 0);
                        }
                    });
                     answerInterface.addEventListener('dragend', e => {
                        if (AppState.draggedItem) AppState.draggedItem.classList.remove('invisible');
                    });
                    scalableContent.addEventListener('dragover', e => e.preventDefault());
                    scalableContent.addEventListener('drop', e => {
                        e.preventDefault();
                        const zone = e.target.closest('.drop-zone');
                        if (zone && AppState.draggedItem) {
                            if(zone.children.length > 0) return; // Prevent dropping on an occupied zone
                            const clone = AppState.draggedItem.cloneNode(true);
                            clone.classList.remove('invisible');
                            zone.appendChild(clone);
                        }
                    });

                    // --- Touch Drag and Drop Events ---
                    answerInterface.addEventListener('touchstart', e => {
                        if (e.target.classList.contains('drag-item')) {
                            e.preventDefault();
                            AppState.draggedItem = e.target;
                            
                            // Create a ghost element for visual feedback
                            const ghost = e.target.cloneNode(true);
                            ghost.classList.add('touch-drag-ghost');
                            document.body.appendChild(ghost);
                            AppState.touchDragGhost = ghost;

                            const touch = e.touches[0];
                            ghost.style.left = `${touch.clientX}px`;
                            ghost.style.top = `${touch.clientY}px`;
                        }
                    });

                    document.addEventListener('touchmove', e => {
                        if (AppState.draggedItem && AppState.touchDragGhost) {
                            e.preventDefault();
                            const touch = e.touches[0];
                            AppState.touchDragGhost.style.left = `${touch.clientX}px`;
                            AppState.touchDragGhost.style.top = `${touch.clientY}px`;

                            // Highlight drop zone
                            const targetElement = document.elementFromPoint(touch.clientX, touch.clientY);
                            document.querySelectorAll('.drop-zone').forEach(dz => dz.classList.remove('dragover'));
                            if (targetElement && targetElement.closest('.drop-zone')) {
                                targetElement.closest('.drop-zone').classList.add('dragover');
                            }
                        }
                    });

                    document.addEventListener('touchend', e => {
                        if (AppState.draggedItem && AppState.touchDragGhost) {
                            e.preventDefault();
                            const touch = e.changedTouches[0];
                            
                            AppState.touchDragGhost.style.display = 'none';
                            const targetElement = document.elementFromPoint(touch.clientX, touch.clientY);
                            AppState.touchDragGhost.style.display = '';
                            
                            document.querySelectorAll('.drop-zone').forEach(dz => dz.classList.remove('dragover'));
                            
                            if (targetElement) {
                                const zone = targetElement.closest('.drop-zone');
                                if (zone && zone.children.length === 0) {
                                    const clone = AppState.draggedItem.cloneNode(true);
                                    zone.appendChild(clone);
                                }
                            }
                            
                            // Cleanup
                            AppState.touchDragGhost.remove();
                            AppState.touchDragGhost = null;
                            AppState.draggedItem = null;
                        }
                    });


                } else {
                    answerInterface.innerHTML = `<p class="text-center text-gray-500">This drag & drop question is not yet configured. Please define drop zones and answer options in the Review & Edit screen.</p>`;
                }
            }
            
            /**
             * Translates global page coordinates for an interactive zone to local coordinates relative to the cropped canvas.
             * @param {Object} zone The interactive zone object.
             * @param {Object} question The question object.
             * @returns {Object} The translated zone coordinates.
             */
            function translateZoneCoordinates(zone, question) {
                const { cropBox, pageDimensions } = question;
                if (!cropBox) return zone; 

                const cropWidth = cropBox.width * pageDimensions.width;
                const cropHeight = cropBox.height * pageDimensions.height;
                const cropX = cropBox.x * pageDimensions.width;
                const cropY = cropBox.y * pageDimensions.height;

                const zoneAbsX = zone.x * pageDimensions.width;
                const zoneAbsY = zone.y * pageDimensions.height;
                const zoneAbsWidth = zone.width * pageDimensions.width;
                const zoneAbsHeight = zone.height * pageDimensions.height;
                
                const newRelX = zoneAbsX - cropX;
                const newRelY = zoneAbsY - cropY;

                return {
                    x: newRelX / cropWidth,
                    y: newRelY / cropHeight,
                    width: zoneAbsWidth / cropWidth,
                    height: zoneAbsHeight / cropHeight
                };
            }

            /**
             * Evaluates the user's answers for a drag-and-drop question.
             */
            function evaluateDragAndDropAnswer() {
                const question = AppState.currentPathway.activeQuestion;
                let allCorrect = true;
                if (!question.interactiveZones || question.interactiveZones.length === 0) allCorrect = false;

                question.interactiveZones.forEach(zone => {
                    const dropZoneEl = scalableContent.querySelector(`.drop-zone[data-zone-id="${zone.id}"]`);
                    const droppedItem = dropZoneEl ? dropZoneEl.querySelector('.drag-item') : null;
                    const droppedAnswer = droppedItem ? droppedItem.textContent.trim() : null;
                    
                    if (droppedAnswer !== zone.correctAnswer) {
                        allCorrect = false;
                    }
                });
                showFeedback(allCorrect);
            }

            /**
             * Renders the interface for inline choice (dropdown) questions.
             * @param {Object} question The question object.
             */
            function renderInlineChoiceInterface(question) {
                const container = document.createElement('div');
                container.className = 'text-center text-lg p-4 bg-gray-50 rounded-lg';
                
                // This part is hardcoded for specific questions found in the sample PDF.
                // A more robust solution would parse the options from the PDF or have a better setup tool.
                let html = '';
                if (question.id.includes('2023-Q7')) { // Example for a specific question
                    html = `
                        <p class="mb-4">The range is the set of all real numbers</p>
                        <div class="flex items-center justify-center gap-2 flex-wrap">
                            <select class="inline-choice-select" data-index="0">
                                <option value="">Select...</option>
                                <option value="Greater than -4">Greater than -4</option>
                                <option value="Less than -4">Less than -4</option>
                            </select>
                            <span>and</span>
                            <select class="inline-choice-select" data-index="1">
                                <option value="">Select...</option>
                                <option value="less than or equal to 2">less than or equal to 2</option>
                                <option value="greater than or equal to 2">greater than or equal to 2</option>
                            </select>
                        </div>`;
                } else { // Default example
                     html = `
                        <p class="mb-4">Complete the statement that describes the rate of change.</p>
                        <div class="flex items-center justify-center gap-2 flex-wrap">
                            <span>The value</span>
                            <select class="inline-choice-select" data-index="0">
                                <option value="">Select...</option>
                                <option value="increases">increases</option>
                                <option value="decreases">decreases</option>
                            </select>
                            <span>at a rate of</span>
                            <select class="inline-choice-select" data-index="1">
                                <option value="">Select...</option>
                                <option value="0.25">0.25</option>
                                <option value="1">1</option>
                                <option value="4">4</option>
                                <option value="3000">3,000</option>
                            </select>
                            <span>m/h.</span>
                        </div>`;
                }
                container.innerHTML = html;
                answerInterface.appendChild(container);

                if (!AppState.currentPathway.isQuiz) {
                    const submitBtn = document.createElement('button');
                    submitBtn.textContent = 'Submit Answer';
                    submitBtn.className = 'w-full mt-6 px-6 py-3 bg-green-600 text-white font-semibold rounded-lg shadow-md hover:bg-green-700';
                    submitBtn.onclick = evaluateInlineChoiceAnswer;
                    answerInterface.appendChild(submitBtn);
                }
            }

            /**
             * Evaluates the answers for an inline choice question.
             */
            function evaluateInlineChoiceAnswer() {
                const question = AppState.currentPathway.activeQuestion;
                const selects = answerInterface.querySelectorAll('.inline-choice-select');
                const userAnswers = [];
                selects.forEach(select => {
                    userAnswers.push(select.value);
                });
                
                const isCorrect = JSON.stringify(userAnswers) === JSON.stringify(question.inlineChoiceAnswer);
                showFeedback(isCorrect);
            }
// ADD THIS ENTIRE NEW FUNCTION
            
            /**
             * Renders a question's PDF page(s) to an array of canvas elements.
             * This is a reusable function for both student view and printing.
             * @param {Object} question The question object.
             * @param {number} scale The rendering scale (e.g., 2.0 for student view, 1.5 for print)
             * @returns {Promise<HTMLCanvasElement[]>} A promise that resolves to an array of canvas elements.
             */
async function createQuestionCanvases(question, scale = 2.0, useCrop = true) {
    const subjectData = getCurrentSubjectData();
                const canvases = [];

                if (!subjectData.pdfDoc) {
                    console.error("PDFDoc is missing. Cannot render canvases.");
                    return [];
                }

                try {
                    // Handle multi-page questions by rendering each page
                    if (question.pageNums && question.pageNums.length > 0) {
                        for (const pageNum of question.pageNums) {
                            const page = await subjectData.pdfDoc.getPage(pageNum);
                            const viewport = page.getViewport({ scale });
                            const canvas = document.createElement('canvas');
                            canvas.width = viewport.width;
                            canvas.height = viewport.height;
                            canvas.style.display = 'block';
                            canvas.style.marginBottom = '1rem';
                            await page.render({ canvasContext: canvas.getContext('2d'), viewport }).promise;
                            canvases.push(canvas);
                        }
                    } else { // Handle single-page questions with cropping
                        const canvas = document.createElement('canvas');
                        const page = await subjectData.pdfDoc.getPage(question.pageNum);
                        const viewport = page.getViewport({ scale });
                        
                        const offscreenCanvas = document.createElement('canvas');
                        const offscreenContext = offscreenCanvas.getContext('2d');
                        offscreenCanvas.width = viewport.width;
                        offscreenCanvas.height = viewport.height;
                        await page.render({ canvasContext: offscreenContext, viewport }).promise;

if (question.cropBox && useCrop) {
    const { x, y, width, height } = question.cropBox;
                            const sx = x * offscreenCanvas.width;
                            const sy = y * offscreenCanvas.height;
                            const sWidth = width * offscreenCanvas.width;
                            const sHeight = height * offscreenCanvas.height;

                            canvas.width = sWidth;
                            canvas.height = sHeight;

                            if (sWidth > 0 && sHeight > 0) {
                                canvas.getContext('2d').drawImage(
                                    offscreenCanvas,
                                    sx, sy, sWidth, sHeight,
                                    0, 0, canvas.width, canvas.height
                                );
                            } else { // Fallback for invalid crop
                                canvas.width = offscreenCanvas.width;
                                canvas.height = offscreenCanvas.height;
                                canvas.getContext('2d').drawImage(offscreenCanvas, 0, 0);
                            }
                        } else {
                            canvas.width = offscreenCanvas.width;
                            canvas.height = offscreenCanvas.height;
                            canvas.getContext('2d').drawImage(offscreenCanvas, 0, 0);
                        }
                        canvases.push(canvas);
                    }
                } catch (error) {
                    console.error(`Error rendering canvas for question ${question.id}:`, error);
                    // Create a fallback "error" canvas
                    const errorCanvas = document.createElement('canvas');
                    errorCanvas.width = 500;
                    errorCanvas.height = 100;
                    const ctx = errorCanvas.getContext('2d');
                    ctx.font = "16px Arial";
                    ctx.fillStyle = "red";
                    ctx.fillText(`Error rendering question ${question.id}.`, 10, 50);
                    canvases.push(errorCanvas);
                }
                
                return canvases;
            }
 // --- NEW INTERACTIVE GRAPHING FUNCTIONS ---
            function renderGraphingInterface(question) {
                // Add the graph type selector UI
                const selectorContainer = document.createElement('div');
                selectorContainer.className = 'graph-type-selector';
                selectorContainer.innerHTML = `
                    <button class="graph-type-btn active" data-type="line">Line</button>
                    <button class="graph-type-btn" data-type="quadratic" disabled>Parabola</button>
                    <button class="graph-type-btn" data-type="exponential" disabled>Exponential</button>
                `;
                answerInterface.appendChild(selectorContainer);
                
                const canvas = document.createElement('canvas');
                canvas.id = 'graphing-canvas';
                canvas.width = 500;
                canvas.height = 500;
                answerInterface.appendChild(canvas);

                const ctx = canvas.getContext('2d');
                const range = { x: 10, y: 10 };
                let dragState = {
                    isDragging: false,
                    target: null, // can be 'p1', 'p2', or 'line'
                    offsetX: 0,
                    offsetY: 0
                };

                // Initialize the current graphing mode
                AppState.currentPathway.graphingMode = 'line';

                const redrawCanvas = () => {
                    drawGrid(ctx, canvas.width, canvas.height, range);
                    const points = AppState.currentPathway.graphingPoints;
                    if (points.length > 0) drawPoint(ctx, points[0], '#ef4444');
                    if (points.length > 1) {
                        drawPoint(ctx, points[1], '#3b82f6');
                        drawLine(ctx, points[0], points[1]);
                    }
                };

               // --- THIS IS THE CORRECTED getMousePos ---
                const getMousePos = (e) => {
                    const rect = canvas.getBoundingClientRect();
                    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                    
                    // Calculate the raw offset relative to the displayed canvas
                    const rawX = clientX - rect.left;
                    const rawY = clientY - rect.top;
                    
                    // Calculate scaling factors
                    const scaleX = canvas.width / rect.width;   // internal width / displayed width
                    const scaleY = canvas.height / rect.height; // internal height / displayed height
                    
                    // Return scaled coordinates
                    return {
                        x: rawX * scaleX,
                        y: rawY * scaleY
                    };
                };

                const handleInteractionStart = (e) => {
                    e.preventDefault();
                    const pos = getMousePos(e);
                    const points = AppState.currentPathway.graphingPoints;

                    // If we have a full line, check for dragging first
                    if (points.length >= 2) {
                        const p1Dist = Math.hypot(pos.x - points[0].x, pos.y - points[0].y);
                        const p2Dist = Math.hypot(pos.x - points[1].x, pos.y - points[1].y);

                        if (p1Dist < 10) {
                            dragState = { isDragging: true, target: 'p1' };
                            return;
                        } else if (p2Dist < 10) {
                            dragState = { isDragging: true, target: 'p2' };
                            return;
                        } else {
                             dragState = { isDragging: true, target: 'line', offsetX: pos.x - points[0].x, offsetY: pos.y - points[0].y };
                             return;
                        }
                    }

                    // *** THIS IS THE FIX: If not dragging, add a point ***
                    if (points.length < 2) {
                        AppState.currentPathway.graphingPoints.push(pos);
                        redrawCanvas();
                        // If this was the second point, show the submit button
                        if (points.length === 2 && !AppState.currentPathway.isQuiz && !document.getElementById('submit-graph-btn')) {
                            const submitBtn = document.createElement('button');
                            submitBtn.id = "submit-graph-btn";
                            submitBtn.textContent = 'Submit Answer';
                            submitBtn.className = 'w-full mt-4 px-6 py-3 bg-green-600 text-white font-semibold rounded-lg shadow-md hover:bg-green-700';
                            submitBtn.onclick = evaluateGraphingAnswer;
                            answerInterface.appendChild(submitBtn);
                        }
                    }
                };

                const handleInteractionMove = (e) => {
                    if (!dragState.isDragging) return;
                    e.preventDefault();
                    const pos = getMousePos(e);
                    const points = AppState.currentPathway.graphingPoints;

                    if (dragState.target === 'p1') {
                        points[0] = { x: pos.x, y: pos.y };
                    } else if (dragState.target === 'p2') {
                        points[1] = { x: pos.x, y: pos.y };
                    } else if (dragState.target === 'line') {
                        const dx = (pos.x - dragState.offsetX) - points[0].x;
                        const dy = (pos.y - dragState.offsetY) - points[0].y;
                        points[0].x += dx;
                        points[0].y += dy;
                        points[1].x += dx;
                        points[1].y += dy;
                    }
                    redrawCanvas();
                };

                const handleInteractionEnd = (e) => {
                    dragState.isDragging = false;
                };

                // Assign all events
                canvas.addEventListener('mousedown', handleInteractionStart);
                canvas.addEventListener('mousemove', handleInteractionMove);
                canvas.addEventListener('mouseup', handleInteractionEnd);
                canvas.addEventListener('mouseleave', handleInteractionEnd);
                canvas.addEventListener('touchstart', handleInteractionStart);
                canvas.addEventListener('touchmove', handleInteractionMove);
                canvas.addEventListener('touchend', handleInteractionEnd);
                
                redrawCanvas();
            }

            function drawGrid(ctx, width, height, range) {
                ctx.clearRect(0, 0, width, height);
                ctx.strokeStyle = '#e2e8f0';
                ctx.lineWidth = 1;
                const origin = { x: width / 2, y: height / 2 };
                const stepX = width / (range.x * 2);
                const stepY = height / (range.y * 2);

                for (let i = -range.x; i <= range.x; i++) {
                    ctx.beginPath();
                    ctx.moveTo(origin.x + i * stepX, 0);
                    ctx.lineTo(origin.x + i * stepX, height);
                    ctx.stroke();
                }
                for (let i = -range.y; i <= range.y; i++) {
                    ctx.beginPath();
                    ctx.moveTo(0, origin.y + i * stepY);
                    ctx.lineTo(width, origin.y + i * stepY);
                    ctx.stroke();
                }

                ctx.strokeStyle = '#4b5563';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, origin.y);
                ctx.lineTo(width, origin.y);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(origin.x, 0);
                ctx.lineTo(origin.x, height);
                ctx.stroke();
            }

            function drawPoint(ctx, point, color) {
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(point.x, point.y, 8, 0, 2 * Math.PI);
                ctx.fill();
            }

            function drawLine(ctx, p1, p2) {
                ctx.strokeStyle = '#3b82f6';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();
            }
            
            function evaluateGraphingAnswer() {
                const question = AppState.currentPathway.activeQuestion;
                if (!question.graphingAnswer || question.graphingAnswer.length < 2 || AppState.currentPathway.graphingPoints.length < 2) {
                    showFeedback(false);
                    return;
                }

                const parsePoint = str => {
                    const coords = str.match(/-?\d+/g);
                    return { x: parseInt(coords[0]), y: parseInt(coords[1]) };
                };
                const correctP1 = parsePoint(question.graphingAnswer[0]);
                const correctP2 = parsePoint(question.graphingAnswer[1]);

                const correctSlope = (correctP2.y - correctP1.y) / (correctP2.x - correctP1.x);
                const correctYIntercept = correctP1.y - correctSlope * correctP1.x;

                const canvas = document.getElementById('graphing-canvas');
                const range = { x: 10, y: 10 };
                const origin = { x: canvas.width / 2, y: canvas.height / 2 };
                const stepX = canvas.width / (range.x * 2);
                const stepY = canvas.height / (range.y * 2);
                
                const toGridCoords = p => ({
                    x: (p.x - origin.x) / stepX,
                    y: -(p.y - origin.y) / stepY
                });

                const userP1 = toGridCoords(AppState.currentPathway.graphingPoints[0]);
                const userP2 = toGridCoords(AppState.currentPathway.graphingPoints[1]);

                const userSlope = (userP2.y - userP1.y) / (userP2.x - userP1.x);
                const userYIntercept = userP1.y - userSlope * userP1.x;
                
                const slopeMatch = Math.abs(userSlope - correctSlope) < 0.1; 
                const interceptMatch = Math.abs(userYIntercept - correctYIntercept) < 0.5;

                showFeedback(slopeMatch && interceptMatch);
            }

            /**
             * Updates the TEKS context box with the current question's information.
             */
            function updateTeksContext(question){
                teksContextNew.innerHTML = `<span class="font-bold">${question.teks}</span>: ${question.teksDescription || ''}`;
                teksContextOld.textContent = question.oldTeks ? `Formerly: ${question.oldTeks}` : '';
            }

            /**
             * Toggles the visibility of the TEKS context box.
             */
            function toggleTeksVisibility() {
                const isHidden = teksContextDiv.classList.toggle('hidden');
                toggleTeksBtn.textContent = isHidden ? 'Show Standard' : 'Hide Standard';
            }
            
/**
 * Shows feedback to the user after they answer a question in practice mode.
 * UPDATED: Calculates and saves raw points earned for variable point scoring.
 * @param {boolean} isOverallCorrect Whether the answer was fully correct.
 * @param {number} correctCount The number of correct parts/points earned.
 */
function showFeedback(isOverallCorrect, correctCount = 0) {
    const subjectData = getCurrentSubjectData();
    const pathway = AppState.currentPathway;
    const question = pathway.activeQuestion;
    const pointsPossible = getQuestionPointsPossible(question);

    // 1. Handle Quiz Mode (No immediate feedback, just save score)
    if (pathway.isQuiz) {
        // In Quiz Mode, we save the full score if correct, or 0 if incorrect/unattempted.
        const scoreToSave = isOverallCorrect ? pointsPossible : 0;
        subjectData.masteryState[pathway.teks][pathway.currentIndex] = scoreToSave;
        
        if (pathway.currentIndex < pathway.questions.length - 1) {
            pathway.currentIndex++;
            renderProblem(pathway.questions[pathway.currentIndex]);
        } else {
            renderResultsScreen();
        }
        return;
    }

    // --- Practice Mode Logic ---
    
    // 2. Lock Interface
    answerInterface.querySelectorAll('button, textarea, select, canvas').forEach(el => {
        el.classList.add('disabled');
        el.onclick = null;
    });
    scalableContent.style.cursor = 'default';

    // 3. Determine Specific Feedback Text (Red/Green Box)
    let specificFeedback = "";
    const isMultipart = (question.itemType || "").toLowerCase().includes('multipart');
    
    // Logic for Rationales (Display only)
    if (question.rationaleMap && pathway.userSelections.length > 0) {
        
        // Loop through EVERY selection (Handles Part A and Part B)
        pathway.userSelections.flat().forEach((userChoice, index) => {
            let lookupKey = userChoice;
            let label = `Option ${userChoice}`;

            // --- SMART KEY DETECTION ---
            const hasMultipartKeys = Object.keys(question.rationaleMap).some(k => k.startsWith('Part'));
            
            if (hasMultipartKeys) {
                const prefix = index === 0 ? "PartA_" : "PartB_";
                let normalizedLetter = userChoice;
                const mapToStandard = {'F':'A', 'G':'B', 'H':'C', 'J':'D'};
                if (index === 1 && mapToStandard[userChoice]) {
                    normalizedLetter = mapToStandard[userChoice];
                }
                lookupKey = `${prefix}${normalizedLetter}`;
                label = index === 0 ? `Part A (Option ${userChoice})` : `Part B (Option ${userChoice})`;
            }

            // --- NEW: PER-PART GRADING LOGIC (Same logic as used for the score) ---
            let isPartCorrect = false;
            
            if (isMultipart) {
                const correctForPart = question.answerText && question.answerText[index];
                if (correctForPart && userChoice === correctForPart) {
                    isPartCorrect = true;
                }
            } else {
                if (question.answerText && question.answerText.includes(userChoice)) {
                    isPartCorrect = true;
                }
            }

            // Set color based on THIS part's correctness, not the overall score
            const colorClass = isPartCorrect 
                ? "bg-green-50 border-green-200 text-green-800" 
                : "bg-red-50 border-red-200 text-red-800";
            
            const icon = isPartCorrect ? "✅" : "❌";

            // Perform the Lookup and Display
            if (question.rationaleMap[lookupKey]) {
                specificFeedback += `
                    <div class="mt-2 p-3 rounded border ${colorClass} text-left text-sm">
                        <span class="font-bold block mb-1">${icon} Explanation for ${label}:</span>
                        ${question.rationaleMap[lookupKey]}
                    </div>`;
            } else {
                // Fallback if we have no rationale but want to show right/wrong status
                specificFeedback += `
                    <div class="mt-2 p-3 rounded border ${colorClass} text-left text-sm">
                        <span class="font-bold block mb-1">${icon} Selection: ${label}</span>
                        (No detailed explanation available)
                    </div>`;
            }
        });
    }

    // 4. Show Header Status 
    feedbackMessage.innerHTML = '';
    
    let headerText = "";
    if (isOverallCorrect) {
        headerText = "Correct! Great job.";
    } else if (correctCount > 0) {
        // Use raw points to show feedback
        headerText = `Partially Correct. (${correctCount} of ${pointsPossible} points earned)`;
    } else {
        headerText = "Incorrect.";
    }

    const headerHtml = `<div class="${isOverallCorrect ? 'text-green-600' : 'text-red-600'} text-lg font-bold">
                            ${headerText}
                        </div>`;
    
    feedbackMessage.innerHTML = headerHtml + specificFeedback;

    // 5. Highlight Buttons (Display only)
    answerInterface.querySelectorAll('.answer-button.selected').forEach(btn => {
        if (isOverallCorrect) {
            btn.classList.add('correct');
        } else {
             btn.classList.add('incorrect');
        }
    });

    // 6. Handle "Correct Answer" Strip Visibility
    if (isOverallCorrect) {
        const answerString = question.answerText?.join(', ') || 'N/A';
        correctAnswerDisplay.textContent = `The correct answer is: ${answerString}`;
        correctAnswerContainer.classList.remove('hidden');
        showConfetti();
    } else {
        correctAnswerContainer.classList.add('hidden');
    }

    // 7. Update State (SAVE THE NUMERICAL SCORE)
    const scoreToSave = correctCount; // Save the raw points earned (0, 1, or 2)
    subjectData.masteryState[pathway.teks][pathway.currentIndex] = scoreToSave;
    renderClickableProgressBar();

    retryProblemBtn.classList.toggle('hidden', isOverallCorrect);
    saveState();
}
            
            /**
             * Displays a confetti animation for a correct answer.
             */
            function showConfetti() {
                const container = document.getElementById('confetti-container');
                const colors = ['#facc15', '#4ade80', '#60a5fa', '#f472b6'];
                for (let i = 0; i < 50; i++) {
                    const confetti = document.createElement('div');
                    confetti.className = 'confetti';
                    confetti.style.left = `${Math.random() * 100}vw`;
                    confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                    confetti.style.animationDelay = `${Math.random() * 0.5}s`;
                    confetti.style.transform = `rotate(${Math.random() * 360}deg)`;
                    container.appendChild(confetti);

                    setTimeout(() => {
                        confetti.remove();
                    }, 2000);
                }
            }

  
/**
             * Renders a visual overlay on the review canvas to show where text items were detected.
             * @param {Event} event The click event from the button.
             */
            function renderDebugOverlay(event) {
                const questionId = event.target.dataset.questionId;
                const question = getCurrentSubjectData().allQuestions.find(q => q.id === questionId);
                const container = document.getElementById(`scalable-content-review-${question.id}`);
                const canvas = container.querySelector('.review-canvas');

                if (!question || !canvas) return;

                // Clear any previous overlays
                container.querySelectorAll('.debug-text-box').forEach(box => box.remove());

                const canvasRect = canvas.getBoundingClientRect();

                question.rawItems.forEach(item => {
                    // pdf.js coordinates have origin at bottom-left, so we need to convert
                    // item.transform[4] is x-coordinate
                    // item.transform[5] is y-coordinate from the bottom
                    const x = item.transform[4];
                    const y = item.transform[5];
                    const width = item.width;
                    const height = item.height;

                    // Convert to top-left origin for CSS absolute positioning
                    const top = canvasRect.height - y - height;
                    const left = x;

                    const box = document.createElement('div');
                    box.className = 'debug-text-box';
                    box.style.position = 'absolute';
                    box.style.left = `${left}px`;
                    box.style.top = `${top}px`;
                    box.style.width = `${width}px`;
                    box.style.height = `${height}px`;
                    box.style.backgroundColor = 'rgba(255, 255, 0, 0.3)'; // Semi-transparent yellow
                    box.style.border = '1px solid #f59e0b'; // Orange border
                    box.style.pointerEvents = 'none'; // So it doesn't interfere with clicks
                    box.title = item.str; // Show the text on hover for debugging
                    container.appendChild(box);
                });
            }
        
            function updateDraggableOptions(event) {
                const questionId = event.target.dataset.questionId;
                const question = getCurrentSubjectData().allQuestions.find(q => q.id === questionId);
                if (question) {
                    // Read comma-separated values, trim whitespace, and filter out empty strings
                    question.draggableOptions = event.target.value.split(',').map(s => s.trim()).filter(Boolean);
                    // Re-render the editor to show the new bank and check for zone matches
                    setupAnswerKeyEditor(question);
                }
            }

            /**
             * Clears all defined interactive zones for a question.
             */
            function clearInteractiveZones(event) {
                const questionId = event.target.dataset.questionId;
                const question = getCurrentSubjectData().allQuestions.find(q => q.id === questionId);
                if (question) {
                    question.interactiveZones = [];
                    redrawZones(question);
                    if (question.itemType.toLowerCase().includes('drag and drop')) {
                        setupAnswerKeyEditor(question);
                    }
                }
            }
            
            /**
             * Redraws the interactive zone boxes on the review canvas.
             */
            function redrawZones(question) {
                const container = document.getElementById(`scalable-content-review-${question.id}`);
                container.querySelectorAll('.drawn-box').forEach(box => box.remove());
                question.interactiveZones.forEach(zone => {
                    const box = document.createElement('div');
                    box.className = 'drawn-box';
                    box.style.left = `${zone.x * 100}%`;
                    box.style.top = `${zone.y * 100}%`;
                    box.style.width = `${zone.width * 100}%`;
                    box.style.height = `${zone.height * 100}%`;
                    box.dataset.id = zone.id;
                    
                    const deleteBtn = document.createElement('div');
                    deleteBtn.className = 'delete-btn';
                    deleteBtn.innerHTML = '&times;';
                    deleteBtn.onclick = (e) => {
                        e.stopPropagation();
                        question.interactiveZones = question.interactiveZones.filter(z => z.id !== zone.id);
                        redrawZones(question);
                         if (question.itemType.toLowerCase().includes('drag and drop')) {
                            setupAnswerKeyEditor(question);
                        }
                    };
                    box.appendChild(deleteBtn);
                    
                    makeBoxDraggable(box, zone, question);
                    container.appendChild(box);
                });
            }

            // REPLACE your current enterLayoutEditorMode function with this one

// REPLACE your current enterLayoutEditorMode function with this one

function enterLayoutEditorMode(event) {
    const questionId = event.target.dataset.questionId;
    const question = getCurrentSubjectData().allQuestions.find(q => q.id === questionId);
    const canvas = document.querySelector(`#review-container-${question.id} .review-canvas`); // Target the first canvas
    const container = document.getElementById(`scalable-content-review-${question.id}`);

    if (!question || !canvas || container.querySelector('.layout-editor-overlay')) return;

    const overlay = document.createElement('div');
    overlay.className = 'layout-editor-overlay layout-editor-active';
    container.appendChild(overlay);

    let startX, startY, selectionBox;

    const getCoords = (e) => {
        if (e.touches) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: e.touches[0].clientX - rect.left,
                y: e.touches[0].clientY - rect.top
            };
        }
        return { x: e.offsetX, y: e.offsetY };
    }

    const startDraw = (e) => {
        e.preventDefault();
        const coords = getCoords(e);
        startX = coords.x;
        startY = coords.y;
        selectionBox = document.createElement('div');
        selectionBox.className = 'selection-box';
        selectionBox.style.left = `${startX}px`;
        selectionBox.style.top = `${startY}px`;
        overlay.appendChild(selectionBox);
    };

    const draw = (e) => {
        if (selectionBox) {
            e.preventDefault();
            const coords = getCoords(e);
            const width = coords.x - startX;
            const height = coords.y - startY;
            selectionBox.style.width = `${Math.abs(width)}px`;
            selectionBox.style.height = `${Math.abs(height)}px`;
            if (width < 0) selectionBox.style.left = `${coords.x}px`;
            if (height < 0) selectionBox.style.top = `${coords.y}px`;
        }
    };

    const endDraw = (e) => {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const endCoords = getCoords(e.changedTouches ? e.changedTouches[0] : e);

        const newZone = {
            id: `zone-${Date.now()}`,
            x: Math.min(startX, endCoords.x) / rect.width,
            y: Math.min(startY, endCoords.y) / rect.height,
            width: Math.abs(endCoords.x - startX) / rect.width,
            height: Math.abs(endCoords.y - startY) / rect.height,
            correctAnswer: null
        };

        if(question.itemType.toLowerCase().includes('hot spot')) {
            question.interactiveZones = [newZone];
            question.needsReview = false;
        } else {
            question.interactiveZones.push(newZone);
        }

        redrawZones(question);
        if (question.itemType.toLowerCase().includes('drag and drop')) {
            setupAnswerKeyEditor(question);
        }
        overlay.remove();
    };

    overlay.addEventListener('mousedown', startDraw);
    overlay.addEventListener('mousemove', draw);
    overlay.addEventListener('mouseup', endDraw);
    overlay.addEventListener('touchstart', startDraw);
    overlay.addEventListener('touchmove', draw);
    overlay.addEventListener('touchend', endDraw);
}
            /**
             * Makes the interactive zone boxes draggable and resizable in the review modal.
             */
            function makeBoxDraggable(boxElement, zone, question) {
                const startDrag = (e) => {
                    e.preventDefault();
                    e.stopPropagation();

                    AppState.isDraggingBox = true;
                    AppState.draggedBoxElement = boxElement;
                    AppState.draggedBoxZone = zone;
                    AppState.draggedBoxQuestion = question;
                    
                    const rect = boxElement.parentElement.getBoundingClientRect();
                    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                    const clientY = e.touches ? e.touches[0].clientY : e.clientY;

                    AppState.dragStartX = clientX - boxElement.getBoundingClientRect().left + rect.left;
                    AppState.dragStartY = clientY - boxElement.getBoundingClientRect().top + rect.top;
                };

                const drag = (e) => {
                    if (!AppState.isDraggingBox || !AppState.draggedBoxElement) return;
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                    const clientY = e.touches ? e.touches[0].clientY : e.clientY;

                    const containerRect = AppState.draggedBoxElement.parentElement.getBoundingClientRect();
                    let newX = clientX - AppState.dragStartX;
                    let newY = clientY - AppState.dragStartY;

                    // Constrain to parent bounds
                    newX = Math.max(0, Math.min(newX, containerRect.width - AppState.draggedBoxElement.offsetWidth));
                    newY = Math.max(0, Math.min(newY, containerRect.height - AppState.draggedBoxElement.offsetHeight));

                    AppState.draggedBoxElement.style.left = `${newX}px`;
                    AppState.draggedBoxElement.style.top = `${newY}px`;
                };

                const endDrag = (e) => {
                    if (!AppState.isDraggingBox || !AppState.draggedBoxElement) return;
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const containerRect = AppState.draggedBoxElement.parentElement.getBoundingClientRect();
                    const finalX = parseFloat(AppState.draggedBoxElement.style.left);
                    const finalY = parseFloat(AppState.draggedBoxElement.style.top);

                    // Update the zone data with new percentage-based coordinates
                    AppState.draggedBoxZone.x = finalX / containerRect.width;
                    AppState.draggedBoxZone.y = finalY / containerRect.height;

                    // Reset dragging state
                    AppState.isDraggingBox = false;
                    AppState.draggedBoxElement = null;
                    AppState.draggedBoxZone = null;
                    AppState.draggedBoxQuestion = null;
                };

                boxElement.addEventListener('mousedown', startDrag);
                document.addEventListener('mousemove', drag);
                document.addEventListener('mouseup', endDrag);
                boxElement.addEventListener('touchstart', startDrag);
                document.addEventListener('touchmove', drag);
                document.addEventListener('touchend', endDrag);
            }

            /**
             * Sets up the answer key editor for drag-and-drop questions in the review modal.
             */
            function setupAnswerKeyEditor(question) {
                const keyZonesContainer = document.getElementById(`key-zones-${question.id}`);
                const bankContainer = document.getElementById(`dnd-bank-${question.id}`);
                if (!keyZonesContainer || !bankContainer) return;
                
                keyZonesContainer.innerHTML = ''; 
                bankContainer.innerHTML = '';
                
                question.draggableOptions.forEach(opt => {
                    const item = document.createElement('div');
                    item.className = 'drag-item';
                    item.textContent = opt;
                    item.draggable = true;
                    bankContainer.appendChild(item);
                });

                question.interactiveZones.forEach((zone, index) => {
                    const keyZone = document.createElement('div');
                    keyZone.className = 'key-drop-zone';
                    keyZone.dataset.zoneId = zone.id;
                    keyZone.innerHTML = `<span class="drop-zone-label">Box ${index + 1}</span>`;
                    if (zone.correctAnswer) {
                        const item = document.createElement('div');
                        item.className = 'drag-item';
                        item.textContent = zone.correctAnswer;
                        keyZone.appendChild(item);
                    }
                    keyZonesContainer.appendChild(keyZone);
                });

                bankContainer.addEventListener('dragstart', e => {
                    if(e.target.classList.contains('drag-item')) {
                        AppState.draggedItem = e.target;
                    }
                });

                keyZonesContainer.addEventListener('dragover', e => {
                    e.preventDefault();
                    const zone = e.target.closest('.key-drop-zone');
                    if (zone) zone.classList.add('dragover');
                });

                keyZonesContainer.addEventListener('dragleave', e => {
                    const zone = e.target.closest('.key-drop-zone');
                    if (zone) zone.classList.remove('dragover');
                });

                keyZonesContainer.addEventListener('drop', e => {
                    e.preventDefault();
                    const zone = e.target.closest('.key-drop-zone');
                    if (zone && AppState.draggedItem) {
                        zone.classList.remove('dragover');
                        const targetZone = getCurrentSubjectData().allQuestions.find(q => q.id === question.id).interactiveZones.find(z => z.id === zone.dataset.zoneId);
                        if (targetZone) {
                            targetZone.correctAnswer = AppState.draggedItem.textContent;
                            
                            // Check if all zones are filled to mark as reviewed
                            const allZonesFilled = question.interactiveZones.every(z => z.correctAnswer);
                            if (allZonesFilled) {
                                question.needsReview = false;
                            }
                            setupAnswerKeyEditor(question);
                        }
                    }
                });
            }

       /**
             * Updates the zoom level of a specific target (passage or question).
             */
            function updateZoom(amount, target) {
                const passageContent = document.getElementById('passage-content-wrapper');

                if (target === 'passage' && passageContent) {
                    // Update and apply zoom ONLY for the passage
                    AppState.passageZoomLevel = Math.max(0.5, Math.min(3, AppState.passageZoomLevel + amount));
                    passageContent.style.transform = `scale(${AppState.passageZoomLevel})`;
                    passageContent.style.transformOrigin = 'top left';

                } else if (target === 'question') {
                    // Update and apply zoom ONLY for the question
                    AppState.zoomLevel = Math.max(0.5, Math.min(3, AppState.zoomLevel + amount));
                    scalableContent.style.transform = `scale(${AppState.zoomLevel})`;
                }
            }
            /**
             * Populates the filter options for the custom pathway generator.
             */
     function populateCustomFilters() {
    const subjectData = getCurrentSubjectData();
    
    // 1. Calculate Counts
    const counts = {
        difficulty: {},
        year: {},
        reportingCategory: {},
        cluster: {},
        itemType: {}
    };

    subjectData.allQuestions.forEach(q => {
        if(q.difficulty) counts.difficulty[q.difficulty] = (counts.difficulty[q.difficulty] || 0) + 1;
        if(q.year) counts.year[q.year] = (counts.year[q.year] || 0) + 1;
        if(q.reportingCategory) counts.reportingCategory[q.reportingCategory] = (counts.reportingCategory[q.reportingCategory] || 0) + 1;
        if(q.cluster) counts.cluster[q.cluster] = (counts.cluster[q.cluster] || 0) + 1;
        if(q.itemType) counts.itemType[q.itemType] = (counts.itemType[q.itemType] || 0) + 1;
    });

    // 2. Define Filter Groups
    const filters = {
        'Difficulty': { 
            dbKey: 'difficulty',
            values: ['Masters', 'Meets', 'Approaches', 'Unrated'] 
        },
        'Year': { 
            dbKey: 'year',
            values: [...new Set(subjectData.allQuestions.map(q => q.year))].filter(Boolean).sort((a,b) => b-a) 
        },
        'Reporting Category': { 
            dbKey: 'reportingCategory',
            values: [...new Set(subjectData.allQuestions.map(q => q.reportingCategory))].filter(Boolean).sort() 
        },
        'Cluster': { 
            dbKey: 'cluster',
            values: [...new Set(subjectData.allQuestions.map(q => q.cluster))].filter(Boolean).sort() 
        },
        'Item Type': { 
            dbKey: 'itemType',
            values: [...new Set(subjectData.allQuestions.map(q => q.itemType))].filter(Boolean).sort() 
        },
    };

    filterContainer.innerHTML = '';
    
    // 3. Render Groups
    for (const label in filters) {
        const groupData = filters[label];
        
        const group = document.createElement('div');
        group.className = 'mb-4';
        group.innerHTML = `<div class="flex justify-between items-center mb-2">
                            <h3 class="font-semibold">${label}</h3>
                            <button class="text-sm text-blue-600 hover:underline select-all-btn" data-group-id="filter-${label.toLowerCase().replace(/ /g, '-')}">Select All</button>
                         </div>`;
        
        const checkboxContainer = document.createElement('div');
        checkboxContainer.className = 'filter-group space-y-1'; // Added space-y-1 for breathing room
        checkboxContainer.id = `filter-${label.toLowerCase().replace(/ /g, '-')}`;
        
        groupData.values.forEach(value => {
            const count = counts[groupData.dbKey][value] || 0;
            const labelEl = document.createElement('label');
            // Added hover effect and pointer cursor
            labelEl.className = 'flex items-center w-full cursor-pointer hover:bg-gray-50 p-1 rounded';
            
            labelEl.innerHTML = `
                <input type="checkbox" class="rounded mr-2" data-filter-key="${label}" value="${value}">
                <span class="text-sm text-gray-700 whitespace-nowrap">${value}</span>
                
                <div class="flex-grow border-b-2 border-dotted border-gray-300 mx-2 relative top-1"></div>
                
                <span class="text-xs text-gray-500 font-mono bg-gray-100 px-2 py-0.5 rounded-full border border-gray-200">${count}</span>
            `;
            checkboxContainer.appendChild(labelEl);
        });
        
        group.appendChild(checkboxContainer);
        filterContainer.appendChild(group);
    }
    
    document.querySelectorAll('.select-all-btn').forEach(btn => {
        btn.onclick = (e) => {
            const groupId = e.target.dataset.groupId;
            const checkboxes = document.querySelectorAll(`#${groupId} input[type="checkbox"]`);
            const shouldCheck = Array.from(checkboxes).some(cb => !cb.checked);
            checkboxes.forEach(cb => cb.checked = shouldCheck);
        };
    });
}
      // --- SORTING COMPARATORS ---

/**
 * Sorts questions by Year (Descending) then Question Number (Ascending).
 */
function logicalSortComparator(a, b) {
    const yearA = parseInt(a.year, 10);
    const yearB = parseInt(b.year, 10);
    const numA = parseInt(a.id.match(/Q(\d+)/)[1], 10);
    const numB = parseInt(b.id.match(/Q(\d+)/)[1], 10);

    // 1. Sort by Year (Descending)
    if (yearA !== yearB) {
        return yearB - yearA;
    }
    
    // 2. Sort by Question Number (Ascending)
    return numA - numB;
}

/**
 * Sorts questions by Question Number (Ascending) then Year (Ascending).
 */
function numericalSortComparator(a, b) {
    const yearA = parseInt(a.year, 10);
    const yearB = parseInt(b.year, 10);
    const numA = parseInt(a.id.match(/Q(\d+)/)[1], 10);
    const numB = parseInt(b.id.match(/Q(\d+)/)[1], 10);

    // 1. Sort by Question Number (Ascending)
    if (numA !== numB) {
        return numA - numB;
    }
    
    // 2. Sort by Year (Ascending)
    return yearA - yearB;
}

/**
 * Generates and saves a custom pathway based on the selected filters and sort order.
 * UPDATED: Includes logic to sort questions based on user selection.
 */
function generateCustomPathway() {
    const selectedFilters = {};
    let filterDescription = [];
    filterContainer.querySelectorAll('input[type="checkbox"]:checked').forEach(cb => {
        const key = cb.dataset.filterKey;
        if (!selectedFilters[key]) {
            selectedFilters[key] = [];
        }
        selectedFilters[key].push(cb.value);
    });

    // Get the selected sort order
    const sortDropdown = document.getElementById('pathway-sort-dropdown');
    const sortMethod = sortDropdown ? sortDropdown.value : 'logical';

    Object.entries(selectedFilters).forEach(([key, values]) => {
        if (values.length > 0) {
            filterDescription.push(`${key}: ${values.join(', ')}`);
        }
    });

    const subjectData = getCurrentSubjectData();
    let filteredQuestions = subjectData.allQuestions.filter(q => {
        return Object.entries(selectedFilters).every(([key, values]) => {
            let propName;
            
            if (key === 'Difficulty') propName = 'difficulty'; 
            else if (key === 'Reporting Category') propName = 'reportingCategory';
            else if (key === 'Cluster') propName = 'cluster';
            else if (key === 'Year') propName = 'year';
            else if (key === 'Item Type') propName = 'itemType';
            
            else return true;

            return values.includes(q[propName]);
        });
    });

    if (filteredQuestions.length === 0) {
        showCustomModal('No Questions Found', 'No questions match the selected filters.', null);
        return;
    }

    // --- APPLY SORTING LOGIC ---
    if (sortMethod === 'random') {
        filteredQuestions.sort(() => Math.random() - 0.5); // Random Shuffle
    } else if (sortMethod === 'numerical') {
        filteredQuestions.sort(numericalSortComparator);
    } else { // Default to 'logical'
        filteredQuestions.sort(logicalSortComparator);
    }

    const filteredQuestionIds = filteredQuestions.map(q => q.id); // Store IDs after sorting

    const pathwayName = filterDescription.length > 0 ? 
                        `${filterDescription.join(' | ')} (${filteredQuestionIds.length} items)` :
                        `Custom Pathway (${filteredQuestionIds.length} items)`;

    const newPathway = {
        id: `custom-${Date.now()}`,
        name: pathwayName,
        filterDescription: filterDescription.join(' | '),
        questionIds: filteredQuestionIds,
        sortMethod: sortMethod // Save the sort method for future reference
    };

    subjectData.customPathways.unshift(newPathway);
    
    saveState();
    renderDashboard();
}
            /**
             * Shows the review modal with all questions that need manual setup.
             */
            function reviewAllNeedingSetup() {
                const questionsToReview = getCurrentSubjectData().allQuestions.filter(q => q.needsReview);
                if (questionsToReview.length > 0) {
                    showReviewModal('Review All Questions Needing Setup', questionsToReview);
                } else {
                    showCustomModal('All Set!', 'There are no more questions that need manual setup.', null);
                    reviewAllContainer.classList.add('hidden');
                }
            }
            
            /**
             * Updates the "Review All" button with the count of questions needing review.
             */
            function updateReviewAllButton() {
                const questionsToReview = getCurrentSubjectData().allQuestions.filter(q => q.needsReview);
                if (questionsToReview.length > 0) {
                    reviewAllContainer.classList.remove('hidden');
                    reviewAllBtn.textContent = `Review ${questionsToReview.length} Questions Needing Setup`;
                } else {
                    reviewAllContainer.classList.add('hidden');
                }
            }

            /**
             * Resets the entire UI and application state.
             */
            function resetUI() {
                const subjectData = getCurrentSubjectData();
                subjectData.pdfDoc = null;
                subjectData.allQuestions = [];
                subjectData.masteryState = {};
                subjectData.teksToRcMap = {};
                subjectData.customPathways = [];
                statusDiv.textContent = '';
                pathwayDisplay.innerHTML = '';
                placeholderView.classList.remove('hidden');
                customPathwayBuilder.classList.add('hidden');
                reviewAllContainer.classList.add('hidden');
                showDashboard();
            }
// ADD THESE THREE NEW FUNCTIONS

            /**
             * Shows the print options modal and sets up its event listeners.
             * @param {Array<Object>} questions The array of questions to be printed.
             * @param {string} pathwayName The name of the pathway for the print header.
             */
/**
 * Shows the print options modal and sets up its event listeners.
 * Fixed to prevent "null parent" errors on repeated clicks.
 */
function showPrintOptionsModal(questions, pathwayName) {
    // Re-select elements by ID to ensure we have the live DOM nodes
    const modal = document.getElementById('print-options-modal');
    const loader = document.getElementById('print-modal-loader');
    const cancelBtn = document.getElementById('cancel-print-btn');
    const generateBtn = document.getElementById('generate-print-btn');
    const includeAnswersToggle = document.getElementById('include-answers-toggle');
    const includeRationalesToggle = document.getElementById('include-rationales-toggle');

    modal.classList.remove('hidden');
    loader.classList.add('hidden');

    // Reset toggles to default
    includeAnswersToggle.checked = false;
    includeRationalesToggle.checked = false;

    // Assign new click listeners directly (overwriting any old ones)
    cancelBtn.onclick = () => {
        modal.classList.add('hidden');
    };

    generateBtn.onclick = async () => {
        const includeAnswers = includeAnswersToggle.checked;
        const includeRationales = includeRationalesToggle.checked;

        loader.classList.remove('hidden'); // Show loader
        
        // Pass both booleans to the generation function
        await generatePrintPage(questions, includeAnswers, includeRationales, pathwayName);
        
        loader.classList.add('hidden'); // Hide loader
        modal.classList.add('hidden'); // Hide modal
    };
}
/**
 * Helper to format the correct answer string based on question type.
 */
function getAnswerStringForQuestion(question) {
    if (!question) return "Unknown";

    if (question.answerText && question.answerText.length > 0) {
        // Handles Multiple Choice, Multipart, Multiselect
        return question.answerText.join(', ');
    } else if (question.textEntryAnswer) {
        return question.textEntryAnswer;
    } else if (question.inlineChoiceAnswer) {
        return question.inlineChoiceAnswer.join(', ');
    } else if (question.graphingAnswer) {
        return "See Graph Solution";
    } else if (question.hotspotAnswer) {
        return "See Hotspot Solution";
    } else if (question.dragAndDropAnswers) {
         return question.dragAndDropAnswers.join(', ');
    }
    
    return "Not Set";
}
/**
 * Generates the printable page.
 * UPDATED: Increased rendering scale from 1.5 to 3.0 for high print resolution.
 */
async function generatePrintPage(questions, includeAnswers, includeRationales, pathwayName) {
    const printWindow = window.open('', '_blank');
    if (!printWindow) {
        showCustomModal("Popup Blocked", "Please allow popups for this site to generate a printable version.", null);
        return;
    }

    printWindow.document.write(`
        <html>
        <head>
            <title>Printable - ${pathwayName}</title>
            <style>
                body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; margin: 0; }
                .page-container { width: 8.5in; min-height: 11in; padding: 0.5in; box-sizing: border-box; margin: 0 auto; }
                .print-header { font-size: 1.5rem; font-weight: bold; text-align: center; margin-bottom: 20px; border-bottom: 2px solid #000; padding-bottom: 10px; }
                .question-container { 
                    margin-top: 20px; 
                    border-top: 1px solid #ccc;
                    padding-top: 15px;
                    page-break-inside: avoid; /* Keep question components together */
                }
                .question-title { font-weight: bold; font-size: 1.1rem; margin-bottom: 10px; }
                .question-image { 
                    width: 100%; 
                    height: auto; 
                    border: 1px solid #eee;
                    margin-bottom: 10px;
                }
                .answer-key { 
                    background-color: #f3f3f3; 
                    border: 1px solid #ddd; 
                    padding: 10px; 
                    margin-top: 10px; 
                    font-weight: bold;
                    font-size: 1.1rem;
                }
                /* NEW RATIONALE STYLES */
                .rationale-container {
                    margin-top: 10px;
                    border: 1px solid #e5e7eb;
                    border-radius: 8px;
                    padding: 10px;
                    background-color: #f9fafb;
                }
                .rationale-header {
                    font-size: 0.9rem;
                    font-weight: bold;
                    color: #4b5563;
                    margin-bottom: 5px;
                    text-transform: uppercase;
                }
                .rationale-item {
                    padding: 8px;
                    margin-bottom: 4px;
                    border-radius: 4px;
                    font-size: 0.9rem;
                    border: 1px solid;
                }
                .rationale-correct {
                    background-color: #d1fae5; /* Green-100 */
                    border-color: #34d399;     /* Green-400 */
                    color: #065f46;            /* Green-800 */
                }
                .rationale-incorrect {
                    background-color: #fee2e2; /* Red-100 */
                    border-color: #f87171;     /* Red-400 */
                    color: #991b1b;            /* Red-800 */
                }
                
                @media print {
                    body { margin: 0; }
                    .page-container { width: 100%; padding: 0; box-shadow: none; }
                    .rationale-correct { 
                        background-color: #d1fae5 !important; 
                        -webkit-print-color-adjust: exact; 
                        color-adjust: exact; 
                    }
                    .rationale-incorrect { 
                        background-color: #fee2e2 !important; 
                        -webkit-print-color-adjust: exact; 
                        color-adjust: exact; 
                    }
                }
            </style>
        </head>
        <body>
            <div class="page-container">
                <h1 class="print-header">${pathwayName}</h1>
                <div id="content">Generating document...</div>
            </div>
        </body>
        </html>
    `);
    printWindow.document.close();

    const contentDiv = printWindow.document.getElementById('content');
    contentDiv.innerHTML = ''; 

    let lastPassagePrinted = null; 

    // Loop through questions
    for (const [index, question] of questions.entries()) {
        const questionDiv = printWindow.document.createElement('div');
        questionDiv.className = 'question-container';
        
        // 1. Passage Logic
        const subjectData = getCurrentSubjectData();
        let passagePages = question.passagePageNums || [];
        let currentPassageIdentifier = passagePages.join(',');

        if (currentPassageIdentifier && currentPassageIdentifier !== lastPassagePrinted) {
            for (const pageNum of passagePages) {
                try {
                    const passagePage = await subjectData.pdfDoc.getPage(pageNum);
                    const viewport = passagePage.getViewport({ scale: 3.0 }); // <-- HIGH RES FIX HERE
                    const passageCanvas = printWindow.document.createElement('canvas');
                    passageCanvas.width = viewport.width;
                    passageCanvas.height = viewport.height;
                    
                    await passagePage.render({ canvasContext: passageCanvas.getContext('2d'), viewport }).promise;

                    const img = printWindow.document.createElement('img');
                    img.className = 'question-image';
                    img.style.borderBottom = "4px double #ccc"; // Visual separator for passage
                    img.src = passageCanvas.toDataURL('image/png');
                    questionDiv.appendChild(img);
                } catch (e) {
                    console.error("Passage render error:", e);
                }
            }
            lastPassagePrinted = currentPassageIdentifier;
        }

        // 2. Question Title
        const title = printWindow.document.createElement('h3');
        title.className = 'question-title';
        title.textContent = `Question ${index + 1} (TEKS: ${question.teks})`;
        questionDiv.appendChild(title);

        // 3. Question Image(s)
        const canvases = await createQuestionCanvases(question, 4.0); // <-- HIGH RES FIX HERE
        for (const canvas of canvases) {
            const img = printWindow.document.createElement('img');
            img.className = 'question-image';
            img.src = canvas.toDataURL('image/png'); 
            questionDiv.appendChild(img);
        }

        // 4. Rationales Logic (NEW)
        if (includeRationales && question.rationaleMap && Object.keys(question.rationaleMap).length > 0) {
            const rationaleContainer = printWindow.document.createElement('div');
            rationaleContainer.className = 'rationale-container';
            
            const header = printWindow.document.createElement('div');
            header.className = 'rationale-header';
            header.textContent = "Item Rationales:";
            rationaleContainer.appendChild(header);

            // Determine if Multipart
            const isMultipart = (question.itemType || "").toLowerCase().includes('multipart');
            const sortedKeys = Object.keys(question.rationaleMap).sort();

            sortedKeys.forEach(key => {
                // Determine if this specific key is correct
                let isCorrect = false;
                const explanation = question.rationaleMap[key];
                
                // Logic to extract letter from key (e.g., "A", "PartA_C")
                let displayLetter = key;
                let cleanLetter = key;
                
                if (key.includes('_')) {
                    // e.g. PartA_A -> Clean: A
                    cleanLetter = key.split('_')[1];
                    displayLetter = key.replace('_', ' - Option ');
                } else {
                    displayLetter = `Option ${key}`;
                }

                // Check correctness against answerText array
                if (question.answerText) {
                    if (isMultipart) {
                        // PartA keys check against answerText[0], PartB against answerText[1]
                        if (key.startsWith('PartA') && question.answerText[0] === cleanLetter) isCorrect = true;
                        if (key.startsWith('PartB') && question.answerText[1] === cleanLetter) isCorrect = true;
                    } else {
                        // Standard check: is this letter in the answer array?
                        if (question.answerText.includes(cleanLetter)) isCorrect = true;
                    }
                }

                const itemDiv = printWindow.document.createElement('div');
                itemDiv.className = `rationale-item ${isCorrect ? 'rationale-correct' : 'rationale-incorrect'}`;
                // Add Check/X icon
                const icon = isCorrect ? "✅" : "❌";
                itemDiv.innerHTML = `<strong>${icon} ${displayLetter}:</strong> ${explanation}`;
                rationaleContainer.appendChild(itemDiv);
            });

            questionDiv.appendChild(rationaleContainer);
        }

        // 5. Simple Answer Key Logic (Existing)
        if (includeAnswers) {
            const answerDiv = printWindow.document.createElement('div');
            answerDiv.className = 'answer-key';
            answerDiv.textContent = `Correct Answer: ${getAnswerStringForQuestion(question)}`;
            questionDiv.appendChild(answerDiv);
        }
        
        contentDiv.appendChild(questionDiv);
    }

    // Wait for images to render before printing
    setTimeout(() => {
        printWindow.print();
    }, 1500);
}
function showCustomModal(title, message, onClose, showCancel = false, showInput = false) {
    const modalId = 'custom-alert-modal';
    document.getElementById(modalId)?.remove();

    const inputFieldHTML = showInput ? `
        <input type="number" id="custom-modal-input" placeholder="Enter 4-digit year (e.g., 2023)"
               class="mt-3 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm text-center font-bold text-lg p-2"
               min="2000" max="2099" />
    ` : '';
    
    const cancelButtonHTML = showCancel ? `<button id="cancel-custom-modal" class="w-full mt-2 px-4 py-2 bg-gray-200 text-gray-700 font-semibold rounded-md hover:bg-gray-300">Go Back</button>` : '';

    const modalHtml = `
        <div id="${modalId}" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center p-4 z-50">
            <div class="bg-white rounded-lg shadow-xl w-full max-w-sm p-6 text-center">
                <h3 class="text-xl font-bold mb-4">${title}</h3>
                <p class="text-gray-700 mb-2">${message}</p>
                ${inputFieldHTML}
                <div class="mt-6">
                    <button id="close-custom-modal" class="w-full px-4 py-2 bg-indigo-600 text-white font-semibold rounded-md hover:bg-indigo-700">OK</button>
                    ${cancelButtonHTML}
                </div>
            </div>
        </div>`;
    document.body.insertAdjacentHTML('beforeend', modalHtml);
    
    const closeModal = () => document.getElementById(modalId)?.remove();
    const inputElement = document.getElementById('custom-modal-input');

    document.getElementById('close-custom-modal').addEventListener('click', () => {
        let inputYear = showInput ? inputElement.value : null;
        closeModal();
        if (onClose) onClose(true, inputYear); // Pass true (confirmed) and the input value
    });
    
    if(showCancel) {
        document.getElementById('cancel-custom-modal').addEventListener('click', () => {
             closeModal();
             if (onClose) onClose(false, null); // Pass false (canceled)
        });
    }
}
/**
 * Shows the review modal for a single question or an array of questions.
 * UPDATED: Renders a "Solution" box for Math/Rubric questions (non-multiple choice).
 */
async function showReviewModal(title, questionsData) {
    const questions = Array.isArray(questionsData) ? questionsData : [questionsData];
    
    const reviewModalTitle = document.getElementById('review-modal-title');
    const reviewModalContent = document.getElementById('review-modal-content');
    const reviewModal = document.getElementById('review-modal');

    reviewModalTitle.textContent = title;
    reviewModalContent.innerHTML = ''; 
    reviewModal.classList.remove('hidden'); 

    for (const question of questions) {
        const item = document.createElement('div');
        item.className = 'review-item';
        item.dataset.needsReview = question.needsReview;
        item.id = `review-container-${question.id}`;

        const type = (question.itemType || "").toLowerCase();
        const isMultipart = type.includes('multipart');
        const needsInteractiveSetup = type.includes('hot spot') || type.includes('drag and drop');
        const needsCropSetup = !question.pageNums || question.pageNums.length === 0; 
        const rMap = question.rationaleMap || {};

        // 1. Helper to build standard A/B/C/D text areas
        const buildRationaleInputs = (prefix, sectionLabel) => {
            return `
                <div class="mt-2 p-2 bg-gray-100 rounded">
                    <h5 class="text-xs font-bold text-gray-500 uppercase mb-1">${sectionLabel}</h5>
                    ${['A', 'B', 'C', 'D'].map(opt => `
                        <div class="flex gap-2 items-start mb-1">
                            <span class="mt-1 text-gray-500 font-bold text-xs w-4">${opt}</span>
                            <textarea 
                                class="rationale-input flex-1 rounded border-gray-300 shadow-sm text-xs p-1 focus:border-indigo-500 focus:ring-indigo-500" 
                                rows="1" 
                                data-question-id="${question.id}" 
                                data-option="${prefix}${opt}"
                                id="rat-input-${question.id}-${prefix}${opt}"
                                placeholder="Explanation for ${opt}...">${rMap[prefix + opt] || ''}</textarea>
                        </div>
                    `).join('')}
                </div>`;
        };

        // 2. NEW HELPER: Build the "Solution" text area (For Math/Rubrics)
        // This box only appears if the parser found "Solution" text.
        const buildSolutionInput = () => {
            if (!rMap['Solution']) return ''; 
            return `
                <div class="mt-2 p-2 bg-blue-50 rounded border border-blue-200">
                    <h5 class="text-xs font-bold text-blue-700 uppercase mb-1">✅ General Solution / Explanation</h5>
                    <textarea 
                        class="rationale-input w-full rounded border-blue-300 shadow-sm text-xs p-2 focus:border-blue-500 focus:ring-blue-500 font-medium text-gray-700" 
                        rows="6" 
                        data-question-id="${question.id}" 
                        data-option="Solution"
                        id="rat-input-${question.id}-Solution"
                        placeholder="General solution text found by parser...">${rMap['Solution']}</textarea>
                </div>`;
        };

        // Combine inputs: Standard Options + The New Solution Box
        let rationaleHTML = isMultipart 
            ? `<div class="grid grid-cols-1 md:grid-cols-2 gap-2">${buildRationaleInputs('PartA_', 'Part A')}${buildRationaleInputs('PartB_', 'Part B')}</div>`
            : buildRationaleInputs('', 'Rationale');
        
        // Append the solution box at the bottom
        rationaleHTML += buildSolutionInput();

        // --- CONTROLS SIDE (Right) ---
        let controlsHTML = `
            <div class="bg-gray-50 p-4 rounded-lg space-y-4 h-full overflow-y-auto">
                <h3 class="font-bold text-lg text-indigo-700 border-b pb-2 sticky top-0 bg-gray-50 z-10">${question.id}</h3>
                
                <div class="grid grid-cols-2 gap-4">
                    <div>
                        <label class="block text-sm font-medium text-gray-700">TEKS</label>
                        <input type="text" id="review-teks-${question.id}" value="${question.teks || ''}" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm sm:text-sm">
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700">Item Type</label>
                        <input type="text" id="review-itemType-${question.id}" value="${question.itemType || ''}" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm sm:text-sm">
                    </div>
                </div>

                <div>
                    <label class="block text-sm font-medium text-gray-700">Correct Answer(s)</label>
                    <input type="text" id="review-answer-${question.id}" value="${question.answerText ? question.answerText.join(', ') : (question.textEntryAnswer || '')}" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm sm:text-sm font-bold text-green-700">
                </div>

                <div class="border-t border-b border-gray-200 py-4">
                    <h4 class="font-semibold text-sm text-purple-800 mb-1">Smart Feedback</h4>
                    ${rationaleHTML}
                </div>
                
                ${needsCropSetup ? `
                <div class="pt-2">
                    <h4 class="font-semibold mb-2 text-xs uppercase text-gray-500">Image Tools</h4>
                    <div class="grid grid-cols-3 gap-2">
                        <button class="manual-crop-btn p-2 bg-white border border-blue-300 text-blue-700 text-xs rounded hover:bg-blue-50" data-question-id="${question.id}">Manual Crop</button>
                        <button class="auto-crop-btn p-2 bg-white border border-gray-300 text-gray-700 text-xs rounded hover:bg-gray-50" data-question-id="${question.id}">Auto-Detect</button>
                        <button class="full-page-btn p-2 bg-white border border-gray-300 text-gray-700 text-xs rounded hover:bg-gray-50" data-question-id="${question.id}">Full Page</button>
                    </div>
                </div>` : ''}

               ${needsInteractiveSetup ? `
                <div class="pt-2 border-t border-gray-200">
                    <h4 class="font-semibold mb-2 text-md text-purple-800">Interactive Zones & Key</h4>
                    
                    <div class="grid grid-cols-2 gap-2 mb-4">
                        <button class="add-zone-btn p-2 bg-green-100 text-green-700 text-xs rounded hover:bg-green-200" data-question-id="${question.id}">+ Add Zone</button>
                        <button class="clear-zones-btn p-2 bg-red-100 text-red-700 text-xs rounded hover:bg-red-200" data-question-id="${question.id}">Clear Zones</button>
                    </div>

                    ${type.includes('drag and drop') ? `
                    <div id="dnd-key-editor-${question.id}">
                        <h5 class="text-sm font-semibold mt-4 mb-2">Answer Key Mapping</h5>
                        <div id="key-zones-${question.id}" class="flex flex-wrap gap-2 p-2 border border-dashed border-purple-300 rounded-lg mb-4"></div>
                        <h5 class="text-sm font-semibold mb-1">Answer Bank Options (Source)</h5>
                        <textarea 
                            id="dnd-options-input-${question.id}"
                            class="w-full rounded-md border-gray-300 shadow-sm text-sm p-2"
                            rows="2"
                            placeholder="Type options separated by commas (e.g., Option A, Option B)"
                            data-question-id="${question.id}">${question.draggableOptions ? question.draggableOptions.join(', ') : ''}</textarea>
                        
                        <div id="dnd-bank-${question.id}" class="flex flex-wrap gap-2 p-2 bg-gray-100 rounded-lg"></div>
                    </div>
                    ` : ''}

                </div>` : ''}
            </div>
        `;

        // --- CANVAS SIDE (Left) ---
        let canvasHTML = `
            <div class="relative h-fit">
                <div class="flex justify-center space-x-2 mb-2">
                    <button class="view-toggle-btn active px-4 py-1 bg-indigo-600 text-white text-sm font-semibold rounded-full shadow-sm" data-mode="question" data-qid="${question.id}">Question Image</button>
                    <button class="view-toggle-btn px-4 py-1 bg-gray-200 text-gray-700 text-sm font-semibold rounded-full shadow-sm hover:bg-gray-300" data-mode="rationale" data-qid="${question.id}">Rationale Source</button>
                </div>

                <div id="rat-nav-${question.id}" class="hidden flex items-center justify-between bg-purple-50 p-2 rounded mb-2 border border-purple-200">
                    <button class="prev-page-btn px-2 py-1 bg-white border rounded text-xs hover:bg-gray-50" data-qid="${question.id}">◀ Prev</button>
                    
                    <div class="flex items-center space-x-1">
                        <label for="rat-page-input-${question.id}" class="text-xs text-purple-800 font-bold">Page</label>
                        <input type="number" id="rat-page-input-${question.id}" value="${question.displayRationalePage || question.rationalePage || 1}" 
                               min="1" class="w-12 text-center text-xs font-bold text-purple-800 rounded border border-purple-300">
                        <span class="text-xs text-purple-800 font-bold" id="rat-total-pages-${question.id}">of ?</span>
                    </div>
                    
                    <button class="next-page-btn px-2 py-1 bg-white border rounded text-xs hover:bg-gray-50" data-qid="${question.id}">Next ▶</button>
                    <button class="scan-page-btn ml-4 px-3 py-1 bg-purple-600 text-white text-xs font-bold rounded shadow hover:bg-purple-700" data-qid="${question.id}">⚡ Scan This Page</button>
                </div>

                <div class="bg-white rounded-lg border shadow-sm overflow-hidden min-h-[300px] flex items-center justify-center relative">
                     <div id="scalable-content-review-${question.id}" class="scalable-content relative w-full"></div>
                </div>
            </div>
        `;

        item.innerHTML = canvasHTML + controlsHTML;
        reviewModalContent.appendChild(item);
        
        // --- LOGIC: Render Default (Question) ---
        const container = document.getElementById(`scalable-content-review-${question.id}`);
        
        const renderQuestionMode = async () => {
            container.innerHTML = '';
            const canvases = await createQuestionCanvases(question, 4.0, false); 
            canvases.forEach(c => {
                c.className = 'review-canvas w-full h-auto';
                container.appendChild(c);
            });
            if (needsCropSetup) redrawCropBox(question);
            if (needsInteractiveSetup) redrawZones(question);
        };

        const renderRationaleMode = async () => {
            const subjectData = getCurrentSubjectData();
            if (!subjectData.rationalePdfDoc) {
                container.innerHTML = `<div class="p-10 text-center text-gray-500">No Rationale PDF uploaded.<br>Please upload one in the dashboard.</div>`;
                return;
            }
            
            container.innerHTML = '<div class="loader mx-auto mt-10"></div>';
            
            try {
                const doc = subjectData.rationalePdfDoc;
                let pageNum = question.displayRationalePage || question.rationalePage || 1;
                pageNum = Math.max(1, Math.min(pageNum, doc.numPages));
                question.displayRationalePage = pageNum;
                
                document.getElementById(`rat-page-input-${question.id}`).value = pageNum;
                document.getElementById(`rat-page-input-${question.id}`).max = doc.numPages;
                document.getElementById(`rat-total-pages-${question.id}`).textContent = `of ${doc.numPages}`;
                
                const page = await doc.getPage(pageNum);
                const viewport = page.getViewport({ scale: 1.5 });
                const canvas = document.createElement('canvas');
                canvas.width = viewport.width;
                canvas.height = viewport.height;
                canvas.className = 'w-full h-auto shadow-md';
                
                await page.render({ canvasContext: canvas.getContext('2d'), viewport }).promise;
                container.innerHTML = '';
                container.appendChild(canvas);
            } catch (e) {
                container.innerHTML = `<div class="text-red-500 p-4">Error loading page: ${e.message}</div>`;
            }
        };

        await renderQuestionMode();

        // --- EVENT LISTENERS ---
        const toggles = item.querySelectorAll('.view-toggle-btn');
        const navBar = document.getElementById(`rat-nav-${question.id}`);
        
        toggles.forEach(btn => {
            btn.addEventListener('click', () => {
                toggles.forEach(b => {
                    b.classList.remove('bg-indigo-600', 'text-white');
                    b.classList.add('bg-gray-200', 'text-gray-700');
                });
                btn.classList.remove('bg-gray-200', 'text-gray-700');
                btn.classList.add('bg-indigo-600', 'text-white');

                const mode = btn.dataset.mode;
                if (mode === 'question') {
                    navBar.classList.add('hidden');
                    renderQuestionMode();
                } else {
                    if (!question.displayRationalePage) question.displayRationalePage = question.rationalePage || 1;
                    navBar.classList.remove('hidden');
                    renderRationaleMode();
                }
            });
        });

        // Navigation
        item.querySelector('.prev-page-btn').onclick = () => {
            if (question.displayRationalePage > 1) {
                question.displayRationalePage--;
                renderRationaleMode();
            }
        };
        item.querySelector('.next-page-btn').onclick = () => {
            const doc = getCurrentSubjectData().rationalePdfDoc;
            if (doc && question.displayRationalePage < doc.numPages) {
                question.displayRationalePage++;
                renderRationaleMode();
            }
        };
        document.getElementById(`rat-page-input-${question.id}`).addEventListener('change', (e) => {
            const doc = getCurrentSubjectData().rationalePdfDoc;
            const newPage = parseInt(e.target.value, 10);
            if (doc && newPage >= 1 && newPage <= doc.numPages) {
                question.displayRationalePage = newPage;
                renderRationaleMode();
            } else {
                e.target.value = question.displayRationalePage || question.rationalePage || 1;
            }
        });

        // 3. RE-SCAN BUTTON
        item.querySelector('.scan-page-btn').onclick = async () => {
            const doc = getCurrentSubjectData().rationalePdfDoc;
            if (!doc) return;
            
            const btn = item.querySelector('.scan-page-btn');
            const originalText = btn.textContent;
            btn.textContent = "Scanning...";
            
            try {
                const page = await doc.getPage(question.displayRationalePage);
                const textContent = await page.getTextContent();
                const pageText = textContent.items.map(i => i.str).join('\n');
                
                const rationales = parseRationalesText(pageText);
                const qNum = question.id.split('-Q')[1].replace(/^0+/, ''); 
                const found = rationales.find(r => r.number == qNum);
                
                if (found && found.rationaleMap) {
                    question.rationaleMap = { ...question.rationaleMap, ...found.rationaleMap };
                    
                    // Force refresh of the UI elements by re-showing the modal content for this item
                    // Note: In a robust app, we'd update DOM elements individually, but for now, 
                    // alert the user to reopen the modal or just update the inputs if found.
                    
                    Object.keys(found.rationaleMap).forEach(key => {
                        let input = document.getElementById(`rat-input-${question.id}-${key}`);
                        if (input) {
                            input.value = found.rationaleMap[key];
                            input.classList.add('bg-green-100');
                            setTimeout(() => input.classList.remove('bg-green-100'), 1000);
                        }
                    });
                    
                    btn.textContent = "✅ Updated!";
                } else {
                    btn.textContent = "❌ Not found";
                }
            } catch (e) {
                console.error(e);
                btn.textContent = "Error";
            }
            setTimeout(() => btn.textContent = originalText, 2000);
        };

        // Standard Listeners 
        item.querySelectorAll('.rationale-input').forEach(input => {
            input.addEventListener('change', (e) => {
                if (!question.rationaleMap) question.rationaleMap = {};
                question.rationaleMap[e.target.dataset.option] = e.target.value;
            });
        });
        document.getElementById(`review-teks-${question.id}`).addEventListener('change', (e) => {
            question.teks = e.target.value; question.needsReview = false; 
        });
        document.getElementById(`review-answer-${question.id}`).addEventListener('change', (e) => {
            const val = e.target.value;
            const t = question.itemType.toLowerCase();
            if(t.includes('multiple') || t.includes('multipart') || t.includes('multiselect')) {
                question.answerText = val.split(',').map(s => s.trim());
            } else { question.textEntryAnswer = val.trim(); }
            question.needsReview = false;
        });

        if (needsCropSetup) {
            item.querySelector('.manual-crop-btn').addEventListener('click', enterManualCropMode);
            item.querySelector('.auto-crop-btn').addEventListener('click', resetCropToAuto);
            item.querySelector('.full-page-btn').addEventListener('click', resetCropToFullPage);
        }
        if (needsInteractiveSetup) {
            item.querySelector('.add-zone-btn').addEventListener('click', enterLayoutEditorMode);
            item.querySelector('.clear-zones-btn').addEventListener('click', clearInteractiveZones);
            if (type.includes('drag and drop')) {
                setupAnswerKeyEditor(question);
                document.getElementById(`dnd-options-input-${question.id}`).addEventListener('change', updateDraggableOptions);
            }
        }
    }
}
            function showFinishConfirmationModal() {
                showCustomModal(
                    "Finish Quiz?",
                    "You have unanswered questions. Are you sure you want to finish and see your results?",
                    (confirmed) => {
                        if (confirmed) {
                            renderResultsScreen();
                        }
                    },
                    true // Show cancel button
                );
                // Adjust button text for clarity
                setTimeout(() => {
                    const closeBtn = document.getElementById('close-custom-modal');
                    if(closeBtn) closeBtn.textContent = "Finish Anyway";
                }, 0);
            }

            function renderMissedQuestionsGrid(missedQuestions) {
    const missedQuestionsGrid = document.getElementById('missed-questions-grid');
    if (!missedQuestionsGrid) return; // Safety check!

    missedQuestionsGrid.innerHTML = ''; 

    if (missedQuestions.length === 0) {
         missedQuestionsGrid.innerHTML = `
            <div class="col-span-full p-8 text-center bg-green-50 rounded-lg border border-green-100">
                <p class="text-2xl text-green-600 font-bold">🎉 Perfect Score!</p>
                <p class="text-green-800">You achieved full points on all questions. No review needed.</p>
            </div>`;
    } else {
         missedQuestions.forEach(q => {
            if (!q || !q.id) return; 
            
            const card = document.createElement('div');
            card.className = 'border border-gray-200 rounded-lg p-4 bg-white shadow-sm hover:shadow-md transition-shadow flex flex-col justify-between h-full';
            
            card.innerHTML = `
                <div class="mb-4">
                    <div class="flex justify-between items-start">
                        <span class="font-bold text-gray-700 text-lg">${q.id}</span>
                        <span class="text-xs px-2 py-1 bg-gray-100 rounded text-gray-600">${q.difficulty || 'Unrated'}</span>
                    </div>
                    <p class="text-xs text-gray-500 mt-1 line-clamp-2" title="${q.teksDescription}">${q.teks}: ${q.teksDescription || 'No description'}</p>
                </div>
                <button class="review-missed-btn w-full px-4 py-2 bg-indigo-50 text-indigo-700 font-semibold text-sm rounded-md hover:bg-indigo-100 transition-colors border border-indigo-100" data-question-id="${q.id}">
                    Review Question
                </button>
            `;
            
            missedQuestionsGrid.appendChild(card);
        });
    }
}



            /**
             * Starts a new practice pathway for a specific topic cluster from the results screen.
             */
            function startTopicPractice(topic) {
                const practiceQuestions = getCurrentSubjectData().allQuestions.filter(q => q.cluster === topic);
                if (practiceQuestions.length > 0) {
                    startPathway(`Practice: ${topic}`, practiceQuestions, { isQuiz: false });
                }
            }

            /**
             * Starts a new pathway to retry a single question from the results screen.
             */
            function retrySingleQuestion(questionId) {
                const question = getCurrentSubjectData().allQuestions.find(q => q.id === questionId);
                if (question) {
                     startPathway(`Retry: ${question.id}`, [question], { isQuiz: false });
                }
            }


            /**
             * Prints the results page.
             */
            function printResults() {
                window.print();
            }

            /**
             * Downloads the results as a text file.
             */
            function downloadResults() {
                const pathway = AppState.currentPathway;
                const mastery = getCurrentSubjectData().masteryState[pathway.teks];
                const correctCount = Object.values(mastery).filter(s => s === 'correct').length;
                const totalCount = pathway.questions.length;

                let textContent = `Results for Pathway: ${pathway.teks}\n`;
                textContent += `Final Score: ${correctCount} / ${totalCount}\n\n`;
                textContent += "Questions to Review:\n";
                
                pathway.questions.forEach((q, index) => {
                    if (mastery[index] !== 'correct') {
                        textContent += `- Question #${index + 1} (ID: ${q.id})\n`;
                    }
                });

                const blob = new Blob([textContent], { type: 'text/plain' });
                const anchor = document.createElement('a');
                anchor.download = `pathway-results-${pathway.teks}.txt`;
                anchor.href = window.URL.createObjectURL(blob);
                anchor.click();
                window.URL.revokeObjectURL(anchor.href);
            }
            
            /**
             * Toggles the "flagged" state for the current question.
             */
            function toggleFlagCurrentQuestion() {
                const { currentIndex, flagged } = AppState.currentPathway;
                flagged[currentIndex] = !flagged[currentIndex]; 
            }

            /**
             * Toggles the filter in the review modal to show all questions or only those needing review.
             */
            function toggleReviewFilter(event) {
                const btn = event.target;
                const isFiltered = btn.dataset.filtered === 'true';
                const items = reviewModalContent.querySelectorAll('.review-item');
                
                if (isFiltered) {
                    items.forEach(item => item.style.display = 'grid');
                    btn.textContent = 'Show Only Questions Needing Review';
                    btn.dataset.filtered = 'false';
                } else {
                    items.forEach(item => {
                        if (item.dataset.needsReview !== 'true') {
                            item.style.display = 'none';
                        }
                    });
                    btn.textContent = 'Show All Questions';
                    btn.dataset.filtered = 'true';
                }
            }

            // --- Quiz Mode Functions ---
            /**
             * Shows the modal for setting up a quiz (e.g., enabling the timer).
             */
            function showQuizSetupModal(teksName, questions) {
                quizSetupModal.classList.remove('hidden');

                const beginQuizHandler = () => {
                    const timerEnabled = enableTimerToggle.checked;
                    const timePerQuestion = parseInt(timePerQuestionInput.value, 10);
                    
                    const timerSettings = timerEnabled ? { time: timePerQuestion * 60 } : null;

                    quizSetupModal.classList.add('hidden');
                    startPathway(teksName, questions, { isQuiz: true, timerSettings });
                    
                    beginQuizBtn.removeEventListener('click', beginQuizHandler);
                };
                
                beginQuizBtn.addEventListener('click', beginQuizHandler);
            }

            /**
             * Starts the timer for a question in quiz mode.
             */
            function startQuestionTimer() {
                let timeLeft = AppState.currentPathway.timerSettings.time;
                timerDisplay.textContent = `${Math.floor(timeLeft / 60)}:${(timeLeft % 60).toString().padStart(2, '0')}`;

                AppState.questionTimer = setInterval(() => {
                    timeLeft--;
                    timerDisplay.textContent = `${Math.floor(timeLeft / 60)}:${(timeLeft % 60).toString().padStart(2, '0')}`;
                    if (timeLeft <= 0) {
                        clearInterval(AppState.questionTimer);
                        evaluateAndAdvanceQuiz(true); // Timed out
                    }
                }, 1000);
            }

            /**
             * Evaluates the current question and advances to the next one in quiz mode.
             */
            function evaluateAndAdvanceQuiz(timedOut = false, isFinishing = false) {
                if(AppState.questionTimer) clearInterval(AppState.questionTimer);

                const pathway = AppState.currentPathway;
                const question = pathway.activeQuestion;
                const type = question.itemType.toLowerCase();
                let isCorrect = false;

                // Only evaluate if not timed out and an answer was given or the question is configured
                if (!timedOut && (AppState.currentPathway.userSelections.length > 0 || (question.interactiveZones && question.interactiveZones.length > 0))) {
                    if (type.includes('multiple choice')) {
                        const userAnswers = AppState.currentPathway.userSelections;
                        const correctAnswers = question.answerText;
                        if(correctAnswers) {
                            let correctCount = 0;
                            userAnswers.forEach((answer, index) => {
                                if (answer === correctAnswers[index]) correctCount++;
                            });
                            isCorrect = correctCount === correctAnswers.length;
                        }
                    } else if (type.includes('hot spot')) {
                        const userClick = AppState.currentPathway.userSelections[0];
                        const correctZone = question.interactiveZones && question.interactiveZones[0];
                        if (userClick && correctZone) {
                            const translatedZone = translateZoneCoordinates(correctZone, question);
                            isCorrect = userClick.x >= translatedZone.x && userClick.x <= translatedZone.x + translatedZone.width &&
                                        userClick.y >= translatedZone.y && userClick.y <= translatedZone.y + translatedZone.height;
                        }
                    } // ... other question type evaluations here with safety checks
                }
                
                // Update status if an answer was submitted, time ran out, or it's an un-configured question
                if(AppState.currentPathway.userSelections.length > 0 || timedOut || !(question.interactiveZones && question.interactiveZones.length > 0)) {
                    getCurrentSubjectData().masteryState[pathway.teks][pathway.currentIndex] = isCorrect ? 'correct' : 'incorrect';
                }

                if (isFinishing) {
                    const hasUnanswered = Object.values(getCurrentSubjectData().masteryState[pathway.teks]).some(s => s === 'not-started');
                    if(hasUnanswered) {
                        showFinishConfirmationModal();
                        return;
                    }
                }

                if (pathway.currentIndex >= pathway.questions.length - 1) {
                    renderResultsScreen();
                } else {
                    pathway.currentIndex++;
                    renderProblem(pathway.questions[pathway.currentIndex]);
                }
            }

            function resetPathwayProgress(pathwayName, questionCount) {
                showCustomModal(
                    `Reset Progress for ${pathwayName}?`,
                    "This will clear all your answers for this pathway and cannot be undone.",
                    (confirmed) => {
                        if (confirmed) {
                            const subjectData = getCurrentSubjectData();
                            if (subjectData.masteryState[pathwayName]) {
                                for (let i = 0; i < questionCount; i++) {
                                    subjectData.masteryState[pathwayName][i] = 'not-started';
                                }
                            }
                            renderDashboard();
                            saveState();
                        }
                    },
                    true // Show cancel button
                );
            }
            
            // --- NEW Crop Editing Functions ---

            /**
             * Redraws the visual overlay for the crop box in the review modal.
             * @param {Object} question The question object.
             */
            function redrawCropBox(question) {
                const container = document.getElementById(`scalable-content-review-${question.id}`);
                container.querySelector('.crop-box-overlay')?.remove(); 

                if (question.cropBox) {
                    const box = document.createElement('div');
                    box.className = 'crop-box-overlay';
                    box.style.left = `${question.cropBox.x * 100}%`;
                    box.style.top = `${question.cropBox.y * 100}%`;
                    box.style.width = `${question.cropBox.width * 100}%`;
                    box.style.height = `${question.cropBox.height * 100}%`;
                    container.appendChild(box);
                }
            }
            
            /**
             * Enters a mode to manually draw a new crop box.
             * @param {Event} event The click event from the button.
             */
            // REPLACE your current enterManualCropMode function with this one

// REPLACE your current enterManualCropMode function with this one

function enterManualCropMode(event) {
    const questionId = event.target.dataset.questionId;
    const question = getCurrentSubjectData().allQuestions.find(q => q.id === questionId);
    const container = document.getElementById(`scalable-content-review-${question.id}`);

    if (!question || container.querySelector('.layout-editor-overlay')) return;

    const overlay = document.createElement('div');
    overlay.className = 'layout-editor-overlay layout-editor-active';
    container.appendChild(overlay);

    let startX, startY, selectionBox, targetCanvas;

    const getCoords = (e, canvas) => {
        const rect = canvas.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        return {
            x: clientX - rect.left,
            y: clientY - rect.top
        };
    }

    const startDraw = (e) => {
        e.preventDefault();

        // --- THIS IS THE SAME FIX, APPLIED HERE ---
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;

        overlay.style.display = 'none';
        const elementUnderneath = document.elementFromPoint(clientX, clientY);
        overlay.style.display = '';

        if (elementUnderneath && elementUnderneath.classList.contains('review-canvas')) {
            targetCanvas = elementUnderneath;
        } else {
            return;
        }
        // --- END OF FIX ---

        const coords = getCoords(e, targetCanvas);
        startX = coords.x;
        startY = coords.y;
        
        selectionBox = document.createElement('div');
        selectionBox.className = 'selection-box';
        selectionBox.style.left = `${startX}px`;
        selectionBox.style.top = `${startY}px`;
        targetCanvas.parentElement.appendChild(selectionBox);
    };

    const draw = (e) => {
        if (selectionBox) {
            e.preventDefault();
            const coords = getCoords(e, targetCanvas);
            const width = coords.x - startX;
            const height = coords.y - startY;
            selectionBox.style.width = `${Math.abs(width)}px`;
            selectionBox.style.height = `${Math.abs(height)}px`;
            if (width < 0) selectionBox.style.left = `${coords.x}px`;
            if (height < 0) selectionBox.style.top = `${coords.y}px`;
        }
    };

    const endDraw = (e) => {
        if (!selectionBox) {
            overlay.remove();
            return;
        }
        e.preventDefault();
        const rect = targetCanvas.getBoundingClientRect();
        const endCoords = getCoords(e.changedTouches ? e.changedTouches[0] : e, targetCanvas);
        
        const newCropBox = {
            x: Math.min(startX, endCoords.x) / rect.width,
            y: Math.min(startY, endCoords.y) / rect.height,
            width: Math.abs(endCoords.x - startX) / rect.width,
            height: Math.abs(endCoords.y - startY) / rect.height,
        };

        if (newCropBox.width > 0.01 && newCropBox.height > 0.01) {
            question.cropBox = newCropBox;
            question.needsReview = false;
        }

        redrawCropBox(question);
        overlay.remove();
    };

    overlay.addEventListener('mousedown', startDraw);
    overlay.addEventListener('mousemove', draw);
    overlay.addEventListener('mouseup', endDraw);
    overlay.addEventListener('touchstart', startDraw);
    overlay.addEventListener('touchmove', draw);
    overlay.addEventListener('touchend', endDraw);
}
            
            /**
             * Resets a question's crop box to the original automatic detection.
             * @param {Event} event The click event from the button.
             */
            async function resetCropToAuto(event) {
                const questionId = event.target.dataset.questionId;
                const question = getCurrentSubjectData().allQuestions.find(q => q.id === questionId);
                const subjectData = getCurrentSubjectData();
                if (!question || !subjectData.pdfDoc) return;

                const page = await subjectData.pdfDoc.getPage(question.pageNum);
                const textContent = await page.getTextContent();
                question.cropBox = detectCropBox(textContent.items, page);
                redrawCropBox(question);
            }
            
            /**
             * Resets a question's crop box to show the full page.
             * @param {Event} event The click event from the button.
             */
            function resetCropToFullPage(event) {
                const questionId = event.target.dataset.questionId;
                const question = getCurrentSubjectData().allQuestions.find(q => q.id === questionId);
                if (question) {
                    question.cropBox = null;
                    redrawCropBox(question);
                }
            }


        function saveState() {
                // Create a serializable version of the state
                const stateToSave = {
                    currentSubject: AppState.currentSubject,
                    subjects: {}
                };

                for (const subjectName in AppState.subjects) {
                    const subjectData = AppState.subjects[subjectName];
                    
                    // Create a copy of the subject data to modify
                    const savedSubject = { ...subjectData };

                    // 1. Exclude the non-serializable PDF objects
                    // We must remove these because they contain "circular references" 
                    // and cannot be saved to localStorage.
                    delete savedSubject.pdfDoc;
                    delete savedSubject.rationalePdfDoc; // <--- THIS IS THE FIX

                    // 2. Exclude the massive 'rawItems' from all questions
                    savedSubject.allQuestions = subjectData.allQuestions.map(question => {
                        const { rawItems, ...questionToSave } = question;
                        return questionToSave;
                    });
                    
                    stateToSave.subjects[subjectName] = savedSubject;
                }

                try {
                    localStorage.setItem('staarMasteryAppData', JSON.stringify(stateToSave));
                } catch (e) {
                    if (e.name === 'QuotaExceededError') {
                        console.error("QuotaExceededError: Failed to save state. Data is too large for localStorage.", e);
                    } else {
                        console.error("Failed to save state:", e);
                    }
                }
            }

            function loadState() {
                const savedState = localStorage.getItem('staarMasteryAppData');
                if (savedState) {
                    const parsedState = JSON.parse(savedState);
                    AppState.currentSubject = parsedState.currentSubject;
                    for (const subjectName in parsedState.subjects) {
                        if (AppState.subjects[subjectName]) {
                            // Merge saved data with the initial structure (which includes pdfDoc: null)
                            Object.assign(AppState.subjects[subjectName], parsedState.subjects[subjectName]);
                        }
                    }
                }
            }

            function getCurrentSubjectData() {
                return AppState.subjects[AppState.currentSubject];
            }

            

            function renderAppForCurrentSubject() {
                const subjectData = getCurrentSubjectData();
                renderSubjectDropdown();
                if (subjectData.allQuestions.length > 0) {
                    statusDiv.textContent = `Loaded ${subjectData.allQuestions.length} questions from saved session.`;
                    if (!subjectData.pdfDoc) {
                        statusDiv.innerHTML += `<br><span class="font-bold text-red-600">Please re-upload the PDF to start a pathway.</span>`;
                    }
                    renderDashboard();
                    populateCustomFilters();
                    updateReviewAllButton();
                    customPathwayBuilder.classList.remove('hidden');
                } else {
                    resetUI();
                }
            }

            function renderSubjectDropdown() {
                subjectDropdown.innerHTML = '';
                Object.keys(AppState.subjects).forEach(subjectName => {
                    const option = document.createElement('option');
                    option.value = subjectName;
                    option.textContent = subjectName;
                    if (subjectName === AppState.currentSubject) {
                        option.selected = true;
                    }
                    subjectDropdown.appendChild(option);
                });
            }



// ==========================================
    // START: ADVANCED AUTOMATION ENGINE (v2)
    // ==========================================

    // 1. MASTER CONFIGURATION
    // This tells the app exactly which files to load and which YEAR to assign them to.
    const SubjectConfig = {
        'Biology': {
            exam: 'assets/pdfs/biologyallquestions.pdf',
            rationales: [
                { year: '2025', file: 'assets/pdfs/2025-staar-biology-rationale.pdf' },
                { year: '2024', file: 'assets/pdfs/2024-staar-biology-rationale.pdf' },
                { year: '2023', file: 'assets/pdfs/2023-staar-biology-rationale.pdf' },
                { year: '2022', file: 'assets/pdfs/2022-staar-biology-rationale.pdf' },
                { year: '2019', file: 'assets/pdfs/2019-staar-biology-rationales.pdf' }
            ]
        }
    };

    /**
     * MAIN AUTO-LOADER
     */
    async function loadSubjectData(subjectName) {
        const config = SubjectConfig[subjectName];
        if (!config) return;

        const statusDiv = document.getElementById('status');
        statusDiv.innerHTML = '<div class="flex items-center justify-center"><div class="loader mr-2"></div>Downloading Exam & Rationales...</div>';

        try {
            // A. Fetch and Process the MAIN EXAM PDF
            console.log(`Fetching Exam: ${config.exam}`);
const examResp = await fetch(config.exam + '?t=' + Date.now());
            if (!examResp.ok) throw new Error(`Exam file not found: ${config.exam}`);
            const examBuffer = await examResp.arrayBuffer();
            
            const subjectData = getCurrentSubjectData();
            subjectData.pdfDoc = await pdfjsLib.getDocument(examBuffer).promise;
            subjectData.teksToRcMap = await buildTeksToRcMap(subjectData.pdfDoc);
            subjectData.allQuestions = await parseAllPages();

            // B. Fetch and Process RATIONALES (Loop through the list)
            if (config.rationales && config.rationales.length > 0) {
                let totalMapped = 0;
                
                for (const ratConfig of config.rationales) {
                    console.log(`Fetching Rationale for ${ratConfig.year}...`);
                    try {
const ratResp = await fetch(ratConfig.file + '?t=' + Date.now());
                        if (ratResp.ok) {
                            const ratBuffer = await ratResp.arrayBuffer();
                            const ratDoc = await pdfjsLib.getDocument(ratBuffer).promise;
                            
                            // Extract text from all pages of the rationale PDF
                            let fullText = "";
                            for (let i = 1; i <= ratDoc.numPages; i++) {
                                const page = await ratDoc.getPage(i);
                                const textContent = await page.getTextContent();
                                fullText += textContent.items.map(item => item.str).join('\n') + "\n";
                            }

                            // Parse and Apply (Using the HARDCODED year)
                            const rationales = parseRationalesText(fullText);
                            rationales.forEach(rat => {
                                // Find question matching YEAR and NUMBER
                                const targetQ = subjectData.allQuestions.find(q => 
                                    q.year === ratConfig.year && 
                                    (q.id.endsWith(`-Q${rat.number}`) || q.id.endsWith(`-Q0${rat.number}`))
                                );
                                if (targetQ) {
                                    targetQ.rationaleMap = rat.rationaleMap;
                                    // Save page number for the "View Source" feature
                                    targetQ.rationalePage = 1; 
                                    // (Optimisation: We could map exact pages here if needed later)
                                    totalMapped++;
                                }
                            });
                        } else {
                            console.warn(`Rationale file missing: ${ratConfig.file}`);
                        }
                    } catch (e) {
                        console.error(`Error loading rationale for ${ratConfig.year}:`, e);
                    }
                }
                console.log(`Total Rationales Mapped: ${totalMapped}`);
            }

            // C. Finalize
            let statusMessage = `Loaded ${subjectData.allQuestions.length} questions from cloud.`;
            statusDiv.innerHTML = statusMessage;
            
            updateReviewAllButton();
            renderDashboard();
            populateCustomFilters();
            saveState();

        } catch (error) {
            console.error("Auto-load failed:", error);
            statusDiv.innerHTML = `<span class="text-red-600 font-bold">Error: ${error.message}</span>`;
        }
    }

    /**
     * UPDATED SWITCH SUBJECT
     */
    function switchSubject(subjectName) {
        AppState.currentSubject = subjectName;
        const fileInput = document.getElementById('pdf-upload');
        if(fileInput) fileInput.value = ''; 
        
        const subjectData = getCurrentSubjectData();
        // If empty, or if we have a config for this subject, try to load it
        if (subjectData.allQuestions.length === 0 && SubjectConfig[subjectName]) {
            loadSubjectData(subjectName);
        } else {
            renderAppForCurrentSubject();
        }
        saveState();
    }

    // --- INITIALIZATION ---
    loadState();
    
    const sDropdown = document.getElementById('subject-dropdown');
    if (sDropdown) {
        sDropdown.innerHTML = '';
        Object.keys(AppState.subjects).forEach(subjectName => {
            const option = document.createElement('option');
            option.value = subjectName;
            option.textContent = subjectName;
            if (subjectName === AppState.currentSubject) option.selected = true;
            sDropdown.appendChild(option);
        });
    }

    // Initial Trigger
    const currentData = getCurrentSubjectData();
    if (currentData.allQuestions.length === 0 && SubjectConfig[AppState.currentSubject]) {
        loadSubjectData(AppState.currentSubject);
    } else {
        renderAppForCurrentSubject();
    }

    // ==========================================
    // END AUTOMATION
    // ==========================================
    
 
function renderResultsScreen() {
    // 1. TRAFFIC COP: Switch the view
    try {
        const problemView = document.getElementById('problem-view');
        const resultsView = document.getElementById('results-view');
        const dashboardView = document.getElementById('dashboard-view'); // <--- NEW: Grab the dashboard
        const homeBtn = document.getElementById('home-btn');
        const appContent = document.getElementById('app-content');

        if (problemView) problemView.classList.add('hidden');
        if (dashboardView) dashboardView.classList.add('hidden'); // <--- NEW: Explicitly hide it!
        
        if (resultsView) {
            if (appContent) {
                appContent.prepend(resultsView);
            }
            resultsView.classList.remove('hidden');
        }
        
        if (homeBtn) homeBtn.classList.remove('hidden');
        
        window.scrollTo(0, 0);

    } catch (e) {
        console.error("View switching failed:", e);
    }

    // 2. THE ACCOUNTANT: Score Calculation & Grid Generation
    try {
        const pathway = AppState.currentPathway;
        const subjectData = getCurrentSubjectData();
        const mastery = subjectData.masteryState[pathway.teks] || {};
        
        let totalPointsEarned = 0;
        let totalPointsPossible = 0;

        // Calculate Scores
        pathway.questions.forEach((question, index) => {
            if (!question) return;

            const pointsPossible = getQuestionPointsPossible(question);
            totalPointsPossible += pointsPossible;

            const status = mastery[index];
            let points = 0;

            if (typeof status === 'number') {
                points = status;
            } else if (status === 'correct') {
                points = pointsPossible;
            }
            totalPointsEarned += points;
        });

        // Update UI (Score Banner)
        const percentage = totalPointsPossible === 0 ? 0 : Math.round((totalPointsEarned / totalPointsPossible) * 100);
        const targets = AppState.difficultySettings.targets;
        let statusLabel = "Did Not Meet Grade Level";
        let statusColor = "text-red-600";

        if (percentage >= targets.masters) {
            statusLabel = "Masters Grade Level";
            statusColor = "text-purple-600";
        } else if (percentage >= targets.meets) {
            statusLabel = "Meets Grade Level";
            statusColor = "text-blue-600";
        } else if (percentage >= targets.approaches) {
            statusLabel = "Approaches Grade Level";
            statusColor = "text-green-600";
        }

        const resultsSummary = document.getElementById('results-summary');
        if (resultsSummary) {
            const endTime = new Date();
            const timeTaken = Math.round((endTime - pathway.startTime) / 1000);
            
            resultsSummary.innerHTML = `
                <div class="text-center mb-8 p-6 bg-gray-50 rounded-xl border border-gray-200">
                    <div class="text-3xl sm:text-4xl font-extrabold ${statusColor} mb-2 tracking-tight">${statusLabel}</div>
                    <div class="text-xl text-gray-700">
                        Score: <span class="font-bold text-gray-900">${totalPointsEarned.toFixed(1)} / ${totalPointsPossible}</span> 
                        <span class="text-gray-500 ml-1">(${percentage}%)</span>
                    </div>
                    ${pathway.timerSettings ? `<div class="text-sm text-gray-500 mt-2 font-mono">Time: ${Math.floor(timeTaken / 60)}m ${timeTaken % 60}s</div>` : ''}
                </div>
            `;
        }

        // 3. IDENTIFY MISSED QUESTIONS
        const missedQuestions = pathway.questions.filter((q, index) => {
            if (!q) return false;
            const status = mastery[index];
            const pointsPossible = getQuestionPointsPossible(q);
            
            if (status === 'correct') return false; 
            if (status === pointsPossible) return false; 

            return true;
        });

        renderMissedQuestionsGrid(missedQuestions);

    } catch (error) {
        console.error("CRASH IN RESULTS CALCULATION:", error);
    }
}
        };
    </script>
</body>
</html>


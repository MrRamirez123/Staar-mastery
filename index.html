<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>STAAR Mastery Pathway</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
   body { 
    font-family: 'Inter', sans-serif; 
    background-color: #f4ecd8; /* Parchment Background */
    color: #44332a; /* Deep Sepia Ink */
}
.review-item {
    /* This creates the two-column grid: left for canvas, right for controls */
    display: grid;
    grid-template-columns: repeat(1, minmax(0, 1fr)); /* Default to single column on small screens */
    gap: 1.5rem; /* 24px */
    border-top-width: 1px;
    padding-top: 1.5rem;
    align-items: start; 
}


@media (min-width: 768px) {
    .review-item {
        grid-template-columns: repeat(2, minmax(0, 1fr));
    }
}
.zoom-controls {
    position: absolute;
    top: 0.5rem; /* 8px */
    right: 0.5rem; /* 8px */
    z-index: 10;
    display: flex;
    gap: 0.5rem; /* 8px */
}
.review-canvas {
    width: 100%;
    height: auto;
    border: 1px solid #e5e7eb; /* Optional: adds a nice border */
    border-radius: 0.375rem;   /* Optional: rounds the corners */
}

.review-item .bg-gray-50 {
    /* Styles for the right-hand control panel inside the modal */
    background-color: #f9fafb; /* gray-50 */
    padding: 1rem;
    border-radius: 0.5rem;
    display: flex;
    flex-direction: column;
    gap: 1rem; /* Creates space between the tools */
}

#problem-view-grid {
    display: grid;
    grid-template-columns: repeat(1, minmax(0, 1fr)); /* Single column on small screens */
    gap: 1.5rem; /* 24px */
}

@media (min-width: 768px) { /* This is the 'md' breakpoint in Tailwind */
    #problem-view-grid {
        grid-template-columns: repeat(2, minmax(0, 1fr)); /* Two equal columns on large screens */
    }
}

#passage-container {
    background-color: #fff9f0;
    padding: 0.5rem;
    border-radius: 0.5rem;
    border: 1px solid #dcd3c5;
    max-height: 85vh; /* Makes the passage scrollable on its own */
    overflow-y: auto;
    position: sticky; /* Makes it "sticky" */
    top: 1rem; /* Adjust as needed */
}

#passage-container canvas {
    width: 100%;
    height: auto;
}

#question-container {
    background-color: #fff9f0 ;
    padding: 1.5rem; /* 24px */
    border-radius: 0.5rem;
    border: 1px solid #dcd3c5;
}

.layout-editor-active { cursor: crosshair; }
.layout-editor-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; }
.drawn-box { position: absolute; background-color: rgba(59, 130, 246, 0.4); border: 2px solid #2563eb; border-radius: 0.25rem; cursor: move; }
.drawn-box:hover .delete-btn { display: flex; }
.delete-btn { display: none; position: absolute; top: -10px; right: -10px; width: 20px; height: 20px; background-color: #ef4444; color: white; border-radius: 50%; align-items: center; justify-content: center; cursor: pointer; font-size: 12px; font-weight: bold; }
.selection-box { position: absolute; border: 2px dashed #10b981; background-color: rgba(167, 243, 208, 0.4); pointer-events: none; }
.crop-box-overlay { position: absolute; border: 2px dashed #f59e0b; background-color: rgba(245, 158, 11, 0.2); pointer-events: none; }
.key-drop-zone { border: 2px dashed #d1d5db; border-radius: 0.5rem; padding: 0.5rem; min-height: 3.5rem; display: flex; flex-direction: column; align-items: center; justify-content: center; background-color: #f9fafb; transition: background-color 0.2s ease; flex: 1; min-width: 100px; }
.key-drop-zone.dragover { background-color: #eef2ff; }
.drag-item { cursor: grab; padding: 0.5rem 1rem; border: 1px solid #d1d5db; background-color: white; border-radius: 0.5rem; box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05); transition: all 0.2s ease-in-out; touch-action: none; }
.drag-item:active { cursor: grabbing; }
.drag-item.dragged { opacity: 0.4; }
.drag-item.invisible { display: none; }
.touch-drag-ghost { position: fixed; pointer-events: none; z-index: 1000; transform: translate(-50%, -50%); }
.drop-zone { position: absolute; border: 2px dashed #4f46e5; border-radius: 0.5rem; background-color: rgba(239, 246, 255, 0.5); display: flex; align-items: center; justify-content: center; }
.drop-zone.dragover { background-color: rgba(191, 219, 254, 0.7); }
.drop-zone .drag-item { font-size: 0.875rem; padding: 0.25rem 0.5rem;}
    /* --- HEADER --- */
    .main-header {
        background: linear-gradient(90deg, #4f46e5, #7c3aed); /* Modern Indigo/Violet Gradient */
        color: white;
        padding: 1rem 1.5rem;
        border-radius: 0.75rem;
        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    .main-header p { color: #d1d5db; }

    /* --- PANELS & CARDS --- */
    .control-panel > div,
    #dashboard-content,
    .pathway-card {
        background-color: #fff9f0;
        border: 1px solid #dcd3c5;
    }
    <div class="mb-4">
    <label for="pdf-upload" class="block text-lg font-medium text-gray-700 mb-2">1. Upload Exam PDF</label>
    <input type="file" id="pdf-upload" accept=".pdf" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100"/>
</div>

<div class="mb-4 p-4 bg-purple-50 rounded-lg border border-purple-200">
    <label for="rationale-upload" class="block text-lg font-medium text-purple-900 mb-2">2. Upload Rationales PDF</label>
    <p class="text-xs text-purple-700 mb-2">Upload the "Item Rationales" file to auto-fill explanations and correct answers.</p>
    <input type="file" id="rationale-upload" accept=".pdf" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-purple-100 file:text-purple-700 hover:file:bg-purple-200"/>
</div>
    .pathway-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
    }
    .teks-title { color: #1e3a8a; font-weight: 700; }
    .pathway-card .reset-pathway-btn { color: #ef4444; }
    
    /* --- BUTTONS --- */
    .practice-pathway-btn { background-color: #4f46e5; color: white; }
    .practice-pathway-btn:hover { background-color: #4338ca; }
    
    .start-quiz-btn { background-color: white; color: #4f46e5; border: 1px solid #4f46e5; }
    .start-quiz-btn:hover { background-color: #eef2ff; }
    
    .review-btn { background-color: #f3f4f6; color: #4b5563; border: 1px solid #d1d5db; }
    .review-btn:hover { background-color: #e5e7eb; }

    #review-all-btn { background-color: #f59e0b; color: white; }
    #review-all-btn:hover { background-color: #d97706; }
.print-btn { background-color: #059669; color: white; }
    .print-btn:hover { background-color: #047857; }
    
    .print-modal-loader {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background-color: rgba(255, 255, 255, 0.8);
        z-index: 10;
    }
    /* --- FORM ELEMENTS --- */
    .control-panel h2 { color: #44332a; }
    .control-panel label { color: #4b5563; }
    .control-panel input[type="file"] { color: #4b5563; }
    .control-panel input[type="file"]::file-selector-button { background-color: #eef2ff; color: #4338ca; }
    #subject-dropdown { background-color: white; color: #1f2937; border-color: #d1d5db; }
    .control-panel .select-all-btn { color: #4f46e5; }
    .control-panel .filter-group { border-color: #e5e7eb; }
    .control-panel .filter-group span { color: #374151; }

    /* --- ALL OTHER STYLES (UNCHANGED) --- */
    .icon-btn { display: inline-flex; align-items: center; justify-content: center; gap: 0.5rem; }
    .student-view-bg { background-color:#e5e7eb; background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='80' height='80' viewBox='0 0 80 80'%3E%3Cg fill='%23e5e7eb' fill-opacity='0.4'%3E%3Cpath fill-rule='evenodd' d='M11 0l5 20H6l5-20zm42 31a3 3 0 100-6 3 3 0 000 6zM0 72h40v4H0v-4zm0-8h31.05a15.993 15.993 0 00-30.05 8H0v-4zm20-4h20v4H20v-4zm0-8h20v4H20v-4zm0-8h20v4H20v-4zm0-8h20v4H20v-4zm-20 0h20v4H0v-4zm0 8h20v4H0v-4zm0 8h20v4H0v-4zm0 8h20v4H0v-4z'/%3E%3C/g%3E%3C/svg%3E"); }
    .question-grid { display: flex; flex-wrap: wrap; gap: 4px; margin-top: 8px; }
    .question-box { width: 20px; height: 20px; border-radius: 4px; border: 1px solid rgba(0,0,0,0.1); transition: transform 0.2s ease, box-shadow 0.2s ease; cursor: pointer; }
    .question-box:hover { transform: scale(1.2); box-shadow: 0 0 5px rgba(0,0,0,0.3); }
    .status-box { width: 1.5rem; height: 1.5rem; border-radius: 0.375rem; margin: 0.125rem; transition: all 0.3s ease; position: relative; border: 1px solid rgba(0,0,0,0.1); transform-style: preserve-3d; perspective: 1000px; }
    .clickable-status-box { cursor: pointer; }
    .clickable-status-box:hover { transform: scale(1.1); }
    .clickable-status-box.current { box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.7); border-color: #3b82f6; }
    .status-not-started { background-color: #e5e7eb; }
    .status-correct { background-color: #10b981; }
    .status-incorrect { background-color: #ef4444; }
    .status-partial { background-color: #f59e0b; }
    .status-flagged::after { content: '‚öë'; position: absolute; top: -5px; right: -5px; color: #db2777; font-size: 14px; font-weight: bold; }
    .status-box.flipping { animation: flip 0.6s ease-in-out forwards; }
    .status-box-face { position: absolute; width: 100%; height: 100%; border-radius: 0.375rem; backface-visibility: hidden; }
    .status-box-back { transform: rotateY(180deg); }
    @keyframes flip { from { transform: rotateY(0deg); } to { transform: rotateY(180deg); } }
.scalable-content {
    position: relative;
    transform-origin: top left;
    transition: transform 0.2s ease;
}

/* --- PAPER MODE THEME ENGINE --- */
:root {
    /* Default Fallback */
    --theme-gradient: linear-gradient(90deg, #5d4037, #8d6e63); /* Leather Brown */
    --theme-bg: #f4ecd8; /* Parchment */
    --theme-pattern: none; /* Will be filled by JS */
    --theme-primary: #8d6e63;
    --theme-hover: #5d4037;
}

body {
    font-family: 'Inter', sans-serif;
    
    /* 1. Base Parchment Color */
    background-color: #f4ecd8 !important; 
    
    /* 2. The Pattern Variable (filled by JS) */
    background-image: var(--theme-pattern);
    
    /* 3. Wallpaper Settings */
    background-repeat: repeat;
    background-size: 300px; /* Adjust size of symbols here */
    background-attachment: fixed; 
    background-blend-mode: multiply; /* Blends ink into paper */
    
    color: #44332a; /* Deep Sepia Text */
    transition: background-image 0.5s ease-in-out;
}

/* --- OVERRIDE WHITE CONTAINERS TO IVORY --- */
.pathway-card, 
.control-panel > div, 
#dashboard-content, 
#question-container, 
#passage-container,
.bg-white {
    background-color: #fff9f0 !important; /* Ivory Paper */
    border-color: #dcd3c5 !important; /* Tan Border */
    color: #44332a;
}

.main-header {
    /* The header now listens to the theme variable */
    background: var(--theme-gradient) !important;
    padding: 1rem 1.5rem;
    border-radius: 0.75rem;
    box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
    display: flex;
    justify-content: space-between;
    align-items: center;
    transition: background 0.8s ease-in-out;
}

/* These specific buttons will now morph colors */
#generate-pathway-btn, 
.practice-pathway-btn, 
#submit-mc-btn, 
#submit-hotspot-btn, 
#submit-graph-btn,
.theme-btn {
    background-color: var(--theme-primary) !important;
    transition: background-color 0.3s ease;
}

#generate-pathway-btn:hover, 
.practice-pathway-btn:hover, 
#submit-mc-btn:hover, 
#submit-hotspot-btn:hover, 
#submit-graph-btn:hover,
.theme-btn:hover {
    background-color: var(--theme-hover) !important;
}

/* Confetti Shapes */
.confetti-star {
    clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%);
}
.confetti-triangle {
    clip-path: polygon(50% 0%, 0% 100%, 100% 100%);
}


    .pathway-card {
        background-color: #fff9f0;
        border-radius: 0.75rem;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        transition: box-shadow 0.3s ease-in-out, transform 0.3s ease-in-out;
    }
    .pathway-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
    }

    .teks-title {
        color: #1e3a8a;
        font-weight: 700;
    }

    .icon-btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 0.5rem;
    }

    .student-view-bg {
         background-color: #e5e7eb;
         background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='80' height='80' viewBox='0 0 80 80'%3E%3Cg fill='%23e5e7eb' fill-opacity='0.4'%3E%3Cpath fill-rule='evenodd' d='M11 0l5 20H6l5-20zm42 31a3 3 0 100-6 3 3 0 000 6zM0 72h40v4H0v-4zm0-8h31.05a15.993 15.993 0 00-30.05 8H0v-4zm20-4h20v4H20v-4zm0-8h20v4H20v-4zm0-8h20v4H20v-4zm0-8h20v4H20v-4zm-20 0h20v4H0v-4zm0 8h20v4H0v-4zm0 8h20v4H0v-4zm0 8h20v4H0v-4z'/%3E%3C/g%3E%3C/svg%3E");
    }
    
    .content-transition {
        transition: opacity 0.3s ease-in-out;
    }
    .fade-out { opacity: 0; }
    .fade-in { opacity: 1; }

    #confetti-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 9999;
        overflow: hidden;
    }

    .confetti {
        position: absolute;
        width: 16px;
        height: 32px;
        background-color: #facc15;
        opacity: 0;
        animation: confetti-fall 3.5s ease-out forwards;
    }

    @keyframes confetti-fall {
        0% {
            transform: translateY(-100vh) rotate(0deg);
            opacity: 1;
        }
        100% {
            transform: translateY(100vh) rotate(720deg);
            opacity: 0;
        }
    }

    .canvas-container {
        width: 100%;
        max-width: 800px;
        overflow: auto;
        border-radius: 0.5rem;
        position: relative;
    }
    .scalable-content {
        position: relative;
        transform-origin: top left;
        transition: transform 0.2s ease;
    }
    #problem-canvas, .review-canvas, #graphing-canvas {
        display: block;
        width: 100%;
        height: auto;
        border: 1px solid #e2e8f0;
        border-radius: 0.5rem;
        image-rendering: -moz-crisp-edges;
        image-rendering: -webkit-crisp-edges;
        image-rendering: pixelated;
        image-rendering: crisp-edges;
    }
    .status-box {
        width: 1.5rem; height: 1.5rem; border-radius: 0.375rem;
        margin: 0.125rem; transition: all 0.3s ease;
        position: relative;
        border: 1px solid rgba(0,0,0,0.1);
    }
    .clickable-status-box {
        cursor: pointer;
    }
    .clickable-status-box:hover {
        transform: scale(1.1);
    }
    .clickable-status-box.current {
        box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.7);
        border-color: #3b82f6;
    }
    .status-not-started { background-color: #e5e7eb; }
    .status-correct { background-color: #10b981; }
    .status-incorrect { background-color: #ef4444; }
    .status-partial { background-color: #f59e0b; }
    .status-flagged::after {
        content: '‚öë';
        position: absolute;
        top: -5px;
        right: -5px;
        color: #db2777;
        font-size: 14px;
        font-weight: bold;
    }
    #review-modal { transition: opacity 0.3s ease-in-out; }
    .loader {
        border: 4px solid #f3f3f3;
        border-radius: 50%;
        border-top: 4px solid #4f46e5;
        width: 24px;
        height: 24px;
        animation: spin 1s linear infinite;
    }
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
    
    .answer-button {
        transition: all 0.2s ease-in-out;
        background: #f3f4f6;
        border: 1px solid #d1d5db;
    }
    .answer-button:not(.disabled):hover {
        transform: scale(1.03);
        box-shadow: 0 4px 14px 0 rgba(0, 0, 0, 0.1);
        border-color: #9ca3af;
    }
    .answer-button.correct { 
        background: linear-gradient(45deg, #10b981, #6ee7b7);
        color: white !important; 
        animation: glow 1s ease-in-out;
        border-color: #059669;
    }
    .answer-button.incorrect { 
        background: linear-gradient(45deg, #ef4444, #f87171);
        color: white !important; 
        animation: shake 0.5s ease-in-out;
        border-color: #b91c1c;
    }
    .answer-button.selected { 
        background: linear-gradient(45deg, #3b82f6, #60a5fa);
        color: white;
        border-color: #1d4ed8;
        box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.4);
    }
    .answer-button.disabled, .disabled { 
        background-color: #d1d5db; 
        cursor: not-allowed; 
        opacity: 0.7; 
    }

    #feedback-message.animate-fade-in-scale {
        animation: fade-in-scale 0.4s ease-out forwards;
    }

    @keyframes shake {
        0%, 100% { transform: translateX(0); }
        25% { transform: translateX(-5px); }
        75% { transform: translateX(5px); }
    }

    @keyframes glow {
        0%, 100% { box-shadow: 0 0 5px #10b981; }
        50% { box-shadow: 0 0 20px #10b981; }
    }

    @keyframes fade-in-scale {
        from { opacity: 0; transform: scale(0.9); }
        to { opacity: 1; transform: scale(1); }
    }
    
    .hotspot-click-marker {
        position: absolute;
        width: 15px;
        height: 15px;
        border-radius: 50%;
        background-color: #3b82f6;
        border: 2px solid white;
        transform: translate(-50%, -50%);
        pointer-events: none;
        box-shadow: 0 0 5px rgba(0,0,0,0.5);
    }
    .hotspot-answer-reveal {
        position: absolute;
        background-color: rgba(16, 185, 129, 0.4);
        border: 2px solid #059669;
        border-radius: 0.25rem;
        pointer-events: none;
    }
    
    #graphing-canvas { cursor: crosshair; background-color: #fff; }
   .graph-type-selector { display: flex; justify-content: center; gap: 0.5rem; margin-bottom: 1rem; }
    .graph-type-btn { padding: 0.5rem 1rem; border: 1px solid #d1d5db; background-color: #f9fafb; border-radius: 0.375rem; font-weight: 500; cursor: pointer; transition: all 0.2s ease; }
    .graph-type-btn.active { background-color: #4f46e5; color: white; border-color: #4f46e5; }
    .graph-type-btn:disabled { background-color: #e5e7eb; cursor: not-allowed; color: #9ca3af; }
    .inline-choice-select {
        display: inline-block;
        width: auto;
        padding: 0.25rem 1.5rem 0.25rem 0.5rem;
        margin: 0 0.25rem;
        border: 1px solid #d1d5db;
        border-radius: 0.375rem;
        background-color: white;
        -webkit-appearance: none;
        -moz-appearance: none;
        appearance: none;
        background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
        background-position: right 0.5rem center;
        background-repeat: no-repeat;
        background-size: 1.5em 1.5em;
    }
    .filter-group { max-height: 150px; overflow-y: auto; border: 1px solid #e5e7eb; padding: 0.5rem; border-radius: 0.5rem; }
    details > summary { 
        cursor: pointer; 
        font-weight: 600; 
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0.5rem;
        list-style: none; /* Hide default marker */
    }
    details > summary::-webkit-details-marker {
        display: none; /* Hide default marker for Chrome/Safari */
    }
    details > summary::before {
        content: '‚ñº';
        margin-right: 0.5rem;
        font-size: 0.6em;
        transition: transform 0.2s;
    }
    details[open] > summary::before {
        transform: rotate(180deg);
    }
    details { padding-left: 1rem; margin-bottom: 0.5rem; }
    #subject-dropdown {
        width: 100%;
        padding: 0.5rem;
        border-radius: 0.375rem;
        border: 1px solid #d1d5db;
        background-color: white;
        margin-bottom: 1rem;
    }
</style>
</head>
<body class="bg-gray-100">
    <div id="confetti-container"></div>
    <div class="container mx-auto p-4 sm:p-6 lg:p-8">
      <header class="main-header mb-8 flex flex-col md:flex-row items-center justify-between gap-4">
    <div class="text-left">
        <h1 class="text-3xl sm:text-4xl font-bold text-white">STAAR Mastery Pathway</h1>
        <p class="text-md text-blue-200 mt-1">Upload, Analyze, and Assign Targeted Pathways.</p>
    </div>
    
    <div class="flex items-center gap-4">
        <div class="bg-white/10 p-2 rounded-lg backdrop-blur-sm border border-white/20">
            <select id="subject-dropdown" class="bg-transparent text-white font-semibold focus:outline-none cursor-pointer">
                </select>
        </div>

        <button id="home-btn" class="hidden px-4 py-2 bg-white text-blue-700 font-semibold rounded-md hover:bg-blue-50 shadow-sm">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-house-door-fill inline-block mr-2" viewBox="0 0 16 16"><path d="M6.5 14.5v-3.505c0-.245.25-.495.5-.495h2c.25 0 .5.25.5.5v3.5a.5.5 0 0 0 .5.5h4a.5.5 0 0 0 .5-.5v-7a.5.5 0 0 0-.146-.354L13 5.793V2.5a.5.5 0 0 0-.5-.5h-1a.5.5 0 0 0-.5.5v1.293L8.354 1.146a.5.5 0 0 0-.708 0l-6 6A.5.5 0 0 0 1.5 7.5v7a.5.5 0 0 0 .5.5h4a.5.5 0 0 0 .5-.5z"/></svg>
            Home
        </button>
    </div>
</header>
        <!-- Main Content Area -->
        <div id="app-content">
            <!-- Dashboard / Teacher View -->
           <div id="dashboard-view">
 <div class="grid grid-cols-1 lg:grid-cols-12 gap-8 items-start">
    
    <div id="dashboard-sidebar" class="lg:col-span-4 space-y-6 h-fit">
        
        <div class="bg-white p-5 rounded-lg shadow border border-gray-200">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-lg font-bold text-gray-800">Quick Actions</h2>
                <div id="status" class="text-xs text-gray-500 font-medium"></div>
            </div>

            <div id="review-all-container" class="hidden mb-4">
                <button id="review-all-btn" class="w-full px-4 py-3 bg-yellow-100 text-yellow-800 border border-yellow-300 font-bold rounded-md hover:bg-yellow-200 transition-all flex items-center justify-center gap-2">
                    <span>‚ö†Ô∏è</span> Review Questions
                </button>
            </div>
<div id="review-all-container" class="hidden mb-4">
    <button id="review-all-btn" class="...">...</button>
</div>

<div class="mb-4">
    <button id="diagnostic-btn" class="w-full px-4 py-3 bg-indigo-100 text-indigo-800 border border-indigo-300 font-bold rounded-md hover:bg-indigo-200 transition-all flex items-center justify-center gap-2">
        <span>ü©∫</span> Run Diagnostic Test
    </button>
</div>
<div class="mb-4">
    <button id="view-history-btn" class="w-full px-4 py-3 bg-gray-100 text-gray-700 border border-gray-300 font-bold rounded-md hover:bg-gray-200 transition-all flex items-center justify-center gap-2">
        <span>üìú</span> View Student History
    </button>
</div>
            <div>
                <label for="pathway-sort-dropdown" class="block text-xs font-bold text-gray-500 uppercase tracking-wide mb-1">Sort Questions By</label>
                <select id="pathway-sort-dropdown" class="w-full p-2 border rounded border-gray-300 text-sm focus:ring-indigo-500 focus:border-indigo-500">
                    <option value="logical">Logical (Year Newest ‚Üí Q#)</option>
                    <option value="numerical">Numerical (Q# ‚Üí Year)</option>
                    <option value="random">Random Shuffle</option>
                </select>
            </div>
        </div>

        <details id="custom-pathway-builder" class="bg-white rounded-lg shadow border border-gray-200 group hidden">
            <summary class="list-none p-5 cursor-pointer font-bold text-gray-800 flex justify-between items-center hover:bg-gray-50 rounded-t-lg">
                <span>‚ö° Custom Pathway Generator</span>
                <span class="transition group-open:rotate-180">‚ñº</span>
            </summary>
            <div class="p-5 border-t border-gray-200">
                <p class="text-sm text-gray-600 mb-4">Select filters below to build a unique practice set.</p>
                <div id="filter-container" class="space-y-4"></div>
                <button id="generate-pathway-btn" class="w-full mt-4 px-4 py-2 bg-indigo-600 text-white font-semibold rounded-md hover:bg-indigo-700 shadow-sm transition-all">
                    Generate Pathway
                </button>
            </div>
        </details>

    </div> 
    
            
            <div id="pathway-display"></div>
            
            <div id="placeholder-view" class="flex flex-col items-center justify-center h-64 text-gray-400">
                <svg class="w-16 h-16 mb-4 opacity-50" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10"></path></svg>
                <p class="text-lg font-medium">Select a subject above to begin</p>
            </div>
        </div>
    </div>
</div>
            <!-- Problem / Student View -->
         <div id="problem-view" class="hidden student-view-bg content-transition">
                <div class="w-full p-4 bg-white rounded-lg shadow-md border border-gray-200 mb-4">
                    <div class="flex justify-between items-center">
                        <div id="progress-indicator" class="font-semibold text-gray-700"></div>
                        <div id="timer-display" class="font-bold text-xl text-blue-600"></div>
                        <div class="flex items-center space-x-4">
                            <button id="edit-question-btn" title="Review and Edit this Question" class="px-3 py-1 bg-purple-100 text-purple-700 text-sm rounded-full hover:bg-purple-200">‚úé Edit</button>
                            <button id="flag-question-btn" ...>‚öë Flag</button>
                            <button id="toggle-teks-btn" ...>Show Standard</button>
                        </div>
                    </div>
                    <div id="clickable-progress-bar" class="flex flex-wrap items-center justify-center p-2 bg-gray-100 rounded-lg mt-4"></div>
                    <div id="teks-context" class="w-full p-3 mt-4 bg-gray-50 rounded-md border border-gray-200 hidden">
                        <p class="font-semibold" id="teks-context-new"></p>
                        <p class="text-sm italic text-gray-600" id="teks-context-old"></p>
                    </div>
                </div>

                <div id="problem-view-grid">
                  <div id="passage-container">
                        <div class="zoom-controls">
                            <button id="passage-zoom-in-btn" class="px-2 py-1 bg-gray-200 rounded-md">+</button>
                            <button id="passage-zoom-out-btn" class="px-2 py-1 bg-gray-200 rounded-md">-</button>
                        </div>
                        <div id="passage-content-wrapper">
                        
                    </div>
                    </div>

                    <div id="question-container">
                        <div class="canvas-container mx-auto relative">
                            <div class="zoom-controls">
                                <button id="zoom-in-btn" class="px-2 py-1 bg-gray-200 rounded-md">+</button>
                                <button id="zoom-out-btn" class="px-2 py-1 bg-gray-200 rounded-md">-</button>
                            </div>
                            <div id="scalable-content" class="scalable-content">
                                </div>
                        </div>
                        <div id="feedback-message" class="mt-4 text-center text-lg font-bold"></div>
                        <div id="correct-answer-container" class="mt-4 p-4 bg-green-50 border-l-4 border-green-300 rounded-r-lg hidden">
                            <div id="correct-answer-display" class="text-sm font-bold text-green-800"></div>
                        </div>
                        <div id="explanation-box" class="mt-2 p-4 bg-gray-50 border-l-4 border-gray-300 rounded-r-lg hidden">
                            <h4 class="font-bold text-gray-800">Analysis & Explanation</h4>
                            <p id="explanation-text" class="text-sm text-gray-700 mt-1"></p>
                        </div>
                        <div id="answer-interface" class="mt-4 w-full"></div>
                        <div id="navigation-controls" class="w-full flex justify-between items-center mt-6 space-x-2">
                            <button id="previous-problem-btn" class="px-4 py-2 bg-gray-500 text-white rounded-md hover:bg-gray-600">Previous</button>
                            <div id="quiz-nav-center" class="flex-grow flex justify-center">
                                <button id="skip-problem-btn" class="px-4 py-2 bg-gray-500 text-white rounded-md hover:bg-gray-600 hidden">Skip for Now</button>
                            </div>
                            <button id="retry-problem-btn" class="px-4 py-2 bg-yellow-500 text-white rounded-md hover:bg-yellow-600 hidden">Retry Problem</button>
                            <button id="back-to-dashboard-btn" class="px-4 py-2 bg-gray-500 text-white rounded-md hover:bg-gray-600">Back to Pathway</button>
                            <button id="next-problem-btn" class="px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700">Next</button>
                        </div>
                    </div>
                
            </div>
            
            <!-- Results View -->
            <div id="results-view" class="hidden">
                <div class="w-full bg-white p-6 rounded-lg shadow-lg border border-gray-200">
                    <div id="results-header">
                        <h2 id="results-title" class="text-3xl font-bold text-gray-800 mb-2"></h2>
                        <p id="results-summary" class="text-lg text-gray-600 mb-6"></p>
                    </div>
                    <div id="missed-questions-container" class="mb-6">
                        <h3 class="text-xl font-semibold mb-4 border-b pb-2">Questions for Review</h3>
                        <div id="missed-questions-grid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4"></div>
                    </div>
                    <div id="results-analysis-container" class="space-y-4"></div>
                    <div class="w-full flex justify-end items-center mt-8 space-x-4">
                         <button id="print-results-btn" class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700">Print Results</button>
                         <button id="download-results-btn" class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700">Download Results</button>
                         <button id="results-back-btn" class="px-4 py-2 bg-gray-500 text-white rounded-md hover:bg-gray-600">Back to Dashboard</button>
                    </div>
                </div>
            </div>

        </div>

        <!-- Review Modal -->
        <div id="review-modal" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center p-4 hidden z-50">
            <div class="bg-white rounded-lg shadow-xl w-full max-w-6xl max-h-[90vh] overflow-y-auto p-6">
                <div class="flex justify-between items-center border-b pb-3 mb-4 sticky top-0 bg-white z-10">
                    <h2 id="review-modal-title" class="text-2xl font-bold">Review Questions</h2>
                    <div class="flex items-center space-x-4">
                        <button id="filter-review-btn" class="px-4 py-2 bg-yellow-400 text-yellow-800 text-sm font-semibold rounded-md hover:bg-yellow-500">Show Only Questions Needing Review</button>
                        <button id="close-review-modal-btn" class="text-3xl font-bold text-gray-500 hover:text-gray-800">&times;</button>
                    </div>
                </div>
                <div id="review-modal-content" class="space-y-8"></div>
            </div>
        </div>

        <!-- Quiz Setup Modal -->
        <div id="quiz-setup-modal" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center p-4 hidden z-50">
            <div class="bg-white rounded-lg shadow-xl w-full max-w-md p-6">
                <h2 class="text-2xl font-bold mb-4">Quiz Setup</h2>
                <div class="space-y-4">
                    <div class="flex items-center justify-between">
                        <label for="enable-timer-toggle" class="font-medium text-gray-700">Enable Timer?</label>
                        <input type="checkbox" id="enable-timer-toggle" class="h-6 w-11 rounded-full bg-gray-300 relative inline-flex items-center cursor-pointer transition-colors duration-300 ease-in-out focus:outline-none" />
                    </div>
                    <div id="timer-options" class="hidden">
                        <label for="time-per-question" class="block text-sm font-medium text-gray-700">Time per question (minutes)</label>
                        <input type="number" id="time-per-question" value="2" min="1" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm">
                    </div>
                </div>
                <div class="mt-6 flex justify-end space-x-4">
                    <button id="cancel-quiz-btn" class="px-4 py-2 bg-gray-200 text-gray-700 rounded-md hover:bg-gray-300">Cancel</button>
                    <button id="begin-quiz-btn" class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700">Begin Quiz</button>
                </div>
            </div>
        </div>
    </div>
<div id="print-options-modal" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center p-4 hidden z-50">
    <div class="bg-white rounded-lg shadow-xl w-full max-w-md p-6 relative">
        <div id="print-modal-loader" class="print-modal-loader hidden">
            <div class="loader"></div>
        </div>
        
        <h2 class="text-2xl font-bold mb-4">Print Options</h2>
        <div class="space-y-4">
            <div class="flex items-center justify-between">
                <label for="include-answers-toggle" class="font-medium text-gray-700">Include Answer Key?</label>
                <input type="checkbox" id="include-answers-toggle" class="h-6 w-11 rounded-full bg-gray-300 relative inline-flex items-center cursor-pointer transition-colors duration-300 ease-in-out focus:outline-none" />
            </div>
            
            <div class="flex items-center justify-between">
                <label for="include-rationales-toggle" class="font-medium text-gray-700">Include Item Rationales?</label>
                <input type="checkbox" id="include-rationales-toggle" class="h-6 w-11 rounded-full bg-gray-300 relative inline-flex items-center cursor-pointer transition-colors duration-300 ease-in-out focus:outline-none" />
            </div>
        </div>

        <div class="mt-6 flex justify-end space-x-4">
            <button id="cancel-print-btn" class="px-4 py-2 bg-gray-200 text-gray-700 rounded-md hover:bg-gray-300">Cancel</button>
            <button id="generate-print-btn" class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700">Generate Printable</button>
        </div>
    </div>
</div>
<div id="global-loader" class="fixed inset-0 bg-indigo-900 bg-opacity-90 z-[9999] hidden flex flex-col items-center justify-center transition-opacity duration-300 backdrop-blur-sm">
    
    <div class="relative max-w-md w-full px-6">
        <div class="bg-white rounded-2xl p-6 shadow-2xl border-4 border-indigo-200 relative">
            <div class="absolute -bottom-4 left-1/2 transform -translate-x-1/2 w-8 h-8 bg-white border-b-4 border-r-4 border-indigo-200 rotate-45"></div>
            
            <h3 class="text-indigo-600 font-bold uppercase tracking-wider text-xs mb-2">‚ú® Ms. STAARworking...</h3>
            <p id="global-loader-text" class="text-xl font-bold text-gray-800 text-center">
                "Hold on, I'm analyzing your test data!"
            </p>
        </div>

        <div class="flex justify-center mt-8">
            <div class="w-24 h-24 bg-white rounded-full border-4 border-indigo-500 shadow-xl flex items-center justify-center text-6xl relative z-10 animate-bounce">
                üë©‚Äçüè´
            </div>
        </div>
    </div>

    <div class="mt-8 w-64 h-3 bg-indigo-900 rounded-full overflow-hidden border border-indigo-700">
        <div class="h-full bg-indigo-400 animate-pulse w-full origin-left transform scale-x-50"></div>
    </div>

</div>
    <script>
        /**
 * Displays the "Welcome Wizard" to guide the user on startup.
 * Features: Teacher Guide, Subject Selection (Background Load), and View Selection.
 */
function showWelcomeModal() {
    // 1. Remove any existing welcome modal
    const existing = document.getElementById('welcome-modal');
    if (existing) existing.remove();

    // 2. Create the Modal Structure
    const modalHtml = `
    <div id="welcome-modal" class="fixed inset-0 bg-slate-900 z-[100] flex items-center justify-center p-4 transition-opacity duration-500">
        <div class="absolute inset-0 overflow-hidden pointer-events-none">
            <div class="absolute -top-24 -left-24 w-96 h-96 bg-indigo-500 rounded-full mix-blend-multiply filter blur-3xl opacity-20 animate-blob"></div>
            <div class="absolute -bottom-24 -right-24 w-96 h-96 bg-purple-500 rounded-full mix-blend-multiply filter blur-3xl opacity-20 animate-blob animation-delay-2000"></div>
        </div>

        <div class="bg-white w-full max-w-5xl rounded-2xl shadow-2xl overflow-hidden flex flex-col md:flex-row relative z-10 min-h-[500px]">
            
            <div class="w-full md:w-1/3 bg-indigo-50 p-8 flex flex-col items-center justify-center text-center border-r border-indigo-100 relative">
                
                <div class="relative bg-white p-4 rounded-xl shadow-md mb-6 border border-indigo-50 transform transition-all duration-300" id="teacher-bubble">
                    <p class="text-indigo-900 font-medium text-lg leading-relaxed" id="teacher-text">
                        "Hi there! üëã I'm here to help you master the standards.<br><br><strong>What subject are we studying today?</strong>"
                    </p>
                    <div class="absolute -bottom-2 left-1/2 transform -translate-x-1/2 w-4 h-4 bg-white rotate-45 border-b border-r border-indigo-50"></div>
                </div>

                <div class="relative">
                    <div class="w-32 h-32 rounded-full bg-indigo-200 border-4 border-white shadow-lg overflow-hidden flex items-end justify-center">
                        <span class="text-7xl mb-[-5px]">üë©‚Äçüè´</span>
                    </div>
                    <div class="absolute -bottom-2 -right-2 bg-green-400 w-6 h-6 rounded-full border-4 border-white"></div>
                </div>
                
                <h3 class="mt-4 font-bold text-indigo-900">Ms. Staar</h3>
                <p class="text-xs text-indigo-500 font-semibold uppercase tracking-wider">Your Learning Guide</p>
            </div>

            <div class="w-full md:w-2/3 p-8 md:p-12 flex flex-col justify-between">
                
                <div class="space-y-8">
                    <div class="transition-all duration-500" id="step-1-container">
                        <label class="block text-xs font-bold text-gray-400 uppercase tracking-widest mb-2">Step 1: Choose Subject</label>
                        <div class="relative group">
                            <select id="welcome-subject-select" class="block w-full p-4 pl-5 text-xl font-bold text-gray-800 bg-gray-50 border-2 border-gray-200 rounded-xl appearance-none focus:border-indigo-500 focus:bg-white focus:ring-0 cursor-pointer transition-colors shadow-sm hover:border-indigo-300">
                                </select>
                            <div class="absolute inset-y-0 right-0 flex items-center px-4 pointer-events-none">
                                <svg class="w-6 h-6 text-indigo-500" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                            </div>
                        </div>
                    </div>

                    <div class="opacity-50 pointer-events-none transition-all duration-500 filter blur-sm" id="step-2-container">
                        <label class="block text-xs font-bold text-gray-400 uppercase tracking-widest mb-3">Step 2: Choose Your View</label>
                        <div class="grid grid-cols-1 sm:grid-cols-3 gap-4">
                            
                            <button class="view-card group p-4 border-2 border-gray-100 rounded-xl hover:border-indigo-500 hover:shadow-lg transition-all text-left relative overflow-hidden" onclick="selectWelcomeView('zone', this)">
                                <div class="absolute top-0 right-0 p-2 opacity-0 group-hover:opacity-100 transition-opacity">
                                    <span class="bg-indigo-600 text-white text-xs font-bold px-2 py-1 rounded-full">Recommended</span>
                                </div>
                                <div class="text-3xl mb-2">üöÄ</div>
                                <h4 class="font-bold text-gray-800 group-hover:text-indigo-600">Student Zones</h4>
                                <p class="text-xs text-gray-500 mt-1 leading-snug">Visual map of what to study next.</p>
                            </button>

                            <button class="view-card group p-4 border-2 border-gray-100 rounded-xl hover:border-orange-500 hover:shadow-lg transition-all text-left" onclick="selectWelcomeView('blueprint', this)">
                                <div class="text-3xl mb-2">üìä</div>
                                <h4 class="font-bold text-gray-800 group-hover:text-orange-600">Blueprint</h4>
                                <p class="text-xs text-gray-500 mt-1 leading-snug">Deep data analysis for teachers.</p>
                            </button>

                         <button class="view-card group p-4 border-2 border-gray-100 rounded-xl hover:border-blue-500 hover:shadow-lg transition-all text-left relative overflow-hidden" onclick="selectWelcomeView('cluster', this)">
                                <div class="absolute top-0 right-0 p-2 opacity-0 group-hover:opacity-100 transition-opacity">
                                    <span class="bg-blue-600 text-white text-xs font-bold px-2 py-1 rounded-full">Best for Teachers</span>
                                </div>
                                <div class="text-3xl mb-2">üìÇ</div>
                                <h4 class="font-bold text-gray-800 group-hover:text-blue-600">Clusters</h4>
                                <p class="text-xs text-gray-500 mt-1 leading-snug">Standard folder view of TEKS.</p>
                            </button>
                        </div>
                    </div>
                </div>

                <div class="mt-8 flex justify-end items-center gap-4">
                    <span id="loading-indicator" class="text-sm font-bold text-indigo-500 hidden items-center animate-pulse">
                        <span class="mr-2">‚ö° Loading data in background...</span>
                    </span>
                    <button id="welcome-go-btn" class="px-8 py-4 bg-gray-300 text-white font-bold text-lg rounded-xl shadow-none cursor-not-allowed transition-all transform hover:scale-105" disabled>
                        Get Started
                    </button>
                </div>

            </div>
        </div>
    </div>`;

    document.body.insertAdjacentHTML('beforeend', modalHtml);

    // 3. Populate Dropdown (Re-using your existing logic structure)
    const subjectSelect = document.getElementById('welcome-subject-select');
    // Add a placeholder
    const placeholder = document.createElement('option');
    placeholder.textContent = "Select a Subject...";
    placeholder.value = "";
    placeholder.selected = true;
    placeholder.disabled = true;
    subjectSelect.appendChild(placeholder);
    
    // Use existing groups logic from renderSubjectDropdown
    const groups = {
         'High School (EOC)': ['Algebra 1', 'Biology', 'English 1', 'English 2', 'U.S. History'],
         'Middle School (Grades 6-8)': ['Math Grade 6', 'Math Grade 7', 'Math Grade 8', 'Reading Grade 6', 'Reading Grade 7', 'Reading Grade 8', 'Science Grade 8', 'Social Studies Grade 8'],
         'Elementary School (Grades 3-5)': ['Math Grade 3', 'Math Grade 4', 'Math Grade 5', 'Reading Grade 3', 'Reading Grade 4', 'Reading Grade 5', 'Science Grade 5'],
    };

    for (const [groupLabel, subjects] of Object.entries(groups)) {
        const optgroup = document.createElement('optgroup');
        optgroup.label = groupLabel;
        subjects.forEach(subjectName => {
            const option = document.createElement('option');
            option.value = subjectName;
            option.textContent = subjectName;
            optgroup.appendChild(option);
        });
        subjectSelect.appendChild(optgroup);
    }

    // 4. Interaction Logic
    
    // -- Step 1: Subject Selected --
    subjectSelect.addEventListener('change', (e) => {
        const subject = e.target.value;
        const teacherText = document.getElementById('teacher-text');
        const step2 = document.getElementById('step-2-container');
        
        // Removed: loader.classList.remove('hidden'); 
        // Removed: switchSubject(subject);  <-- DELETED THIS LINE

        if (subject) {
            // A. Update Teacher Text
            teacherText.innerHTML = `
                "Excellent choice! I'm pulling up the <strong>${subject}</strong> data.<br><br>
                How would you like to view the dashboard?"
            `;

            // B. Unlock Step 2
            step2.classList.remove('opacity-50', 'pointer-events-none', 'filter', 'blur-sm');
        }
    });

    // -- Step 2: View Selected --
    window.selectWelcomeView = (mode, btn) => {
        // Update State
        AppState.dashboardViewMode = mode;
        
        // Visual Feedback (Selection Ring)
        document.querySelectorAll('.view-card').forEach(c => {
            c.classList.remove('ring-4', 'ring-indigo-200', 'bg-indigo-50', 'border-indigo-500');
            c.classList.add('border-gray-100');
        });
        btn.classList.remove('border-gray-100');
        btn.classList.add('ring-4', 'ring-indigo-200', 'bg-indigo-50', 'border-indigo-500');

        // Update Teacher Text
        const teacherText = document.getElementById('teacher-text');
        const modeName = mode === 'zone' ? 'Student Zones' : (mode === 'blueprint' ? 'Strategy Blueprint' : 'Cluster View');
        teacherText.innerHTML = `
            "<strong>${modeName}!</strong> Great for visualization.<br><br>
            We are all set. Click <strong>Get Started</strong> to jump in!"
        `;

        // Unlock "Go" Button
        const goBtn = document.getElementById('welcome-go-btn');
        goBtn.disabled = false;
        goBtn.classList.remove('bg-gray-300', 'cursor-not-allowed');
        goBtn.classList.add('bg-indigo-600', 'hover:bg-indigo-700', 'shadow-xl');
    };

  // -- Step 3: Go! --
    document.getElementById('welcome-go-btn').addEventListener('click', async () => {
        const subject = document.getElementById('welcome-subject-select').value;
        const modal = document.getElementById('welcome-modal');
        const goBtn = document.getElementById('welcome-go-btn');

        // Show loading state on the button itself
        goBtn.textContent = "Loading...";
        goBtn.disabled = true;

        // NOW we load the data (Once. reliably.)
        await switchSubject(subject);

        // Close modal and render
        modal.style.opacity = '0';
        setTimeout(() => {
            modal.remove();
            renderDashboard(); 
        }, 500);
    });
}
 window.onload = function() {
    // --- App Initialization ---
    if (typeof pdfjsLib === 'undefined') {
        console.error("PDF.js library not loaded. Please check the script link.");
        return;
    }
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.worker.min.js';

    console.log("üèÅ [Startup] initializing...");
    loadState(); 
    
    // --- CHANGE: HANDLE SAVED STATE VS NEW START ---
    // If we have a saved subject from a previous session, use it. 
    // Otherwise, default to null so NOTHING loads yet.
    if (!AppState.currentSubject) {
        AppState.currentSubject = null;
    }

    renderSubjectDropdown();

    // Show the Wizard immediately.
    // The Wizard is now the ONLY thing that triggers a data load.
    showWelcomeModal();
    
    // Ensure file input listeners are active
    const fileInput = document.getElementById('pdf-upload');
    if (fileInput) fileInput.addEventListener('change', handleFileSelect);
    
    const rationaleInput = document.getElementById('rationale-upload');
    if (rationaleInput) rationaleInput.addEventListener('change', handleRationaleSelect);
};
// ==========================================
// 1. UPDATED PARSER SCHEMAS (Universal Support)
// ==========================================
const ParserSchemas = {
    // --- HIGH SCHOOL ---
    'Biology': {
        questionStartRegex: /(\d{4})\s*[-‚Äì‚Äî]\s*Q\d+/,
        questionIdRegex: /\d{4}\s*[-‚Äì‚Äî]\s*(Q\d+)/,
        teksRcRegex: /([A-Z0-9\.]+\([A-Z]\))\s+RC\s*(\d+)/,
        teksRegex: /([A-ZŒª0-9\.]+\([A-Z0-9]\))\s*([\s\S]+?)\s*Analysis of Assessed Standards/im,
        itemTypeMatch: /Item Type\s*([\s\S]+?)\s*Stimulus/,
        clusterMatch: /Cluster\s*([\s\S]+?)\s*Subcluster/,
        analysisAnchor: 'Analysis of Assessed Standards',
        bottomAnchor: 'Correct Answer'
    },
    'Algebra 1': {
        questionStartRegex: /(\d{4})\s*[-‚Äì‚Äî]?\s*Q\d+/,
        questionIdRegex: /\d{4}\s*[-‚Äì‚Äî]?\s*(Q\d+)/,
        teksRcRegex: /([A-Z0-9\.]+\([A-Z]\))\s+RC\s*(\d+)/,
        teksRegex: /([A-ZŒª0-9\.]+\([A-Z0-9]\))\s*([\s\S]+?)\s*Analysis of Assessed Standards/im,
        itemTypeMatch: /Item Type\s*([\s\S]+?)\s*Stimulus/,
        clusterMatch: /Cluster\s*([\s\S]+?)\s*Subcluster/,
        analysisAnchor: 'Analysis of Assessed Standards',
        bottomAnchor: 'Correct Answer'
    },
    'U.S. History': {
        questionStartRegex: /(\d{4})\s*[-‚Äì‚Äî]?\s*Q\d+/, 
        questionIdRegex: /\d{4}\s*[-‚Äì‚Äî]?\s*(Q\d+)/,    
        teksRcRegex: /([A-Z0-9\.]+\([A-Z]\))\s+RC\s*(\d+)/,
        teksRegex: /([A-ZŒª0-9\.]+\([A-Z0-9]\))\s*([\s\S]+?)\s*Analysis of Assessed Standards/im,
        itemTypeMatch: /Item Type\s*([\s\S]+?)\s*Stimulus/,
        clusterMatch: /Cluster\s*([\s\S]+?)\s*Subcluster/,
        analysisAnchor: 'Analysis of Assessed Standards',
        bottomAnchor: 'Correct Answer'
    },
    'English 1': {
        questionStartRegex: /(\d{4})\s*[-‚Äì‚Äî]?\s*Q\d+/, 
        questionIdRegex: /\d{4}\s*[-‚Äì‚Äî]?\s*(Q\d+)/,    
        teksRcRegex: /([A-Z0-9\.]+\([A-Z]\))\s+RC\s*(\d+)/, 
        teksRegex: /([A-ZŒª0-9\.]+\([A-Z0-9]\))\s*([\s\S]+?)\s*Analysis of Assessed Standards/im,
        itemTypeMatch: /Item Type\s*([\s\S]+?)\s*Stimulus/,
        clusterMatch: /Cluster\s*([\s\S]+?)\s*Subcluster/, 
        analysisAnchor: 'Analysis of Assessed Standards', 
        bottomAnchor: 'Correct Answer' 
    },
    'English 2': {
        questionStartRegex: /(\d{4})\s*[-‚Äì‚Äî]?\s*Q\d+/, 
        questionIdRegex: /\d{4}\s*[-‚Äì‚Äî]?\s*(Q\d+)/,    
        teksRcRegex: /([A-Z0-9\.]+\([A-Z]\))\s+RC\s*(\d+)/,
        teksRegex: /([A-ZŒª0-9\.]+\([A-Z0-9]\))\s*([\s\S]+?)\s*Analysis of Assessed Standards/im,
        itemTypeMatch: /Item Type\s*([\s\S]+?)\s*Stimulus/,
        clusterMatch: /Cluster\s*([\s\S]+?)\s*Subcluster/,
        analysisAnchor: 'Analysis of Assessed Standards',
        bottomAnchor: 'Correct Answer'
    }
};

// --- AUTOMATICALLY MAP ELEMENTARY/MIDDLE TO EXISTING SCHEMAS ---
const baseMathSchema = ParserSchemas['Algebra 1'];
const baseReadingSchema = ParserSchemas['English 1'];
const baseScienceSchema = ParserSchemas['Biology'];
const baseSocialStudiesSchema = ParserSchemas['U.S. History'];

// Map Math 3-8
['Math Grade 3', 'Math Grade 4', 'Math Grade 5', 'Math Grade 6', 'Math Grade 7', 'Math Grade 8'].forEach(sub => ParserSchemas[sub] = baseMathSchema);
// Map Reading 3-8
['Reading Grade 3', 'Reading Grade 4', 'Reading Grade 5', 'Reading Grade 6', 'Reading Grade 7', 'Reading Grade 8'].forEach(sub => ParserSchemas[sub] = baseReadingSchema);
// Map Science 5 & 8
['Science Grade 5', 'Science Grade 8'].forEach(sub => ParserSchemas[sub] = baseScienceSchema);
// Map Social Studies 8
['Social Studies Grade 8'].forEach(sub => ParserSchemas[sub] = baseSocialStudiesSchema);


// ==========================================
// 2. UPDATED APP STATE (Full K-12 Support)
// ==========================================
const AppState = {
    currentSubject: null, 
    subjects: {
        // High School
        'Algebra 1': { pdfDocs: [], rationalePdfDoc: null, allQuestions: [], masteryState: {}, teksToRcMap: {}, customPathways: [] },
        'Biology': { pdfDocs: [], rationalePdfDoc: null, allQuestions: [], masteryState: {}, teksToRcMap: {}, customPathways: [] },
        'English 1': { pdfDocs: [], rationalePdfDoc: null, allQuestions: [], masteryState: {}, teksToRcMap: {}, customPathways: [] },
        'English 2': { pdfDocs: [], rationalePdfDoc: null, allQuestions: [], masteryState: {}, teksToRcMap: {}, customPathways: [] },
        'U.S. History': { pdfDocs: [], rationalePdfDoc: null, allQuestions: [], masteryState: {}, teksToRcMap: {}, customPathways: [] },
        
        // Math 3-8
        'Math Grade 3': { pdfDocs: [], rationalePdfDoc: null, allQuestions: [], masteryState: {}, teksToRcMap: {}, customPathways: [] },
        'Math Grade 4': { pdfDocs: [], rationalePdfDoc: null, allQuestions: [], masteryState: {}, teksToRcMap: {}, customPathways: [] },
        'Math Grade 5': { pdfDocs: [], rationalePdfDoc: null, allQuestions: [], masteryState: {}, teksToRcMap: {}, customPathways: [] },
        'Math Grade 6': { pdfDocs: [], rationalePdfDoc: null, allQuestions: [], masteryState: {}, teksToRcMap: {}, customPathways: [] },
        'Math Grade 7': { pdfDocs: [], rationalePdfDoc: null, allQuestions: [], masteryState: {}, teksToRcMap: {}, customPathways: [] },
        'Math Grade 8': { pdfDocs: [], rationalePdfDoc: null, allQuestions: [], masteryState: {}, teksToRcMap: {}, customPathways: [] },

        // Reading 3-8
        'Reading Grade 3': { pdfDocs: [], rationalePdfDoc: null, allQuestions: [], masteryState: {}, teksToRcMap: {}, customPathways: [] },
        'Reading Grade 4': { pdfDocs: [], rationalePdfDoc: null, allQuestions: [], masteryState: {}, teksToRcMap: {}, customPathways: [] },
        'Reading Grade 5': { pdfDocs: [], rationalePdfDoc: null, allQuestions: [], masteryState: {}, teksToRcMap: {}, customPathways: [] },
        'Reading Grade 6': { pdfDocs: [], rationalePdfDoc: null, allQuestions: [], masteryState: {}, teksToRcMap: {}, customPathways: [] },
        'Reading Grade 7': { pdfDocs: [], rationalePdfDoc: null, allQuestions: [], masteryState: {}, teksToRcMap: {}, customPathways: [] },
        'Reading Grade 8': { pdfDocs: [], rationalePdfDoc: null, allQuestions: [], masteryState: {}, teksToRcMap: {}, customPathways: [] },

        // Science 5 & 8
        'Science Grade 5': { pdfDocs: [], rationalePdfDoc: null, allQuestions: [], masteryState: {}, teksToRcMap: {}, customPathways: [] },
        'Science Grade 8': { pdfDocs: [], rationalePdfDoc: null, allQuestions: [], masteryState: {}, teksToRcMap: {}, customPathways: [] },

        // Social Studies 8
        'Social Studies Grade 8': { pdfDocs: [], rationalePdfDoc: null, allQuestions: [], masteryState: {}, teksToRcMap: {}, customPathways: [] },
    },
    difficultySettings: {
        mastersThreshold: 40, 
        meetsThreshold: 65,   
        targets: { approaches: 38, meets: 60, masters: 82 } 
    },
    currentPathway: { 
        teks: null,
        questions: [],
        currentIndex: 0,
        activeQuestion: null,
        userSelections: [],
        graphingPoints: [], 
        flagged: {}, 
        isQuiz: false,
        timerSettings: null,
        startTime: null,
    },
    questionTimer: null, 
    draggedItem: null, 
    touchDragGhost: null, 
    zoomLevel: 1.0, 
    passageZoomLevel: 1.0, 
    unparsedPages: 0, 
    dashboardViewMode: 'cluster', 
    isDraggingBox: false, 
    draggedBoxElement: null,
    draggedBoxZone: null,
    draggedBoxQuestion: null,
    dragStartX: 0,
    dragStartY: 0,
};


// ==========================================
// 3. UPDATED RC NAMES (Correct Mapping for Zones)
// ==========================================
const RCNames = {
    // --- HIGH SCHOOL ---
    'Algebra 1': {
        'RC 1': 'Number & Algebraic Methods',
        'RC 2': 'Describing & Graphing Linear Functions',
        'RC 3': 'Writing & Solving Linear Functions',
        'RC 4': 'Quadratic Functions & Equations',
        'RC 5': 'Exponential Functions & Equations'
    },
    'Biology': {
        'RC 1': 'Cell Structure & Function',
        'RC 2': 'Mechanisms of Genetics',
        'RC 3': 'Biological Evolution & Classification',
        'RC 4': 'Biological Processes & Systems',
        'RC 5': 'Interdependence within Environmental Systems'
    },
    'U.S. History': {
        'RC 1': 'History',
        'RC 2': 'Geography & Culture',
        'RC 3': 'Government & Citizenship',
        'RC 4': 'Economics, Science, Tech, & Society'
    },
    'English 1': { 'RC 1': 'Analysis Across Genres', 'RC 2': 'Analysis of Literary Texts', 'RC 3': 'Analysis of Informational Texts', 'RC 4': 'Composition', 'RC 5': 'Revision', 'RC 6': 'Editing' },
    'English 2': { 'RC 1': 'Analysis Across Genres', 'RC 2': 'Analysis of Literary Texts', 'RC 3': 'Analysis of Informational Texts', 'RC 4': 'Composition', 'RC 5': 'Revision', 'RC 6': 'Editing' },

    // --- MATH 3-5 (Elementary) ---
    'Math Grade 3': { 'RC 1': 'Numerical Representations', 'RC 2': 'Computations & Algebraic Relationships', 'RC 3': 'Geometry & Measurement', 'RC 4': 'Data Analysis & Personal Financial Literacy' },
    'Math Grade 4': { 'RC 1': 'Numerical Representations', 'RC 2': 'Computations & Algebraic Relationships', 'RC 3': 'Geometry & Measurement', 'RC 4': 'Data Analysis & Personal Financial Literacy' },
    'Math Grade 5': { 'RC 1': 'Numerical Representations', 'RC 2': 'Computations & Algebraic Relationships', 'RC 3': 'Geometry & Measurement', 'RC 4': 'Data Analysis & Personal Financial Literacy' },
    
    // --- MATH 6-8 (Middle) ---
    'Math Grade 6': { 'RC 1': 'Numerical Representations', 'RC 2': 'Computations & Algebraic Relationships', 'RC 3': 'Geometry & Measurement', 'RC 4': 'Data Analysis & Personal Financial Literacy' },
    'Math Grade 7': { 'RC 1': 'Probability & Numerical Representations', 'RC 2': 'Computations & Algebraic Relationships', 'RC 3': 'Geometry & Measurement', 'RC 4': 'Data Analysis & Personal Financial Literacy' },
    'Math Grade 8': { 'RC 1': 'Probability & Numerical Representations', 'RC 2': 'Computations & Algebraic Relationships', 'RC 3': 'Geometry & Measurement', 'RC 4': 'Data Analysis & Personal Financial Literacy' },

    // --- READING 3-8 ---
    'Reading Grade 3': { 'RC 1': 'Analysis Across Genres', 'RC 2': 'Analysis of Literary Texts', 'RC 3': 'Analysis of Informational Texts', 'RC 4': 'Composition/Revision/Editing' },
    'Reading Grade 4': { 'RC 1': 'Analysis Across Genres', 'RC 2': 'Analysis of Literary Texts', 'RC 3': 'Analysis of Informational Texts', 'RC 4': 'Composition/Revision/Editing' },
    'Reading Grade 5': { 'RC 1': 'Analysis Across Genres', 'RC 2': 'Analysis of Literary Texts', 'RC 3': 'Analysis of Informational Texts', 'RC 4': 'Composition/Revision/Editing' },
    'Reading Grade 6': { 'RC 1': 'Analysis Across Genres', 'RC 2': 'Analysis of Literary Texts', 'RC 3': 'Analysis of Informational Texts', 'RC 4': 'Composition/Revision/Editing' },
    'Reading Grade 7': { 'RC 1': 'Analysis Across Genres', 'RC 2': 'Analysis of Literary Texts', 'RC 3': 'Analysis of Informational Texts', 'RC 4': 'Composition/Revision/Editing' },
    'Reading Grade 8': { 'RC 1': 'Analysis Across Genres', 'RC 2': 'Analysis of Literary Texts', 'RC 3': 'Analysis of Informational Texts', 'RC 4': 'Composition/Revision/Editing' },

    // --- SCIENCE 5 & 8 ---
    'Science Grade 5': { 'RC 1': 'Matter & Energy', 'RC 2': 'Force, Motion, & Energy', 'RC 3': 'Earth & Space', 'RC 4': 'Organisms & Environments' },
    'Science Grade 8': { 'RC 1': 'Matter & Energy', 'RC 2': 'Force, Motion, & Energy', 'RC 3': 'Earth & Space', 'RC 4': 'Organisms & Environments' },

    // --- SOCIAL STUDIES 8 ---
    'Social Studies Grade 8': { 'RC 1': 'History', 'RC 2': 'Geography & Culture', 'RC 3': 'Government & Citizenship', 'RC 4': 'Economics, Science, Tech, & Society' },
};
            
// ==========================================
// 4. UPDATED FILE LINKS (Placeholders Ready)
// ==========================================
const SubjectFiles = {
    // High School
    'Biology': 'https://raw.githubusercontent.com/MrRamirez123/Staar-mastery/main/assets/pdfs/biologyallquestions.pdf', 
    'Algebra 1': [
        'https://raw.githubusercontent.com/MrRamirez123/Staar-mastery/main/assets/pdfs/Algebra1621.pdf',
        'https://raw.githubusercontent.com/MrRamirez123/Staar-mastery/main/assets/pdfs/Algebra2225.pdf'
    ],
    'English 1': 'https://raw.githubusercontent.com/MrRamirez123/Staar-mastery/main/assets/pdfs/eng125.pdf',    
    'English 2': null,    
    'U.S. History': [
        'https://raw.githubusercontent.com/MrRamirez123/Staar-mastery/main/assets/pdfs/ushistory1819.pdf',
        'https://raw.githubusercontent.com/MrRamirez123/Staar-mastery/main/assets/pdfs/ushistory2122.pdf',
        'https://raw.githubusercontent.com/MrRamirez123/Staar-mastery/main/assets/pdfs/ushistory2325.pdf'
    ],

    // Placeholders for Elementary (3-5)
    'Math Grade 3': [
        'https://raw.githubusercontent.com/MrRamirez123/Staar-mastery/main/assets/pdfs/math31521.pdf',
        'https://raw.githubusercontent.com/MrRamirez123/Staar-mastery/main/assets/pdfs/math32225.pdf'
    ],
    'Math Grade 4': null,
    'Math Grade 5': null,
    'Reading Grade 3': ['https://raw.githubusercontent.com/MrRamirez123/Staar-mastery/main/assets/pdfs/eng32223.pdf',
        'https://raw.githubusercontent.com/MrRamirez123/Staar-mastery/main/assets/pdfs/eng32425.pdf'
    ],
    'Reading Grade 4': null,
    'Reading Grade 5': null,
    'Science Grade 5': null,

    // Placeholders for Middle School (6-8)
    'Math Grade 6': null,
    'Math Grade 7': null,
    'Math Grade 8': null,
    'Reading Grade 6': null,
    'Reading Grade 7': null,
    'Reading Grade 8': null,
    'Science Grade 8': null,
    'Social Studies Grade 8': null
};

      

            // Caching all necessary DOM elements for quick access.
            
            const fileInput = document.getElementById('pdf-upload');
            const statusDiv = document.getElementById('status');
            const dashboardContent = document.getElementById('dashboard-content');
            const pathwayDisplay = document.getElementById('pathway-display');
            const placeholderView = document.getElementById('placeholder-view');
            const answerInterface = document.getElementById('answer-interface');
            const backToDashboardBtn = document.getElementById('back-to-dashboard-btn');
            const toggleTeksBtn = document.getElementById('toggle-teks-btn');
            const teksContextDiv = document.getElementById('teks-context');
            const teksContextNew = document.getElementById('teks-context-new');
            const teksContextOld = document.getElementById('teks-context-old');
            const dashboardView = document.getElementById('dashboard-view');
            const problemView = document.getElementById('problem-view');
            const resultsView = document.getElementById('results-view');
            const progressIndicator = document.getElementById('progress-indicator');
            const clickableProgressBar = document.getElementById('clickable-progress-bar');
            const reviewModal = document.getElementById('review-modal');
            const reviewModalTitle = document.getElementById('review-modal-title');
            const reviewModalContent = document.getElementById('review-modal-content');
            const closeReviewModalBtn = document.getElementById('close-review-modal-btn');
            const customPathwayBuilder = document.getElementById('custom-pathway-builder');
            const filterContainer = document.getElementById('filter-container');
            const generatePathwayBtn = document.getElementById('generate-pathway-btn');
            const explanationBox = document.getElementById('explanation-box');
            const explanationText = document.getElementById('explanation-text');
            const previousProblemBtn = document.getElementById('previous-problem-btn');
            const nextProblemBtn = document.getElementById('next-problem-btn');
            const retryProblemBtn = document.getElementById('retry-problem-btn');
            const skipProblemBtn = document.getElementById('skip-problem-btn');
            const correctAnswerContainer = document.getElementById('correct-answer-container');
            const correctAnswerDisplay = document.getElementById('correct-answer-display');
            const feedbackMessage = document.getElementById('feedback-message');
            const zoomInBtn = document.getElementById('zoom-in-btn');
            const zoomOutBtn = document.getElementById('zoom-out-btn');
            const scalableContent = document.getElementById('scalable-content');
            const resultsBackBtn = document.getElementById('results-back-btn');
            const printResultsBtn = document.getElementById('print-results-btn');
            const downloadResultsBtn = document.getElementById('download-results-btn');
            const flagQuestionBtn = document.getElementById('flag-question-btn');
            const filterReviewBtn = document.getElementById('filter-review-btn');
            const reviewAllContainer = document.getElementById('review-all-container');
            const reviewAllBtn = document.getElementById('review-all-btn');
            const resultsTitle = document.getElementById('results-title');
            const resultsSummary = document.getElementById('results-summary');
            const missedQuestionsGrid = document.getElementById('missed-questions-grid');
            const resultsAnalysisContainer = document.getElementById('results-analysis-container');
            const quizSetupModal = document.getElementById('quiz-setup-modal');
            const enableTimerToggle = document.getElementById('enable-timer-toggle');
            const timerOptions = document.getElementById('timer-options');
            const timePerQuestionInput = document.getElementById('time-per-question');
            const cancelQuizBtn = document.getElementById('cancel-quiz-btn');
            const beginQuizBtn = document.getElementById('begin-quiz-btn');
            const timerDisplay = document.getElementById('timer-display');
            const homeBtn = document.getElementById('home-btn');
            const subjectDropdown = document.getElementById('subject-dropdown');
            const editQuestionBtn = document.getElementById('edit-question-btn');
            const printOptionsModal = document.getElementById('print-options-modal');
            const cancelPrintBtn = document.getElementById('cancel-print-btn');
            const generatePrintBtn = document.getElementById('generate-print-btn');
            const includeAnswersToggle = document.getElementById('include-answers-toggle');
            const printModalLoader = document.getElementById('print-modal-loader');
function handleEditCurrentQuestion() {
    const currentQuestion = AppState.currentPathway.activeQuestion;
    if (currentQuestion) {
        showReviewModal(`Editing: ${currentQuestion.id}`, currentQuestion);
    }
}

            // --- Event Listeners ---
            // Assigning functions to be called when specific events occur on elements.
            
            editQuestionBtn.addEventListener('click', handleEditCurrentQuestion);
            backToDashboardBtn.addEventListener('click', showDashboard);
            document.getElementById('view-history-btn').addEventListener('click', showHistoryModal);
            homeBtn.addEventListener('click', showDashboard);
            resultsBackBtn.addEventListener('click', showDashboard);
            toggleTeksBtn.addEventListener('click', toggleTeksVisibility);
            closeReviewModalBtn.addEventListener('click', () => {
                reviewModal.classList.add('hidden');
                updateReviewAllButton();
                renderDashboard(); 
                saveState();
            });
            generatePathwayBtn.addEventListener('click', generateCustomPathway);
        // Question Zoom Buttons
            zoomInBtn.addEventListener('click', () => updateZoom(0.2, 'question'));
            zoomOutBtn.addEventListener('click', () => updateZoom(-0.2, 'question'));
            
            // Passage Zoom Buttons
            document.getElementById('passage-zoom-in-btn').addEventListener('click', () => updateZoom(0.2, 'passage'));
            document.getElementById('passage-zoom-out-btn').addEventListener('click', () => updateZoom(-0.2, 'passage'));
            printResultsBtn.addEventListener('click', printResults);
            downloadResultsBtn.addEventListener('click', downloadResults);
            flagQuestionBtn.addEventListener('click', toggleFlagCurrentQuestion);
            filterReviewBtn.addEventListener('click', toggleReviewFilter);
            reviewAllBtn.addEventListener('click', reviewAllNeedingSetup);
            resultsAnalysisContainer.addEventListener('click', (e) => {
                if (e.target.matches('.practice-topic-btn')) {
                    const topic = e.target.dataset.topic;
                    startTopicPractice(topic);
                }
            });
     missedQuestionsGrid.addEventListener('click', (e) => {
    const reviewButton = e.target.closest('.review-missed-btn');
    if (reviewButton) {
        const questionId = reviewButton.dataset.questionId;
        // Find the index in the CURRENT pathway so we can jump to it
        const index = AppState.currentPathway.questions.findIndex(q => q.id === questionId);
        
        if (index !== -1) {
            // 1. Switch back to student view
            showProblemView();
            // 2. Jump to the question and Force Reveal the answer
            reviewMissedQuestion(index);
        }
    }
});
  /**
 * Jumps to a question and immediately reveals the answer/rationale.
 * UPDATED: Changes "Back" button to return to Results.
 */
async function reviewMissedQuestion(index) {
    // 1. Render the problem normally
    AppState.currentPathway.currentIndex = index;
    await renderProblem(AppState.currentPathway.questions[index]);

    // 2. HIJACK THE NAVIGATION BUTTONS
    const backBtn = document.getElementById('back-to-dashboard-btn');
    const originalText = backBtn.textContent;
    const originalOnClick = backBtn.onclick;

    // Change button to "Back to Results"
    backBtn.textContent = "‚¨Ö Back to Results";
    backBtn.onclick = () => {
        // Restore original state
        backBtn.textContent = "Back to Pathway";
        backBtn.onclick = showDashboard; // Restore original dashboard link
        renderResultsScreen(); // Go back to results
    };
    
    // Hide 'Next/Finish' to force them to use the 'Back to Results' button
    // (Optional: keeps flow simple so they don't get lost)
    document.getElementById('next-problem-btn').classList.add('hidden');

    // 3. Force the "Reveal" state (Existing Logic)
    const question = AppState.currentPathway.questions[index];
    const pathway = AppState.currentPathway;
    
    // Lock Interface
    answerInterface.querySelectorAll('button, textarea, select, canvas').forEach(el => {
        el.classList.add('disabled');
        el.onclick = null;
    });
    
    // Show Correct Answer
    correctAnswerContainer.classList.remove('hidden');
    const answerString = question.answerText?.join(', ') || 'N/A';
    correctAnswerDisplay.textContent = `The correct answer is: ${answerString}`;

    // Highlight Buttons
    answerInterface.querySelectorAll('.answer-button').forEach(btn => {
        const btnText = btn.textContent.trim();
        if (question.answerText && question.answerText.includes(btnText)) {
            btn.classList.add('correct');
        } 
        pathway.userSelections.flat().forEach(userSel => {
            if (userSel === btnText && !question.answerText.includes(userSel)) {
                btn.classList.add('incorrect');
            }
        });
    });

    // Generate Rationale HTML
    let feedbackHTML = "";
    if (question.answerText && question.rationaleMap) {
        question.answerText.forEach(ans => {
            if (question.rationaleMap[ans]) {
                feedbackHTML += `
                    <div class="mt-2 p-3 rounded border bg-green-50 border-green-200 text-green-800 text-left text-sm">
                        <span class="font-bold block mb-1">‚úÖ Correct Rationale (Option ${ans}):</span>
                        ${question.rationaleMap[ans]}
                    </div>`;
            }
        });
    }
    if (question.rationaleMap && question.rationaleMap['Solution']) {
        feedbackHTML += `
            <div class="mt-2 p-3 rounded border bg-blue-50 border-blue-200 text-blue-800 text-left text-sm">
                <span class="font-bold block mb-1">üìò General Analysis:</span>
                ${question.rationaleMap['Solution']}
            </div>`;
    }
    feedbackMessage.innerHTML = feedbackHTML;
}

            enableTimerToggle.addEventListener('change', () => {
                timerOptions.classList.toggle('hidden', !enableTimerToggle.checked);
            });
            cancelQuizBtn.addEventListener('click', () => quizSetupModal.classList.add('hidden'));
            subjectDropdown.addEventListener('change', (e) => switchSubject(e.target.value));


    nextProblemBtn.addEventListener('click', () => {
    const pathway = AppState.currentPathway;
    
    // --- QUIZ MODE LOGIC ---
    if (pathway.isQuiz) {
        // 1. Force the grading (Silent Practice Mode)
        // This will calculate the score, save it, and automatically call next() inside showFeedback
        submitCurrentQuestion(); 
    } 
    // --- PRACTICE MODE LOGIC (Untouched) ---
    else {
        const isLastQuestion = pathway.currentIndex === pathway.questions.length - 1;
        if (!isLastQuestion) {
            pathway.currentIndex++;
            renderProblem(pathway.questions[pathway.currentIndex]);
        } else {
            console.log("%c[PATHWAY] Final question submitted. Rendering results.", "color: blue; font-weight: bold;");
            renderResultsScreen();
        }
    }
});

            skipProblemBtn.addEventListener('click', () => {
                const pathway = AppState.currentPathway;
                const subjectData = getCurrentSubjectData();
                const mastery = subjectData.masteryState[pathway.teks];
                const hasUnanswered = Object.values(mastery).some(s => s === 'not-started');
                const isLastQuestion = pathway.currentIndex === pathway.questions.length - 1;

                if (isLastQuestion && !hasUnanswered) {
                     renderResultsScreen();
                } else if (isLastQuestion && hasUnanswered) {
                     showFinishConfirmationModal();
                }
                else if (pathway.currentIndex < pathway.questions.length - 1) {
                    pathway.currentIndex++;
                    renderProblem(pathway.questions[pathway.currentIndex]);
                }
            });

            previousProblemBtn.addEventListener('click', () => {
                if (AppState.currentPathway.currentIndex > 0) {
                    AppState.currentPathway.currentIndex--;
                    renderProblem(AppState.currentPathway.questions[AppState.currentPathway.currentIndex]);
                }
            });

            retryProblemBtn.addEventListener('click', () => {
                renderProblem(AppState.currentPathway.questions[AppState.currentPathway.currentIndex]);
            });

    function handleFileSelect(e) {
    const file = e.target.files[0];
    if (!file || file.type !== 'application/pdf') return;
    
    // 1. SHOW LOADER
    showLoader("I'm reading your PDF file... this might take a few seconds!");

    const subjectData = getCurrentSubjectData();
    subjectData.allQuestions = [];
    subjectData.masteryState = {};
    subjectData.teksToRcMap = {};
    subjectData.pdfDocs = []; 
    
    const fileReader = new FileReader();
    fileReader.onload = async function() {
        const typedarray = new Uint8Array(this.result);
        const newDoc = await pdfjsLib.getDocument(typedarray).promise;
        subjectData.pdfDocs.push(newDoc); 

        subjectData.teksToRcMap = await buildTeksToRcMap(newDoc);
        subjectData.allQuestions = await parseAllPages(newDoc, 0); 
        
        // 2. HIDE LOADER
        hideLoader();
        
        // Update Status Text (Small text for confirmation)
        let statusMessage = `Processing complete. Found ${subjectData.allQuestions.length} questions.`;
        if (AppState.unparsedPages > 0) {
            statusMessage += ` <span class="font-bold text-red-600">Warning: ${AppState.unparsedPages} page(s) could not be parsed.</span>`;
        }
        document.getElementById('status').innerHTML = statusMessage;
        
        updateReviewAllButton();
        renderDashboard();
        populateCustomFilters();
        saveState();
    };
    fileReader.readAsArrayBuffer(file);
}


// --- IMPROVED RATIONALE UPLOADER (Year-First Safety + Structure Parsing) ---

// Ensure the listener is attached safely
const rationaleInput = document.getElementById('rationale-upload');
if (rationaleInput) {
    rationaleInput.removeEventListener('change', handleRationaleSelect); 
    rationaleInput.addEventListener('change', handleRationaleSelect);
}
/**
 * Handles the selection of the Rationale PDF.
 * UPDATED: Stores the PDF doc and maps questions to specific page numbers.
 */
function handleRationaleSelect(e) {
    const file = e.target.files[0];
    if (!file || file.type !== 'application/pdf') return;

    statusDiv.innerHTML = '<div class="flex items-center justify-center"><div class="loader mr-2"></div>Scanning Rationales & Mapping Pages...</div>';
    
    const fileReader = new FileReader();
    fileReader.onload = async function() {
        const typedarray = new Uint8Array(this.result);
        const pdfDoc = await pdfjsLib.getDocument(typedarray).promise;
        
        // 1. SAVE THE DOC FOR LATER VIEWING
        const subjectData = getCurrentSubjectData();
        subjectData.rationalePdfDoc = pdfDoc;

        let fullText = "";
        const pageMap = {}; // Maps "Item Number" -> Page Number

        // 2. Scan pages to build text AND map locations
        for (let i = 1; i <= pdfDoc.numPages; i++) {
            const page = await pdfDoc.getPage(i);
            const textContent = await page.getTextContent();
            const pageText = textContent.items.map(item => item.str).join('\n');
            
            fullText += pageText + "\n";

            // Simple check: If we see "Item 5" on this page, map 5 to this page.
            // Regex looks for "Item" followed by a number, or just a number at start of line
            const itemMatches = pageText.match(/(?:Item\s+|Position\s+|^)\s*(\d+)/g);
            if (itemMatches) {
                itemMatches.forEach(match => {
                    const num = match.replace(/\D/g, '');
                    if (!pageMap[num]) pageMap[num] = i; // Store first occurrence
                });
            }
        }

        // 3. Detect Year (Safety Check)
        const headerText = fullText.substring(0, 1000); 
        const yearMatch = headerText.match(/20\d{2}/);
        let detectedYear = yearMatch ? yearMatch[0] : null;

        if (!detectedYear) {
          await new Promise(resolve => {
        showCustomModal(
            "Year Missing",
            "Could not automatically detect the exam year (e.g., 2023) from the file header. Please enter the year manually to continue:",
            (confirmed, inputYear) => {
                if (confirmed && inputYear) {
                    detectedYear = inputYear; // Update detectedYear with user's input
                    resolve();
                } else {
                    // User canceled, or provided no input
                    statusDiv.innerHTML = `<span class="text-red-600 font-bold">Upload canceled by user.</span>`;
                    resolve(); // Resolve to exit the promise wait
                }
            },
            true, // Show cancel button
            true // Indicate that input field is needed
        );
    });

    if (!detectedYear) {
        // This means the user cancelled the modal, so we exit the handler.
        return;
    }
}
        // 4. Parse Text Logic (Existing Logic)
        const rationales = parseRationalesText(fullText);
        
        // 5. Update Questions with Data AND Page Location
        let matchCount = 0;
        rationales.forEach(rat => {
            const targetQ = subjectData.allQuestions.find(q => 
                q.year === detectedYear && 
                (q.id.endsWith(`-Q${rat.number}`) || q.id.endsWith(`-Q0${rat.number}`))
            );

            if (targetQ) {
                targetQ.rationaleMap = rat.rationaleMap;
                // SAVE THE PAGE NUMBER
                targetQ.rationalePage = pageMap[rat.number] || 1; 
                matchCount++;
            }
        });

        statusDiv.innerHTML = `Success! Mapped rationales to <strong>${matchCount}</strong> questions for <span class="text-blue-600 font-bold">${detectedYear}</span>.`;
        saveState();
    };
    fileReader.readAsArrayBuffer(file);
}

/**
 * UNIVERSAL PARSER v9: The "Polished Math" Edition
 
 */
function parseRationalesText(text) {
    const rationalesMap = new Map();

    const cleanText = (str) => {
        return str
            .replace(/\$/g, "")
            .replace(/\\sqrt\{(\d+)\}/g, "‚àö$1")
            .replace(/\\sqrt/g, "‚àö")
            .replace(/\\frac\{(.+?)\}\{(.+?)\}/g, "($1/$2)")
            .replace(/\\cdot/g, "‚Ä¢")
            .replace(/\\approx/g, "‚âà")
            .replace(/\\le/g, "‚â§")
            .replace(/\\ge/g, "‚â•")
            .replace(/\s+/g, " ").trim();
    };

    // 1. CHUNKING
    const chunks = text.split(/Item\s*(?:Position|#)/gi);

    chunks.forEach((chunk) => {
        if (!chunk || chunk.trim().length === 0) return;

        // --- 2. SMART ID FINDER ---
        const detectionText = chunk.replace(/["',]/g, " ");

        let numMatch = detectionText.match(/\b(\d+)\b(?=[\s\S]{0,600}\b(?:Option|Rationale|Correct|Score|Part|pts?|SCR|scoring|guide|To\b)\b)/i);
        
        if (!numMatch) {
             numMatch = chunk.match(/^[\s\n"']*(\d+)/); 
        }
        
        if (!numMatch) return;

        const itemNumber = parseInt(numMatch[1], 10);

        if (itemNumber > 200 || itemNumber < 1) return;

        const strNum = itemNumber.toString();

        // 3. PARSE CONTENT
        const rawContent = chunk; 
        
        const optionMap = {};

        const optionRegex = /Option[\s.,-]+(?:["']?([A-Z0-9])["']?|["'](.+?)["'])\s*(?:is\s+|:\s*|[\s.-]+)(correct|incorrect|in\s+correct)?/gi;
        
        const hasOptions = optionRegex.test(rawContent);

        if (!hasOptions) {
            // --- RUBRIC / MATH TEXT ENTRY HANDLING ---
            let clean = cleanText(rawContent);
            
            clean = clean
                .replace(new RegExp(`^\\W*${strNum}\\W*`), "") // Remove question number
                .replace(/Rationales?/gi, "")
                .replace(/Correct\s+Answer/gi, "")
                .replace(/For\s+SCR\s+items.*guide/i, "See Scoring Guide in Source PDF.")
                // NEW: Remove leading math answers (digits, fractions, coordinates)
                // Matches "3/2, -1 " or "15 " at the start
                .replace(/^[\d\s,./-]+\s+(?=To\b)/i, "") 
                .trim();
            
            if (clean.length > 0) {
                optionMap[`Solution`] = clean;
            }
        } else {
            optionRegex.lastIndex = 0;
            let matches = [...rawContent.matchAll(optionRegex)];

            matches.forEach((m, i) => {
                const key = m[1] ? m[1].toUpperCase() : (m[2] ? m[2].trim() : "Unknown");
                
                const startIdx = m.index + m[0].length;
                const endIdx = (i < matches.length - 1) ? matches[i+1].index : rawContent.length;
                
                let explanation = rawContent.substring(startIdx, endIdx);
                
                explanation = explanation
                    .replace(/in\s+correct/gi, "incorrect")
                    .replace(/^[.,;:\s]+/, "")
                    .replace(/^(is\s+)?(correct|incorrect)[\s.:]*/i, "");
                
                optionMap[`${key}`] = cleanText(explanation); 
            });
        }

        // Handle Multipart Splits
        if (rawContent.match(/Part\s+B/i)) {
            const parts = rawContent.split(/Part\s+B/i);
            const extractFromPart = (partText, prefix) => {
                let partMatches = [...partText.matchAll(optionRegex)];
                partMatches.forEach((m, i) => {
                    const key = m[1] ? m[1].toUpperCase() : (m[2] ? m[2].trim() : "Unknown");
                    const startIdx = m.index + m[0].length;
                    const endIdx = (i < partMatches.length - 1) ? partMatches[i+1].index : partText.length;
                    let exp = cleanText(partText.substring(startIdx, endIdx));
                    exp = exp.replace(/^(is\s+)?(correct|incorrect)[\s.:]*/i, "");
                    optionMap[`${prefix}${key}`] = exp;
                });
            };
            extractFromPart(parts[0], "PartA_");
            extractFromPart(parts[1] || "", "PartB_");
        }

        // 4. MERGE
        if (Object.keys(optionMap).length > 0) {
            if (rationalesMap.has(strNum)) {
                const existing = rationalesMap.get(strNum);
                rationalesMap.set(strNum, { ...existing, ...optionMap });
            } else {
                rationalesMap.set(strNum, optionMap);
            }
        }
    });

    return Array.from(rationalesMap, ([number, rationaleMap]) => ({ number, rationaleMap }));
}
function finalizeItem(number, content, rationalesArray) {
    let correctOption = null;
    
    // Extract Answer Key
    const optionMatch = content.match(/Option\s+([A-Z])\s+is\s+correct/i);
    if (optionMatch) correctOption = optionMatch[1];

    // Clean Text for Display
    let cleanExplanation = content
        .replace(/Option\s+[A-Z]\s+is\s+correct/gi, "") 
        .replace(/Option\s+[A-Z]\s+is\s+incorrect/gi, "")
        .replace(/\d+\s*pts?/gi, "") // Remove "2 pts" text
        .replace(/^\d+\s*/, "") // Remove leading numbers
        .replace(/\s+/g, " ")
        .trim();

    if (number && cleanExplanation.length > 0) {
        rationalesArray.push({
            number: number,
            text: cleanExplanation,
            correctOption: correctOption
        });
    }
}
            /**
             * Scans the PDF to create a mapping between TEKS standards and their Reporting Category (RC).
             * This helps categorize questions correctly.
             * @param {pdfjs.PDFDocumentProxy} pdfDoc The loaded PDF document.
             * @returns {Promise<Object>} A map of TEKS codes to RC strings.
             */
      
            async function buildTeksToRcMap(pdfDoc) {
                const map = {};
                // Select the correct regex from our new schema object
                const schema = ParserSchemas[AppState.currentSubject] || ParserSchemas['Biology'];
                const teksRcRegex = schema.teksRcRegex;

                // This regex might not find anything for English, and that's OK.
                // The map will just be empty.
                for (let i = 1; i <= pdfDoc.numPages; i++) {
                    const page = await pdfDoc.getPage(i);
                    const textContent = await page.getTextContent();
                    const text = textContent.items.map(item => item.str).join(' ');
                    const match = text.match(teksRcRegex);
                    if (match) {
                        const teksCode = match[1].trim();
                        const rc = `RC ${match[2].trim()}`;
                        if (!map[teksCode]) {
                            map[teksCode] = rc;
                        }
                    }
                }
                return map;
            }

async function parseAllPages(targetDoc = null, pdfIndex = 0) {
    console.clear();
    console.log(`%c--- PARSING PDF INDEX ${pdfIndex} (Aligned Auto-Crop) ---`, "color: blue; font-weight: bold;");
    
    statusDiv.innerHTML = '<div class="flex items-center justify-center"><div class="loader mr-2"></div>Processing PDF...</div>';

    const questions = [];
    AppState.unparsedPages = 0;
    
    const subjectData = getCurrentSubjectData();
    const docToParse = targetDoc || subjectData.pdfDocs[0];
    const schema = ParserSchemas[AppState.currentSubject] || ParserSchemas['Biology'];

    if (!docToParse) return [];

    let currentPassagePageNum = null; 

    for (let i = 1; i <= docToParse.numPages; i++) {
        const page = await docToParse.getPage(i);
        const textContent = await page.getTextContent();
        const items = textContent.items;
        const pageHeight = page.view[3];
        const pageWidth = page.view[2];
        const pageText = items.map(t => t.str).join(' ');

       if (!pageText.includes("Analysis of Assessed Standards")) {
    // FIX: Check for "Reading" so Grades 3-8 get the 2-panel view
    if (AppState.currentSubject.includes('English') || AppState.currentSubject.includes('Reading')) {
        currentPassagePageNum = i;
        console.log(`Page ${i} identified as Reading/English Passage.`);
    }
    continue; 
}

        // --- 2. HEADER SCAN ---
        const pageDefaults = { teks: null, cluster: null };
        const teksMatch = pageText.match(schema.teksRegex);
        const clusterMatch = pageText.match(schema.clusterMatch);
        if (teksMatch) pageDefaults.teks = teksMatch[1].trim();
        if (clusterMatch) pageDefaults.cluster = clusterMatch[1].trim();

        // --- 3. GLOBAL RIGHT EDGE DETECTION ---
        // Find the "Analysis" header anywhere on the page
        let globalRightX = pageWidth - 25; // Default to full width
        const analysisHeader = items.find(item => item.str.includes(schema.analysisAnchor));
        
        if (analysisHeader) {
            // Lock this X-coordinate for ALL questions on this page
            globalRightX = analysisHeader.transform[4] - 25; 
        }

        // --- 4. VERTICAL SLICING ---
        const startAnchors = items.filter(item => schema.questionStartRegex.test(item.str));
        const endAnchors = items.filter(item => /Correct\s*Answer/i.test(item.str));

        startAnchors.sort((a, b) => b.transform[5] - a.transform[5]);
        endAnchors.sort((a, b) => b.transform[5] - a.transform[5]);

        if (startAnchors.length > 0) {
            for (let qIdx = 0; qIdx < startAnchors.length; qIdx++) {
                const startItem = startAnchors[qIdx];
                const endItem = endAnchors.find(end => end.transform[5] < startItem.transform[5]);

                // --- MATCHED NUMBERS TO AUTO-DETECT ---
                // Original code had +20 and -10. Now matching your detectCropBox:
                const topBound = startItem.transform[5] + startItem.height + 10; 
                // Using +10 here to match your detectCropBox logic exactly
                const bottomBound = endItem ? endItem.transform[5] + 10 : 20;

                // --- APPLY SMART CROP ---
                const leftX = 30; 
                const cropX = leftX / pageWidth;
                const cropY = (pageHeight - topBound) / pageHeight;
                
                // Use the Global Right X
                const cropWidth = (globalRightX - leftX) / pageWidth;
                const cropHeight = (topBound - bottomBound) / pageHeight;

                const smartCropBox = {
                    x: cropX,
                    y: cropY,
                    width: cropWidth,
                    height: cropHeight
                };

                // Filter items for text parsing (using the slightly wider slice to be safe for text)
                // We use a safe buffer for text parsing so we don't miss content that sits on the line
                const slicedItems = items.filter(item => {
                    const y = item.transform[5];
                    return y <= (topBound + 10) && y >= (bottomBound - 10);
                });

                // Pass smartCropBox as the manual override
                const question = parsePageContent(slicedItems, i, page, currentPassagePageNum, pdfIndex, smartCropBox, pageDefaults);
                
                if (question) {
                    if ((!question.answerText || question.answerText.length === 0) && endItem) {
                        const ansMatch = endItem.str.match(/\((.*?)\)/);
                        if (ansMatch) question.answerText = ansMatch[1].split(',').map(s => s.trim());
                    }
                    questions.push(question);
                }
            }
        } else {
            const question = parsePageContent(items, i, page, currentPassagePageNum, pdfIndex, null, pageDefaults);
            if (question) questions.push(question);
        }
    }
    return questions;
}


            /**
             * Extracts the automatic crop box coordinates from a page's text content.
             * @param {Array} items - The text items from a PDF page.
             * @param {pdfjs.PDFPageProxy} page - The PDF page object.
             * @returns {Object|null} A percentage-based crop box object or null.
             */
          // ADD THIS REPLACEMENT FUNCTION
            function detectCropBox(items, page) {
                // Select the correct schema
                const schema = ParserSchemas[AppState.currentSubject] || ParserSchemas['Biology'];

                // Find anchors based on the schema's keywords
                // This is flexible for all subjects now.
                const topAnchorItem = items.find(item => schema.questionStartRegex.test(item.str));
                const analysisAnchor = items.find(item => item.str.includes(schema.analysisAnchor));
                const bottomAnchor = items.find(item => item.str.includes(schema.bottomAnchor));

                if (topAnchorItem && analysisAnchor && bottomAnchor) {
                    const pageHeight = page.view[3];
                    const pageWidth = page.view[2];

                    const leftX = 30; // Must be positive to be a valid coordinate
                    const rightX = analysisAnchor.transform[4] - 25;
                    const topY_fromBottom = topAnchorItem.transform[5] + topAnchorItem.height + 10;
                    const bottomY_fromBottom = bottomAnchor.transform[5] + 10;
                    const cropX = leftX / pageWidth;
                    const cropY = (pageHeight - topY_fromBottom) / pageHeight;
                    const cropWidth = (rightX - leftX) / pageWidth;
                    const cropHeight = (topY_fromBottom - bottomY_fromBottom) / pageHeight;
                    
                    if (cropWidth > 0 && cropHeight > 0 && cropX >= 0 && cropY >= 0) {
                        return { x: cropX, y: cropY, width: cropWidth, height: cropHeight };
                    }
                }
                return null;
            }
            
            /**
             * Parses the text content of a single PDF page to extract question details.
             * @param {Array} items The text items from a PDF page.
             * @param {number} pageNum The page number.
             * @param {pdfjs.PDFPageProxy} page The PDF page object.
             * @returns {Object|null} A question object or null if parsing fails.
             */


function parsePageContent(items, pageNum, page, currentPassagePageNum, pdfIndex = 0, manualCropBox = null, pageDefaults = {}) { 
    try {
        const text = items.map(i => i.str).join(' ');

        // 1. Metadata
        const schema = ParserSchemas[AppState.currentSubject] || ParserSchemas['Biology'];
        const yearMatch = text.match(schema.questionStartRegex);
        if (!yearMatch) return null; 

        const teksMatch = text.match(schema.teksRegex);
        const itemTypeMatch = text.match(schema.itemTypeMatch);
        const clusterMatch = text.match(schema.clusterMatch);
        const rcMatchOnPage = text.match(/RC\s*(\d+)/);
        const questionIdMatch = text.match(schema.questionIdRegex);
        const questionNum = questionIdMatch ? questionIdMatch[1] : `P${pageNum}`;
        
        let teksCode = teksMatch ? teksMatch[1].trim() : (pageDefaults.teks || 'NEEDS_REVIEW');
        let teksDescription = teksMatch ? teksMatch[2].trim().replace(/\s+/g, ' ') : 'See Standard Description';
        let cluster = clusterMatch ? clusterMatch[1].trim().replace(/\n/g, ' ') : (pageDefaults.cluster || 'Uncategorized');
        let reportingCategory = rcMatchOnPage ? `RC ${rcMatchOnPage[1]}` : (getCurrentSubjectData().teksToRcMap[teksCode] || null);
        let itemType = itemTypeMatch ? itemTypeMatch[1].trim().replace(/\n/g, ' ') : 'Multiple Choice (1 pt)';
        let needsReview = (teksCode === 'NEEDS_REVIEW');

        // 2. Answers
        let answerText = null, dragAndDropAnswers = null, hotspotAnswer = null, textEntryAnswer = null, inlineChoiceAnswer = null, graphingAnswer = null;
        const correctAnsMatch = text.match(/\*?\s*Correct\s*Answer\s*[:]?\s*\((.*?)\)/i);
        const typeLower = itemType.toLowerCase();

        if (correctAnsMatch && correctAnsMatch[1]) {
            const answerString = correctAnsMatch[1];
            if (typeLower.includes('multiple choice') || typeLower.includes('multipart') || typeLower.includes('multiselect')) {
                answerText = answerString.split(',').map(s => s.trim());
            } else if (typeLower.includes('hot spot')) {
                hotspotAnswer = answerString.trim();
                needsReview = true;
            } else if (typeLower.includes('drag and drop')) {
                dragAndDropAnswers = answerString.split(/[,;]/).map(s => s.replace(/\[.*?\]\s*/g, '').trim());
                needsReview = true;
            } else if (typeLower.includes('inline choice')) {
                inlineChoiceAnswer = answerString.split(/[;]/).map(s => s.trim());
            } else if (typeLower.includes('graphing')) {
                 graphingAnswer = answerString.match(/\(-?\d+,\s*-?\d+\)/g);
            } else if (typeLower.includes('short constructed response') || typeLower.includes('text entry') || typeLower.includes('equation editor')) {
                textEntryAnswer = answerString.trim();
                if (textEntryAnswer.toLowerCase().includes('scoring guide')) {
                    textEntryAnswer = "Enter correct answer in review mode."; 
                    needsReview = true;
                }
            }
        } else {
             if (!typeLower.includes('hot spot') && !typeLower.includes('drag and drop')) needsReview = true;
        }

        // --- 3. CROP PRIORITY FIX ---
        // Priority 1: Run Auto-Detect ("Tight Crop") on the items provided.
        let cropBox = detectCropBox(items, page);

        // Priority 2: If Auto-Detect fails (returns null), use the Manual Slice ("Rough Crop").
        if (!cropBox && manualCropBox) {
             cropBox = manualCropBox;
        }
        // ---------------------------

        // 4. Difficulty
        let stateCorrectPct = null;
        let difficulty = 'Unrated';
        let targetLabel = "Full Credit"; 
        if (answerText && answerText.length > 0) {
             const rawLetter = answerText[0];
             const letterMatch = rawLetter.match(/\b([A-HJ-K])\b/); 
             targetLabel = letterMatch ? letterMatch[1] : rawLetter.charAt(0);
        }
        const dataAnalysisIndex = items.findIndex(i => i.str.includes('Data Analysis'));
        if (dataAnalysisIndex !== -1) {
            for (let i = dataAnalysisIndex; i < Math.min(items.length, dataAnalysisIndex + 100); i++) {
                const str = items[i].str.trim().replace('*', ''); 
                if (str.toUpperCase() === targetLabel.toUpperCase()) {
                    for (let j = 1; j <= 4; j++) {
                        if (i + j >= items.length) break;
                        const potentialNumStr = items[i+j].str.trim();
                        if (/^\d+$/.test(potentialNumStr)) {
                            const num = parseInt(potentialNumStr, 10);
                            if (num >= 0 && num <= 100) {
                                stateCorrectPct = num;
                                break; 
                            }
                        }
                    }
                }
                if (stateCorrectPct !== null) break; 
            }
        }
        if (stateCorrectPct !== null) {
            const settings = AppState.difficultySettings || { mastersThreshold: 40, meetsThreshold: 65 };
            if (stateCorrectPct < settings.mastersThreshold) difficulty = 'Masters';
            else if (stateCorrectPct < settings.meetsThreshold) difficulty = 'Meets';
            else difficulty = 'Approaches';
        }

        return {
            id: `${yearMatch[1]}-${questionNum}`, year: yearMatch[1], teks: teksCode,
            teksDescription: teksDescription,
            reportingCategory: reportingCategory,
            cluster: cluster,
            answerText, dragAndDropAnswers, hotspotAnswer, textEntryAnswer, inlineChoiceAnswer, graphingAnswer,
            itemType, pageNum, cropBox, explanation: '',
            interactiveZones: [], 
            draggableOptions: dragAndDropAnswers ? [...new Set(dragAndDropAnswers)] : [],
            needsReview: needsReview,
            passagePageNums: currentPassagePageNum ? [currentPassagePageNum] : [], 
            pageDimensions: { width: page.view[2], height: page.view[3] },
            rawItems: items,
            stateCorrectPct: stateCorrectPct,
            difficulty: difficulty,
            pdfIndex: pdfIndex
        };
    } catch (e) {
        console.error("Error in parsePageContent:", e, items);
        return null;
    }
}

           /**
 * Toggles the dashboard view between Cluster, Year, and the new Zone view.
 */
function toggleDashboardView() {
    const modes = ['cluster', 'year', 'zone'];
    const currentMode = AppState.dashboardViewMode || 'cluster';
    const nextIndex = (modes.indexOf(currentMode) + 1) % modes.length;
    
    AppState.dashboardViewMode = modes[nextIndex];
    
    // Update button text based on the new mode
    const labels = {
        'cluster': 'Group by: Cluster',
        'year': 'Group by: Year',
        'zone': 'View: Student Zones üöÄ'
    };
    viewToggleBtn.textContent = labels[AppState.dashboardViewMode];
    
    renderDashboard();
}

function renderDashboard() {
    const subjectData = getCurrentSubjectData();
    // Default to 'cluster' if no mode is set
    const currentMode = AppState.dashboardViewMode || 'cluster';

    // 1. DYNAMIC LAYOUT SWITCHING (Immersive Mode)
    const sidebar = document.getElementById('dashboard-sidebar');
    
    // FIX: Changed ID from 'dashboard-content' to 'pathway-display'
    const content = document.getElementById('pathway-display'); 

    if (currentMode === 'cluster') {
        // --- Standard View (Sidebar Visible) ---
        if (sidebar) sidebar.classList.remove('hidden');
        if (content) {
            content.classList.remove('lg:col-span-12');
            // This forces the content to take up the remaining width
            content.classList.add('lg:col-span-8'); 
            content.classList.add('w-full'); // Ensure it takes full available width
        }
    } else {
        // --- Immersive View (Sidebar Hidden for Full Width) ---
        if (sidebar) sidebar.classList.add('hidden');
        if (content) {
            content.classList.remove('lg:col-span-8');
            content.classList.add('lg:col-span-12');
            content.classList.add('w-full');
        }
    }

    // 2. CLEAR OLD CONTENT
    content.innerHTML = ''; // Ensure we are clearing the correct element
    const placeholderView = document.getElementById('placeholder-view');
    if(placeholderView) placeholderView.classList.add('hidden');
    
    if (!subjectData || subjectData.allQuestions.length === 0) {
        if(placeholderView) placeholderView.classList.remove('hidden');
        return;
    }

    // 3. GLOBAL TOOLBAR
    const toolbar = document.createElement('div');
    toolbar.className = "sticky top-0 z-30 bg-white border-b border-gray-200 shadow-sm mb-6 -mx-6 px-6 py-4 flex flex-col sm:flex-row gap-4 items-center justify-between";
    
    // LEFT SIDE: View Selector + Sidebar Toggle
    const leftGroup = document.createElement('div');
    leftGroup.className = "flex items-center gap-3 w-full sm:w-auto";
    
    // Toggle Button: Only needed if we are NOT in standard Cluster view
    if (currentMode !== 'cluster') {
        const toggleBtn = document.createElement('button');
        toggleBtn.className = "p-2 bg-gray-100 text-gray-600 rounded-lg hover:bg-gray-200 border border-gray-300 transition-colors";
        toggleBtn.innerHTML = "‚öôÔ∏è"; // Gear icon
        toggleBtn.title = "Toggle Sidebar Controls";
        toggleBtn.onclick = () => {
            // Slide sidebar in/out
            sidebar.classList.toggle('hidden');
            // Adjust width of content column accordingly
            if (sidebar.classList.contains('hidden')) {
                content.classList.remove('lg:col-span-8');
                content.classList.add('lg:col-span-12');
            } else {
                content.classList.remove('lg:col-span-12');
                content.classList.add('lg:col-span-8');
            }
        };
        leftGroup.appendChild(toggleBtn);
    }

    const viewLabel = document.createElement('span');
    viewLabel.className = "text-xs font-bold text-gray-500 uppercase tracking-wider hidden sm:inline";
    viewLabel.textContent = "MODE:";
    
    const viewSelect = document.createElement('select');
    viewSelect.className = "p-2 pl-3 pr-8 border border-gray-300 rounded-lg text-sm font-bold text-gray-700 focus:ring-2 focus:ring-indigo-500 outline-none cursor-pointer bg-white shadow-sm w-full sm:w-auto";
    
    viewSelect.innerHTML = `
        <option value="zone">üöÄ Student Zones (Map)</option>
        <option value="blueprint">üìä Strategy Blueprint (Analysis)</option>
        <option value="cluster">üìÇ Clusters (Folder View)</option>
    `;
    viewSelect.value = currentMode;
    viewSelect.onchange = (e) => {
        AppState.dashboardViewMode = e.target.value;
        renderDashboard(); 
    };
    
    leftGroup.appendChild(viewLabel);
    leftGroup.appendChild(viewSelect);
    toolbar.appendChild(leftGroup);

    // RIGHT SIDE: Year Filter
    const filterGroup = document.createElement('div');
    filterGroup.className = "flex items-center gap-3 w-full sm:w-auto justify-end";
    const years = [...new Set(subjectData.allQuestions.map(q => q.year).filter(y => y))].sort((a, b) => b - a);
    const yearSelect = document.createElement('select');
    yearSelect.className = "p-2 border border-gray-300 rounded-lg text-sm font-semibold text-indigo-800 bg-indigo-50 hover:bg-white transition-colors cursor-pointer outline-none focus:ring-2 focus:ring-indigo-500";
    
    const allOption = document.createElement('option');
    allOption.value = 'All';
    allOption.textContent = 'üìÖ All Years';
    yearSelect.appendChild(allOption);
    
    years.forEach(y => {
        const opt = document.createElement('option');
        opt.value = y;
        opt.textContent = `${y} Exam`;
        yearSelect.appendChild(opt);
    });
    
    if (!AppState.dashboardYearFilter) AppState.dashboardYearFilter = 'All';
    yearSelect.value = AppState.dashboardYearFilter;
    yearSelect.onchange = (e) => {
        AppState.dashboardYearFilter = e.target.value;
        renderDashboard();
    };
    filterGroup.appendChild(yearSelect);
    
    toolbar.appendChild(filterGroup);
    content.appendChild(toolbar); // Changed from pathwayDisplay to content

    // 4. MAIN CONTENT CONTAINER
    const contentContainer = document.createElement('div');
    contentContainer.id = "dashboard-inner-content";
    contentContainer.className = "animate-fade-in"; 
    content.appendChild(contentContainer); // Changed from pathwayDisplay to content

    // RENDER CUSTOM PATHWAYS
    if (subjectData.customPathways && subjectData.customPathways.length > 0) {
        const customSection = document.createElement('div');
        customSection.className = "mb-8 space-y-4";
        customSection.innerHTML = `
            <div class="flex items-center gap-2 border-b border-indigo-100 pb-2 mb-4">
                <span class="text-xl">‚ö°</span>
                <h2 class="text-xl font-bold text-indigo-900">Your Custom Pathways</h2>
            </div>
        `;
        subjectData.customPathways.forEach(pathway => {
            const row = createCustomPathwayRow(pathway);
            if (row) customSection.appendChild(row);
        });
        contentContainer.appendChild(customSection);
    }

    // 5. ROUTER
    if (currentMode === 'blueprint') {
        renderDashboardByBlueprint(contentContainer);
    } else if (currentMode === 'zone') {
        renderDashboardByZone(contentContainer);
    } else {
        renderDashboardByCluster(contentContainer);
    }
}


/**
 * Renders the "Gauntlet" Map View with Satellite Rings.
 * Features: Orbiting question boxes that show individual status (Green/Red/Gray).
 */
function renderDashboardByZone(container) {
    const subjectData = getCurrentSubjectData();
    const questions = subjectData.allQuestions;

    // 1. Safety Check
    if (!questions || questions.length === 0) {
        container.innerHTML = `<div class="p-12 text-center text-gray-500 italic">No questions found. Upload a PDF to generate the Gauntlet.</div>`;
        return;
    }

    // 2. Generate Data Structure (Cluster -> TEKS -> Questions)
    const blueprint = generateDynamicZones(questions);

    // 3. Render Header
    container.innerHTML = `
        <div class="mb-10 text-center animate-fade-in">
            <h2 class="text-4xl font-extrabold text-transparent bg-clip-text bg-gradient-to-r from-indigo-600 to-purple-600 mb-2" 
                style="background-image: var(--theme-gradient);">
                The Gauntlet: ${AppState.currentSubject}
            </h2>
            <p class="text-gray-600 text-lg font-medium">Complete the satellites to master the islands.</p>
        </div>
    `;

    const mapContainer = document.createElement('div');
    mapContainer.className = "map-container space-y-16 pb-20";

    // 4. Render Islands (Clusters)
    blueprint.topics.forEach((topic) => {
        const island = document.createElement('div');
        island.className = "map-island relative bg-white/60 backdrop-blur-sm border-2 border-dashed border-gray-300 rounded-[2.5rem] p-8 transition-all hover:border-indigo-400 hover:shadow-xl hover:bg-white/90";
        
        // Island Title (Floating Badge)
        island.innerHTML = `
            <div class="absolute -top-6 left-8 bg-white border border-gray-200 text-gray-800 px-6 py-2 rounded-2xl shadow-md font-bold text-xl flex items-center gap-3 z-10">
                <span class="text-2xl">üèùÔ∏è</span> ${topic.title}
            </div>
        `;

        // The Path Container
        const pathContainer = document.createElement('div');
        pathContainer.className = "level-path flex flex-wrap items-center justify-start gap-12 mt-8 pl-4";

        // 5. Render TEKS Nodes
        topic.skills.forEach((sub) => {
            
            // Bucket Questions by Difficulty
            const buckets = {
                'Approaches': [],
                'Meets': [],
                'Masters': []
            };

            sub.questions.forEach(q => {
                const diff = (q.difficulty || 'Unrated').toLowerCase();
                if (diff.includes('approaches')) buckets['Approaches'].push(q);
                else if (diff.includes('meets')) buckets['Meets'].push(q);
                else buckets['Masters'].push(q); 
            });

            const levels = [
                { name: 'Approaches', color: 'border-green-400', bg: 'bg-green-50', icon: 'üå±', questions: buckets['Approaches'] },
                { name: 'Meets',      color: 'border-blue-400',  bg: 'bg-blue-50',  icon: 'üöÄ', questions: buckets['Meets'] },
                { name: 'Masters',    color: 'border-purple-400', bg: 'bg-purple-50', icon: 'üëë', questions: buckets['Masters'] }
            ];

            // Render levels that have questions
            levels.forEach((lvl) => {
                if (lvl.questions.length === 0) return; 

                // --- NEW: Generate the Satellite Ring Node ---
                const ringNode = renderSatelliteRing(lvl, sub.teks);
                pathContainer.appendChild(ringNode);
                
                // Add connector line visually
                const connector = document.createElement('div');
                connector.className = "path-connector w-8 h-1 bg-gray-300 opacity-50 hidden sm:block"; // Hide on mobile
                pathContainer.appendChild(connector);
            });
        });

        // Clean up last connector
        if (pathContainer.lastChild && pathContainer.lastChild.classList.contains('path-connector')) {
            pathContainer.lastChild.remove();
        }

        island.appendChild(pathContainer);
        mapContainer.appendChild(island);
    });

    container.appendChild(mapContainer);
}


function renderSatelliteRing(levelData, teksName) {
    const { name, color, bg, icon, questions } = levelData;
    const subjectData = getCurrentSubjectData();

    // 1. Main Container (The Solar System)
    const container = document.createElement('div');
    container.className = "relative w-32 h-32 flex items-center justify-center flex-shrink-0 group z-10"; 

    // --- NEW: The Visual Orbit Track (Dashed Circle) ---
    // This grounds the satellites so they don't look like they are floating randomly
    const orbitTrack = document.createElement('div');
    orbitTrack.className = "absolute w-28 h-28 border-2 border-dashed border-gray-300 rounded-full opacity-50 pointer-events-none";
    container.appendChild(orbitTrack);

    // 2. The Planet (Center Button)
    const planet = document.createElement('button');
    planet.className = `w-16 h-16 rounded-full border-4 ${color} ${bg} flex flex-col items-center justify-center shadow-md z-20 transition-transform hover:scale-110 relative`;
    planet.innerHTML = `
        <div class="text-xl">${icon}</div>
        <div class="text-[8px] font-bold uppercase mt-1 tracking-widest">${name}</div>
    `;
    
    // Clicking Planet = Start All / Practice All for this level
    planet.onclick = () => startPathway(`${teksName} (${name})`, questions, { isQuiz: false });

    // 3. The Satellites (Orbiting Questions)
    const radius = 56; // Distance from center
    const count = questions.length;
    
    // --- UPDATED MATH: Better angles for small numbers ---
    let startAngle = -90; // Default top
    let angleStep = 360 / count;

    // Special Case: If there are exactly 2 items, place them Left (-180) and Right (0)
    // instead of Top (-90) and Bottom (90)
    if (count === 2) {
        startAngle = 180; // Start Left
        angleStep = 180;  // Jump to Right
    } 
    // Special Case: If 4 items, rotate 45deg so they are corners (X shape) instead of + shape
    else if (count === 4) {
        startAngle = -45;
    }

    questions.forEach((q, localIndex) => {
        const satellite = document.createElement('button');
        
        // Position Math
        const angle = startAngle + (localIndex * angleStep); 
        const rad = angle * (Math.PI / 180);
        const x = Math.cos(rad) * radius;
        const y = Math.sin(rad) * radius;

        // Default Status: Gray
        let statusClass = "bg-gray-100 border-gray-300 text-gray-500"; 
        let content = `${localIndex + 1}`;

        // Check Status (Using safe lookup)
        const allTeksQuestions = subjectData.allQuestions.filter(qm => qm.teks === teksName);
        const trueIndex = allTeksQuestions.findIndex(tq => tq.id === q.id);
        
        if (subjectData.masteryState[teksName] && subjectData.masteryState[teksName][trueIndex] !== undefined) {
            const score = subjectData.masteryState[teksName][trueIndex];
            const max = getQuestionPointsPossible(q);
            
            if (score === max) {
                 statusClass = "bg-green-100 border-green-500 text-green-700 shadow-sm";
                 content = "‚úî";
            } else if (score > 0) {
                 statusClass = "bg-yellow-100 border-yellow-500 text-yellow-700 shadow-sm";
            } else if (score === 0) { // Explicit 0 means incorrect
                 statusClass = "bg-red-100 border-red-500 text-red-700 shadow-sm";
            }
        }

        satellite.className = `absolute w-8 h-8 rounded-full border-2 flex items-center justify-center text-xs font-bold transition-all hover:scale-125 z-30 ${statusClass}`;
        satellite.style.transform = `translate(${x}px, ${y}px)`;
        satellite.innerHTML = content;
        satellite.title = `Question ${localIndex + 1}`;

        // CLICK: Launch ONLY this question
        satellite.onclick = (e) => {
            e.stopPropagation(); 
            startPathway(`Review: ${teksName} Q${localIndex + 1}`, [q], { isQuiz: false });
        };

        container.appendChild(satellite);
    });

    // 4. Hover Info Card
    const infoCard = document.createElement('div');
    infoCard.className = "absolute -bottom-16 opacity-0 group-hover:opacity-100 transition-opacity bg-gray-900 text-white text-xs p-2 rounded-lg w-40 text-center pointer-events-none z-50";
    infoCard.innerHTML = `<span class="font-bold text-yellow-400">${name}</span><br>${questions.length} Questions`;
    container.appendChild(infoCard);

    container.appendChild(planet);
    return container;
}

function generateDynamicZones(questions) {
    const topicMap = {};
    const processSkillsMap = new Map();

    questions.forEach(q => {
        const rawDesc = q.teksDescription || "";
        const teksCode = q.teks || "General";
        const cleanDesc = cleanICan(rawDesc);

        // 1. Process Skills (Visual only - doesn't hide anything)
        if (rawDesc.match(/analyze|evaluate|investigate|infer|demonstrate|plan|conduct/i)) {
            if (!processSkillsMap.has(teksCode)) {
                processSkillsMap.set(teksCode, {
                    teks: teksCode,
                    description: cleanDesc
                });
            }
        }

        // 2. THE FIX: RAW DATA ONLY
        // We use whatever is in the Cluster field. Period.
        let topicTitle = q.cluster; 
        
        // Fallback only if strictly empty
        if (!topicTitle || topicTitle.trim() === "") {
             topicTitle = q.reportingCategory || "General Topics";
        }

        // 3. BUILD DATA STRUCTURE
        if (!topicMap[topicTitle]) {
            topicMap[topicTitle] = {
                title: topicTitle,
                subskills: {}
            };
        }

        if (!topicMap[topicTitle].subskills[teksCode]) {
            topicMap[topicTitle].subskills[teksCode] = {
                teks: teksCode,
                description: cleanDesc,
                questions: []
            };
        }
        // Always push the question. Never drop it.
        topicMap[topicTitle].subskills[teksCode].questions.push(q);
    });

    // 4. FORMAT OUTPUT
    const topicsArray = Object.values(topicMap).map(t => {
        const skillsArray = Object.values(t.subskills);
        const totalQs = skillsArray.reduce((acc, s) => acc + s.questions.length, 0);
        
        return {
            title: t.title,
            totalQuestions: totalQs,
            skills: skillsArray.sort((a,b) => a.teks.localeCompare(b.teks))
        };
    });

    // Simple Sort A-Z
    topicsArray.sort((a, b) => a.title.localeCompare(b.title));

    return {
        topics: topicsArray,
        processSkills: Array.from(processSkillsMap.values())
    };
}

/**
 * 2. cleanICan
 * Converts official TEKS text into student-friendly "I Can" statements.
 */
function cleanICan(text) {
    if(!text) return "I can demonstrate mastery of this standard.";
    let clean = text.trim();
    // Replace typical TEKS prefixes
    clean = clean.replace(/^The student is expected to /i, "I can ");
    clean = clean.replace(/^The student /i, "I ");
    // Capitalize first letter if needed
    return clean.charAt(0).toUpperCase() + clean.slice(1);
}

/**
 * 3. calculateMastery (FIXED VERSION)
 * Calculates stats for the progress bars using the Global Index.
 */
function calculateMastery(questions, teksName) {
    const subjectData = getCurrentSubjectData();
    // specific TEKS mastery state or general mastery array?
    // We default to the main mastery array for the subject
    const masteryState = subjectData.mastery || []; 

    let score = 0;
    let possible = 0;
    let attempted = 0;

    questions.forEach((q) => {
        // CRITICAL FIX: Find the question's actual index in the main list
        // This ensures we get the correct status even when questions are re-ordered
        const globalIndex = subjectData.allQuestions.indexOf(q);
        
        if (globalIndex === -1) return; // Safety check

        const pts = getQuestionPointsPossible(q);
        possible += pts;

        const status = masteryState[globalIndex]; 
        
        if (status !== undefined && status !== 'not-started' && status !== null) {
            attempted++;
            if (typeof status === 'number') score += status;
            else if (status === 'correct') score += pts;
        }
    });

    const percent = possible === 0 ? 0 : Math.round((score / possible) * 100);

    return { score, possible, attempted, percent };
}

/**
 * Displays the Test Blueprint Modal (Ranked Analysis) with Year Filtering.
 */
function showBlueprintModal() {
    const subjectData = getCurrentSubjectData();
    const allQuestions = subjectData.allQuestions;
    const currentSubject = AppState.currentSubject;

    // 1. Extract Unique Years & Sort (Newest First)
    // We filter out undefined/null years just in case
    const years = [...new Set(allQuestions.map(q => q.year).filter(y => y))].sort((a, b) => b - a);
    
    // Default to the latest year, or 'All' if no years detected
    let activeYear = years.length > 0 ? years[0] : 'All';

    // Helper: Function to Calculate & Render the Content div
    const renderContent = (targetYear) => {
        // Filter Data
        let dataset = allQuestions;
        if (targetYear !== 'All') {
            dataset = allQuestions.filter(q => q.year == targetYear);
        }
        
        const total = dataset.length || 1;
        const rcCounts = {};
        const clusterCounts = {};
        const teksCounts = {};

        dataset.forEach(q => {
            const rc = q.reportingCategory || 'Uncategorized';
            const cluster = q.cluster || 'General';
            const teks = q.teks || 'Unknown';

            rcCounts[rc] = (rcCounts[rc] || 0) + 1;
            clusterCounts[cluster] = (clusterCounts[cluster] || 0) + 1;
            teksCounts[teks] = (teksCounts[teks] || 0) + 1;
        });

        // Generate HTML for Sections
        
        // SECTION 1: REPORTING CATEGORIES
        const rcHTML = Object.entries(rcCounts)
            .sort((a,b) => b[1] - a[1])
            .map(([rc, count]) => {
                const pct = Math.round((count/total)*100);
                const shortRC = rc.match(/RC\s*\d+/); 
                const rcKey = shortRC ? shortRC[0] : rc;
                const displayName = (RCNames[currentSubject] && RCNames[currentSubject][rcKey]) 
                                    ? RCNames[currentSubject][rcKey] 
                                    : rc.replace(/^RC\s*\d+\s*/, '');
                
                return `
                <div class="mb-3">
                    <div class="flex justify-between text-sm font-bold text-gray-700 mb-1">
                        <span>${displayName}</span>
                        <span>${count} Qs (${pct}%)</span>
                    </div>
                    <div class="w-full bg-gray-100 rounded-full h-4 overflow-hidden">
                        <div class="bg-indigo-500 h-4 rounded-full" style="width: ${pct}%"></div>
                    </div>
                </div>`;
            }).join('');

        // SECTION 2: CLUSTERS
        const clusterHTML = Object.entries(clusterCounts)
            .sort((a,b) => b[1] - a[1])
            .map(([cluster, count], index) => {
                const isTop3 = index < 3;
                return `
                <div class="flex items-center justify-between p-3 rounded-lg border ${isTop3 ? 'bg-orange-50 border-orange-200 shadow-sm' : 'bg-white border-gray-100'}">
                    <div class="flex items-center gap-3">
                        <span class="font-mono text-sm font-bold text-gray-400">#${index+1}</span>
                        <span class="font-medium text-gray-800 text-sm line-clamp-1" title="${cluster}">${cluster}</span>
                    </div>
                    <div class="flex items-center gap-2">
                        ${isTop3 ? '<span class="text-xs">üî•</span>' : ''}
                        <span class="font-bold text-gray-600 text-sm">${count}</span>
                    </div>
                </div>`;
            }).join('');

        // SECTION 3: TEKS LEADERBOARD
        const teksHTML = Object.entries(teksCounts)
            .sort((a,b) => b[1] - a[1])
            .map(([teks, count], index) => {
                const isTop10 = index < 10;
                const bgClass = isTop10 ? 'bg-yellow-50 border-yellow-300 ring-1 ring-yellow-200' : 'bg-white border-gray-200';
                const textClass = isTop10 ? 'text-yellow-800' : 'text-gray-600';
                
                return `
                <div class="flex flex-col items-center justify-center p-3 rounded-lg border ${bgClass} text-center relative overflow-hidden">
                    ${isTop10 ? `<div class="absolute top-0 right-0 bg-yellow-400 text-white text-[10px] font-bold px-1.5 rounded-bl">#${index+1}</div>` : ''}
                    <span class="text-lg font-bold ${textClass}">${teks}</span>
                    <span class="text-xs text-gray-400 font-medium">${count} Qs</span>
                </div>`;
            }).join('');

        return `
            <section>
                <h3 class="text-lg font-bold text-indigo-700 mb-4 border-b pb-2">1. Reporting Categories (${targetYear})</h3>
                <div class="space-y-2">${rcHTML}</div>
            </section>

            <section>
                <h3 class="text-lg font-bold text-orange-700 mb-4 border-b pb-2">2. Clusters Ranked (${targetYear})</h3>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-3">${clusterHTML}</div>
            </section>

            <section>
                <h3 class="text-lg font-bold text-green-700 mb-4 border-b pb-2">3. TEKS Leaderboard (${targetYear})</h3>
                <div class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-3">${teksHTML}</div>
            </section>
        `;
    };

    // 3. Build Modal Shell
    const modalId = 'blueprint-modal';
    document.getElementById(modalId)?.remove(); 

    const yearOptions = years.map(y => `<option value="${y}" ${y == activeYear ? 'selected' : ''}>${y} Exam</option>`).join('');
    // Add an 'All Years' option at the end
    const allOption = `<option value="All">Aggregate (All Years)</option>`;

    const modalHtml = `
        <div id="${modalId}" class="fixed inset-0 bg-gray-900 bg-opacity-50 flex items-center justify-center p-4 z-50 backdrop-blur-sm">
            <div class="bg-white rounded-xl shadow-2xl w-full max-w-4xl max-h-[90vh] flex flex-col overflow-hidden">
                <div class="p-6 border-b flex flex-col sm:flex-row justify-between items-center bg-gray-50 gap-4">
                    <div>
                        <h2 class="text-2xl font-bold text-gray-800">Test Blueprint Analysis</h2>
                        <p class="text-sm text-gray-500">Breakdown of Reporting Categories, Clusters, and TEKS.</p>
                    </div>
                    
                    <div class="flex items-center gap-3">
                        <label class="text-sm font-bold text-gray-600 uppercase">Analyzing:</label>
                        <select id="blueprint-year-select" class="p-2 border border-indigo-300 rounded-lg text-indigo-800 font-bold bg-indigo-50 hover:bg-white transition-colors cursor-pointer focus:ring-2 focus:ring-indigo-500 outline-none">
                            ${yearOptions}
                            ${allOption}
                        </select>
                        <button onclick="document.getElementById('${modalId}').remove()" class="text-gray-400 hover:text-gray-700 text-2xl font-bold ml-4">&times;</button>
                    </div>
                </div>
                
                <div id="blueprint-content" class="p-6 overflow-y-auto space-y-8 custom-scrollbar">
                    ${renderContent(activeYear)}
                </div>
                
                <div class="p-4 border-t bg-gray-50 flex justify-end">
                    <button onclick="document.getElementById('${modalId}').remove()" class="px-6 py-2 bg-gray-800 text-white font-bold rounded-lg hover:bg-gray-700">Close Analysis</button>
                </div>
            </div>
        </div>
    `;

    document.body.insertAdjacentHTML('beforeend', modalHtml);

    // 4. Attach Event Listener for Switching Years
    document.getElementById('blueprint-year-select').addEventListener('change', (e) => {
        const newYear = e.target.value;
        const contentDiv = document.getElementById('blueprint-content');
        contentDiv.innerHTML = renderContent(newYear);
    });
}
      /**
 * Creates a single row in the dashboard for a TEKS standard.
 * FIX: Updated status display logic to handle numerical scores.
 * @param {string} teksName The name of the TEKS.
 * @param {Array<Object>} questions An array of questions for that TEKS.
 * @returns {HTMLElement} The created row element.
 */
function createTeksRow(teksName, questions) {
    const subjectData = getCurrentSubjectData();
    if (!subjectData.masteryState[teksName]) {
        subjectData.masteryState[teksName] = {};
        questions.forEach((_, i) => subjectData.masteryState[teksName][i] = 'not-started');
    }
    const teksRow = document.createElement('div');
    teksRow.className = 'p-4 rounded-lg border bg-gray-50 my-2 pathway-card';
    teksRow.dataset.teksId = teksName;
    
    const pathwayNeedsReview = questions.some(q => q.needsReview);
    const reviewIconHTML = pathwayNeedsReview ? `<span title="Some questions in this pathway need teacher setup." class="ml-2 text-yellow-500 font-bold">‚ö†Ô∏è</span>` : '';

    const progressMade = Object.values(subjectData.masteryState[teksName]).some(s => s !== 'not-started');
    const resetBtnHTML = progressMade ? `<button class="reset-pathway-btn text-xs text-red-500 hover:underline">Reset</button>` : '';

    // --- NEW: "I CAN" STATEMENT LOGIC ---
    // Get the description from the first question, or default if missing
    const rawDesc = questions[0]?.teksDescription || "";
    // Clean it up (e.g., "The student is expected to..." -> "I can...")
    const friendlyDesc = cleanICan(rawDesc); 
    // ------------------------------------

    teksRow.innerHTML = `
        <div class="flex justify-between items-start">
            <div class="flex-grow">
                <p class="font-semibold flex items-center flex-wrap teks-title text-lg">
                    ${teksName} 
                    ${reviewIconHTML}
                    <span class="text-sm font-normal text-gray-600 ml-0 sm:ml-2 w-full sm:w-auto block sm:inline mt-1 sm:mt-0">
                        ‚Äî ${friendlyDesc}
                    </span>
                </p>
            </div>
            <div class="ml-4 whitespace-nowrap">
                ${resetBtnHTML}
            </div>
        </div>
        <div class="flex flex-col sm:flex-row space-y-2 sm:space-y-0 sm:space-x-2 mt-4">
            <button class="practice-pathway-btn icon-btn flex-1 px-3 py-2 bg-green-600 text-white text-sm font-semibold rounded-md hover:bg-green-700 transition-all">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M10.804 8 5 4.633v6.734L10.804 8zm.792-.696a.802.802 0 0 1 0 1.392l-6.363 3.692C4.713 12.69 4 12.345 4 11.692V4.308c0-.653.713-.998 1.233-.696l6.363 3.692z"/></svg>
                <span>Practice Pathway</span>
            </button>
            <button class="start-quiz-btn icon-btn flex-1 px-3 py-2 bg-blue-600 text-white text-sm font-semibold rounded-md hover:bg-blue-700 transition-all">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-stopwatch" viewBox="0 0 16 16"><path d="M8.5 5.6a.5.5 0 1 0-1 0v2.9h-3a.5.5 0 0 0 0 1H8a.5.5 0 0 0 .5-.5V5.6z"/><path d="M6.5 1A.5.5 0 0 1 7 .5h2a.5.5 0 0 1 0 1v.57c1.36.196 2.594.78 3.584 1.64a.715.715 0 0 1 .012-.013l.354-.354-.354-.353a.5.5 0 0 1 .707-.707l1.414 1.415a.5.5 0 1 1-.707.707l-.353-.354-.354.354a.715.715 0 0 1-.013.012A7.001 7.001 0 0 1 7 2.071V1.5a.5.5 0 0 1-.5-.5zM8 3a6 6 0 1 0 .001 12A6 6 0 0 0 8 3z"/></svg>
                <span>Start Quiz</span>
            </button>
            <button class="review-btn icon-btn flex-1 px-3 py-2 bg-gray-200 text-gray-700 text-sm font-semibold rounded-md hover:bg-gray-300 transition-all">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M15.502 1.94a.5.5 0 0 1 0 .706L14.459 3.69l-2-2L13.502.646a.5.5 0 0 1 .707 0l1.293 1.293zm-1.75 2.456-2-2L4.939 9.21a.5.5 0 0 0-.121.196l-.805 2.414a.25.25 0 0 0 .316.316l2.414-.805a.5.5 0 0 0 .196-.12l6.813-6.814z"/><path fill-rule="evenodd" d="M1 13.5A1.5 1.5 0 0 0 2.5 15h11a1.5 1.5 0 0 0 1.5-1.5v-6a.5.5 0 0 0-1 0v6a.5.5 0 0 1-.5.5h-11a.5.5 0 0 1-.5-.5v-11a.5.5 0 0 1 .5-.5H9a.5.5 0 0 0 0-1H2.5A1.5 1.5 0 0 0 1 2.5v11z"/></svg>
                <span>Review & Edit</span>
            </button>
            <button class="print-btn icon-btn flex-1 px-3 py-2 text-sm font-semibold rounded-md transition-all">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M.5 1a.5.5 0 0 0 0 1h5a.5.5 0 0 0 0-1H.5zM9 1a.5.5 0 0 0 0 1h5a.5.5 0 0 0 0-1H9z"/><path d="M2.5 3a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-1 0v-1a.5.5 0 0 1 .5-.5z"/><path d="M4 3.5a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7a.5.5 0 0 1-.5-.5z"/><path d="M2.5 5a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-1 0v-1a.5.5 0 0 1 .5-.5z"/><path d="M4 5.5a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7a.5.5 0 0 1-.5-.5zM.5 7a.5.5 0 0 0 0 1h5a.5.5 0 0 0 0-1H.5zM9 7a.5.5 0 0 0 0 1h5a.5.5 0 0 0 0-1H9z"/><path d="M2.5 9a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-1 0v-1a.5.5 0 0 1 .5-.5z"/><path d="M4 9.5a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7a.5.5 0 0 1-.5-.5z"/><path d="M2.5 11a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-1 0v-1a.5.5 0 0 1 .5-.5z"/><path d="M4 11.5a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7a.5.5 0 0 1-.5-.5zM.5 13a.5.5 0 0 0 0 1h5a.5.5 0 0 0 0-1H.5zM9 13a.5.5 0 0 0 0 1h5a.5.5 0 0 0 0-1H9z"/><path d="M2.5 15a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-1 0v-1a.5.5 0 0 1 .5-.5z"/><path d="M4 15.5a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7a.5.5 0 0 1-.5-.5z"/></svg>
                <span>Print</span>
            </button>
        </div>`;

    teksRow.querySelector('.practice-pathway-btn').onclick = () => startPathway(teksName, questions, { isQuiz: false });
    teksRow.querySelector('.start-quiz-btn').onclick = () => showQuizSetupModal(teksName, questions);
    teksRow.querySelector('.review-btn').onclick = () => showReviewModal(teksName, questions);
    teksRow.querySelector('.print-btn').onclick = () => showPrintOptionsModal(questions, teksName);
    if(resetBtnHTML) {
        teksRow.querySelector('.reset-pathway-btn').onclick = () => resetPathwayProgress(teksName, questions.length);
    }

    // Helper function to map score to status string for display
    const getDisplayStatus = (score, pointsPossible) => {
        // Handle unattempted questions
        if (score === undefined || score === 'not-started' || isNaN(score)) return { className: 'not-started', title: 'Not started' };
        
        if (score === pointsPossible) return { className: 'correct', title: 'Correct' };
        if (score > 0) return { className: 'partial', title: `Partial (${score}/${pointsPossible} pts)` };
        return { className: 'incorrect', title: 'Incorrect' };
    };

    const questionGrid = document.createElement('div');
    questionGrid.className = 'question-grid';

    questions.forEach((question, index) => {
        const score = parseFloat(subjectData.masteryState[teksName]?.[index]);
        const pointsPossible = getQuestionPointsPossible(question);
        const { className, title } = getDisplayStatus(score, pointsPossible);

        const box = document.createElement('button');
        box.className = `question-box status-${className}`; // Uses the calculated class name
        box.dataset.index = index;
        box.title = `Question ${index + 1}: ${title}`; // Uses the calculated title
        
        // Check for flag (assuming AppState.currentPathway.flagged is available on the dashboard load)
        const isFlagged = AppState.currentPathway.flagged[index] && AppState.currentPathway.teks === teksName;
        if (isFlagged) { 
            box.classList.add('status-flagged');
        }

        questionGrid.appendChild(box);
    });

    // Find the main div inside teksRow to append the grid to.
    teksRow.querySelector('div').appendChild(questionGrid);

    // Add the click listener for the new boxes
    teksRow.addEventListener('click', (e) => {
        if (e.target.matches('.question-box')) {
            const index = parseInt(e.target.dataset.index, 10);
            startPathwayAtIndex(teksName, questions, index);
        }
    });

    return teksRow;
}
     /**
 * Creates a single row in the dashboard for a custom pathway.
 * FIX: Updated status display logic to handle numerical scores.
 * @param {Object} pathwayObject The saved custom pathway object.
 * @returns {HTMLElement} The created row element.
 */
function createCustomPathwayRow(pathwayObject) {
    const subjectData = getCurrentSubjectData();
    
    // "Re-hydrate" the questions array from the saved IDs
    const questions = pathwayObject.questionIds.map(id => 
        subjectData.allQuestions.find(q => q.id === id)
    ).filter(Boolean); 

    if (questions.length === 0) return null;

    const pathwayName = pathwayObject.name;
    
    const customPathwayDiv = document.createElement('div');
    customPathwayDiv.className = 'p-4 border rounded-lg bg-indigo-50 border-indigo-200 pathway-card mb-4';

    // 1. Build Main Card HTML (Grid moved to top-right)
    customPathwayDiv.innerHTML = `
        <div class="flex justify-between items-start mb-4">
            <div class="flex-grow pr-4">
                <h3 class="text-lg font-bold text-indigo-800">${pathwayName}</h3>
                <p class="text-xs text-gray-600 italic mt-1">${pathwayObject.filterDescription}</p>
            </div>

            <div class="flex flex-col items-end gap-2">
                <button class="delete-custom-pathway-btn text-xs text-red-500 hover:underline">Delete</button>
                <div class="question-grid-container flex justify-end"></div>
            </div>
        </div>
        
        <div class="flex flex-col sm:flex-row space-y-2 sm:space-y-0 sm:space-x-2">
            <button class="practice-pathway-btn flex-1 px-3 py-1 bg-green-600 text-white text-sm font-semibold rounded-md hover:bg-green-700">Practice Pathway</button>
             <button class="start-quiz-btn flex-1 px-3 py-1 bg-blue-600 text-white text-sm font-semibold rounded-md hover:bg-blue-700">Start Quiz</button>
            <button class="review-btn flex-1 px-3 py-1 bg-gray-200 text-gray-700 text-sm font-semibold rounded-md hover:bg-gray-300">Review & Edit</button>
            <button class="print-btn flex-1 px-3 py-1 text-sm font-semibold rounded-md">Print</button>
        </div>
    `;
    
    // Helper function to map score to status string for display
    const getDisplayStatus = (score, pointsPossible) => {
        // Handle unattempted questions
        if (score === undefined || score === 'not-started' || isNaN(score)) return { className: 'not-started', title: 'Not started' };
        
        if (score === pointsPossible) return { className: 'correct', title: 'Correct' };
        if (score > 0) return { className: 'partial', title: `Partial (${score}/${pointsPossible} pts)` };
        return { className: 'incorrect', title: 'Incorrect' };
    };
    
    // 2. Build the Visual Progress Grid Logic
    const questionGrid = document.createElement('div');
    questionGrid.className = 'question-grid';
    // Force right alignment for the grid flex container
    questionGrid.style.justifyContent = 'flex-end';
    
    // Ensure mastery tracking exists for this custom pathway name
    if (!subjectData.masteryState[pathwayName]) {
        subjectData.masteryState[pathwayName] = {};
        questions.forEach((_, i) => subjectData.masteryState[pathwayName][i] = 'not-started');
    }

    questions.forEach((question, index) => {
        const score = parseFloat(subjectData.masteryState[pathwayName]?.[index]);
        const pointsPossible = getQuestionPointsPossible(question);
        const { className, title } = getDisplayStatus(score, pointsPossible);

        const box = document.createElement('button');
        box.className = `question-box status-${className}`; // Uses the calculated class name
        box.dataset.index = index;
        box.title = `Question ${index + 1}: ${title}`; // Uses the calculated title
        
        // Add flag if set
        if (AppState.currentPathway.flagged[index]) { 
            box.classList.add('status-flagged');
        }

        questionGrid.appendChild(box);
    });

    // Append grid to the new top-right container
    customPathwayDiv.querySelector('.question-grid-container').appendChild(questionGrid);

    // 3. Attach Listeners
    customPathwayDiv.querySelector('.practice-pathway-btn').onclick = () => startPathway(pathwayName, questions, { isQuiz: false });
    customPathwayDiv.querySelector('.start-quiz-btn').onclick = () => showQuizSetupModal(pathwayName, questions);
    customPathwayDiv.querySelector('.review-btn').onclick = () => showReviewModal(pathwayName, questions);
    customPathwayDiv.querySelector('.print-btn').onclick = () => showPrintOptionsModal(questions, pathwayName);
    
    // Delete Listener
    customPathwayDiv.querySelector('.delete-custom-pathway-btn').onclick = () => {
        if (confirm(`Are you sure you want to delete the pathway "${pathwayName}"?`)) {
            subjectData.customPathways = subjectData.customPathways.filter(p => p.id !== pathwayObject.id);
            saveState();
            renderDashboard();
        }
    };

    // Grid Click Listener (Jump to Question)
    customPathwayDiv.addEventListener('click', (e) => {
        if (e.target.matches('.question-box')) {
            const index = parseInt(e.target.dataset.index, 10);
            startPathwayAtIndex(pathwayName, questions, index);
        }
    });
    
    return customPathwayDiv;
}
             
           function createCategorySummary(title, questions) {
    const summary = document.createElement('summary');
    const pathwayKey = `Category: ${title}`;
    const subjectData = getCurrentSubjectData();
    const progressMade = subjectData.masteryState[pathwayKey] && Object.values(subjectData.masteryState[pathwayKey]).some(s => s !== 'not-started');
    const resetBtnHTML = progressMade ? `<button class="reset-pathway-btn text-xs text-red-500 hover:underline">Reset</button>` : '';

    // --- NEW: FRIENDLY NAME LOGIC ---
    let displayTitle = title;
    // Check if this title is an RC (e.g., "RC 1")
    const rcMatch = title.match(/RC\s*(\d+)/); 
    const currentSubject = AppState.currentSubject;

    if (rcMatch && RCNames[currentSubject]) {
        // Normalize to "RC 1" key to look up in the dictionary
        const shortKey = `RC ${rcMatch[1]}`; 
        if (RCNames[currentSubject][shortKey]) {
            // Append the friendly name: "RC 1: Cell Structure & Function"
            displayTitle = `${title}: ${RCNames[currentSubject][shortKey]}`;
        }
    }
    // --------------------------------

    summary.innerHTML = `
        <span class="flex-grow">${displayTitle}</span>
        <div class="flex items-center space-x-2">
            ${resetBtnHTML}
            <button class="practice-all-btn px-2 py-1 bg-green-100 text-green-800 text-xs font-semibold rounded-md hover:bg-green-200">Practice All</button>
            <button class="quiz-all-btn px-2 py-1 bg-blue-100 text-blue-800 text-xs font-semibold rounded-md hover:bg-blue-200">Quiz All</button>
        </div>
    `;
    summary.querySelector('.practice-all-btn').onclick = (e) => { e.stopPropagation(); startPathway(pathwayKey, questions, { isQuiz: false }); };
    summary.querySelector('.quiz-all-btn').onclick = (e) => { e.stopPropagation(); showQuizSetupModal(pathwayKey, questions); };
    if (resetBtnHTML) {
        summary.querySelector('.reset-pathway-btn').onclick = (e) => { e.stopPropagation(); resetPathwayProgress(pathwayKey, questions.length); };
    }
    return summary;
}

 
/**
 * Renders the actionable "Strategy Blueprint" view.
 * Layout: Stacked Vertically.
 * RANKING: Based on TOTAL POINTS (Weighted).
 * FEATURE: "High Yield" button opens Strategy Modal (Step 2 Fix).
 */
function renderDashboardByBlueprint(container) {
    const subjectData = getCurrentSubjectData();
    let questions = subjectData.allQuestions;
    const currentSubject = AppState.currentSubject; 

    // 1. APPLY YEAR FILTER
    if (AppState.dashboardYearFilter && AppState.dashboardYearFilter !== 'All') {
        questions = questions.filter(q => q.year == AppState.dashboardYearFilter);
    }

    if (questions.length === 0) {
        container.innerHTML = `<div class="p-12 text-center text-gray-500 bg-gray-50 rounded-lg border border-dashed border-gray-300">
            <p class="text-xl">No data found for <strong>${AppState.dashboardYearFilter}</strong>.</p>
            <p class="text-sm mt-2">Try selecting "All Years" or a different exam.</p>
        </div>`;
        return;
    }

    // 2. AGGREGATE DATA (Weighted by Points)
    const rcStats = {};      
    const clusterStats = {}; 
    const teksStats = {};
    
    const rcQuestions = {};
    const clusterQuestions = {};
    const teksQuestions = {};
    
    let totalExamPoints = 0;

    questions.forEach(q => {
        const rc = q.reportingCategory || 'Uncategorized';
        const cluster = q.cluster || 'General';
        const teks = q.teks || 'Unknown';
        
        const pts = getQuestionPointsPossible(q);
        totalExamPoints += pts;

        // Init Objects
        if (!rcStats[rc]) rcStats[rc] = { count: 0, points: 0 };
        if (!clusterStats[cluster]) clusterStats[cluster] = { count: 0, points: 0 };
        if (!teksStats[teks]) teksStats[teks] = { count: 0, points: 0 };

        // Increment Stats
        rcStats[rc].count++;      rcStats[rc].points += pts;
        clusterStats[cluster].count++; clusterStats[cluster].points += pts;
        teksStats[teks].count++;  teksStats[teks].points += pts;

        // Store Questions
        if (!rcQuestions[rc]) rcQuestions[rc] = []; rcQuestions[rc].push(q);
        if (!clusterQuestions[cluster]) clusterQuestions[cluster] = []; clusterQuestions[cluster].push(q);
        if (!teksQuestions[teks]) teksQuestions[teks] = []; teksQuestions[teks].push(q);
    });

    // 3. RENDER HEADER (High Yield Generator)
    // Find top 10 TEKS by POINTS
    const topTeksKeys = Object.keys(teksStats)
        .sort((a,b) => teksStats[b].points - teksStats[a].points) 
        .slice(0, 10);
        
    const highYieldQuestions = topTeksKeys.flatMap(k => teksQuestions[k]);

    const header = document.createElement('div');
    header.className = "mb-8 bg-gradient-to-r from-indigo-600 to-purple-600 rounded-xl p-6 text-white shadow-lg flex flex-col md:flex-row justify-between items-center gap-4";
    header.innerHTML = `
        <div>
            <h2 class="text-2xl font-bold">Strategy Blueprint: ${AppState.dashboardYearFilter === 'All' ? 'All Years' : AppState.dashboardYearFilter}</h2>
            <p class="text-indigo-100 opacity-90">Based on <strong>${totalExamPoints} Total Points</strong> available. Ranked by point value.</p>
        </div>
        <button id="high-yield-btn" class="bg-white text-indigo-700 font-bold px-6 py-3 rounded-lg shadow hover:bg-gray-50 transition transform hover:scale-105 flex items-center gap-2">
            <span>‚ö°</span> Practice Top 10 High-Yield Items
        </button>
    `;
    
    // --- [STEP 2] CONNECT THE BUTTON TO THE MODAL HERE ---
    header.querySelector('#high-yield-btn').onclick = () => {
        // This calls the modal function you added in Step 1
        showHighYieldOptionsModal(highYieldQuestions, AppState.dashboardYearFilter);
    };
    // -----------------------------------------------------
    
    container.appendChild(header);

    // 4. RENDER STACKED SECTIONS
    const stack = document.createElement('div');
    stack.className = "space-y-8"; 
    container.appendChild(stack);

    // --- ROW 1: REPORTING CATEGORIES ---
    const row1 = document.createElement('div');
    row1.className = "bg-white p-6 rounded-xl border border-gray-200 shadow-sm";
    row1.innerHTML = `<h3 class="text-xl font-bold text-gray-800 mb-6 border-b pb-2 flex items-center gap-2"><span>üìÇ</span> Reporting Categories</h3>`;
    
    const rcGrid = document.createElement('div');
    rcGrid.className = "grid grid-cols-1 md:grid-cols-2 gap-x-8 gap-y-4"; 
    
    Object.entries(rcStats).sort((a,b) => b[1].points - a[1].points).forEach(([rc, stats]) => {
        const pct = Math.round((stats.points / totalExamPoints) * 100);
        const shortRC = rc.match(/RC\s*\d+/); 
        const rcKey = shortRC ? shortRC[0] : rc;
        const displayName = (RCNames[currentSubject] && RCNames[currentSubject][rcKey]) 
                            ? RCNames[currentSubject][rcKey] 
                            : rc.replace(/^RC\s*\d+\s*/, '');

        const item = document.createElement('div');
        item.className = "group";
        item.innerHTML = `
            <div class="flex justify-between items-end mb-1">
                <span class="text-sm font-bold text-gray-700 leading-tight">${displayName}</span>
                <span class="text-xs font-mono text-gray-500 font-bold">${stats.count} Qs ‚Ä¢ ${stats.points} Pts (${pct}%)</span>
            </div>
            <div class="flex items-center gap-3">
                <div class="flex-grow bg-gray-100 rounded-full h-4 overflow-hidden shadow-inner">
                    <div class="bg-indigo-500 h-4 rounded-full" style="width: ${pct}%"></div>
                </div>
                <button class="play-btn px-3 py-0.5 bg-green-100 text-green-700 text-xs font-bold rounded hover:bg-green-200 transition opacity-0 group-hover:opacity-100">‚ñ∂ Practice</button>
            </div>
        `;
        item.querySelector('.play-btn').onclick = () => startPathway(`Practice: ${displayName}`, rcQuestions[rc], { isQuiz: false });
        rcGrid.appendChild(item);
    });
    row1.appendChild(rcGrid);
    stack.appendChild(row1);

    // --- ROW 2: CLUSTERS ---
    const row2 = document.createElement('div');
    row2.className = "bg-white p-6 rounded-xl border border-gray-200 shadow-sm";
    row2.innerHTML = `<h3 class="text-xl font-bold text-gray-800 mb-6 border-b pb-2 flex items-center gap-2"><span>üèóÔ∏è</span> Clusters (Ranked by Points)</h3>`;
    
    const clusterGrid = document.createElement('div');
    clusterGrid.className = "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4";
    
    Object.entries(clusterStats).sort((a,b) => b[1].points - a[1].points).forEach(([cluster, stats], index) => {
        const isTop3 = index < 3; 
        const card = document.createElement('div');
        card.className = `p-4 rounded-lg border flex justify-between items-center group transition-all hover:shadow-md ${isTop3 ? 'bg-orange-50 border-orange-200' : 'bg-white border-gray-100'}`;
        card.innerHTML = `
            <div class="flex flex-col">
                <div class="flex items-center gap-2">
                    <span class="font-mono text-xs font-bold text-gray-400">#${index+1}</span>
                    ${isTop3 ? '<span class="text-sm animate-pulse">üî•</span>' : ''}
                </div>
                <span class="font-bold text-gray-800 text-md leading-tight mt-1 line-clamp-2" title="${cluster}">${cluster}</span>
                <span class="text-xs text-gray-500 font-bold mt-1">${stats.count} Qs ‚Ä¢ ${stats.points} Pts</span>
            </div>
            <button class="play-btn p-3 bg-green-100 text-green-700 rounded-full hover:bg-green-200 transition opacity-0 group-hover:opacity-100 shadow-sm" title="Practice this cluster">‚ñ∂</button>
        `;
        card.querySelector('.play-btn').onclick = () => startPathway(`Practice: ${cluster}`, clusterQuestions[cluster], { isQuiz: false });
        clusterGrid.appendChild(card);
    });
    row2.appendChild(clusterGrid);
    stack.appendChild(row2);

    // --- ROW 3: TEKS LEADERBOARD ---
    const row3 = document.createElement('div');
    row3.className = "bg-white p-6 rounded-xl border border-gray-200 shadow-sm";
    row3.innerHTML = `<h3 class="text-xl font-bold text-gray-800 mb-6 border-b pb-2 flex items-center gap-2"><span>üèÜ</span> TEKS Leaderboard (By Points)</h3>`;
    
    const teksGrid = document.createElement('div');
    teksGrid.className = "grid grid-cols-2 md:grid-cols-4 lg:grid-cols-6 gap-3";

    Object.entries(teksStats).sort((a,b) => b[1].points - a[1].points).forEach(([teks, stats], index) => {
        const isTop10 = index < 10;
        const tile = document.createElement('div');
        tile.className = `flex flex-col items-center justify-center p-3 rounded-lg border group hover:border-indigo-300 transition-all ${isTop10 ? 'bg-yellow-50 border-yellow-200 shadow-sm' : 'bg-white border-gray-100'}`;
        
        let rankIcon = `#${index+1}`;
        if (index === 0) rankIcon = 'ü•á';
        if (index === 1) rankIcon = 'ü•à';
        if (index === 2) rankIcon = 'ü•â';

        tile.innerHTML = `
            <span class="text-xs font-bold mb-1 ${index < 3 ? 'text-lg' : 'text-gray-400'}">${rankIcon}</span>
            <span class="font-bold text-gray-800 text-lg">${teks}</span>
            <span class="text-xs text-gray-500 font-bold mb-2">${stats.points} Pts (${stats.count} Qs)</span>
            <button class="play-btn w-full py-1 bg-indigo-50 text-indigo-700 text-xs font-bold rounded hover:bg-indigo-100 transition opacity-0 group-hover:opacity-100">Play</button>
        `;
        tile.querySelector('.play-btn').onclick = () => startPathway(`Practice: ${teks}`, teksQuestions[teks], { isQuiz: false });
        teksGrid.appendChild(tile);
    });
    row3.appendChild(teksGrid);
    stack.appendChild(row3);
}
            
            function renderDashboardByYear(container) {
                const subjectData = getCurrentSubjectData();
                const grouped = subjectData.allQuestions.reduce((acc, q) => {
                    const { year, reportingCategory, cluster, teks } = q;
                    if (!year || !reportingCategory || !cluster || !teks) return acc;
                    if (!acc[year]) acc[year] = {};
                    if (!acc[year][reportingCategory]) acc[year][reportingCategory] = {};
                    if (!acc[year][reportingCategory][cluster]) acc[year][reportingCategory][cluster] = {};
                    if (!acc[year][reportingCategory][cluster][teks]) acc[year][reportingCategory][cluster][teks] = [];
                    acc[year][reportingCategory][cluster][teks].push(q);
                    return acc;
                }, {});

                const years = Object.keys(grouped).sort((a,b) => b - a);
                years.forEach(year => {
                    const yearQuestions = Object.values(grouped[year]).flatMap(rc => Object.values(rc).flatMap(c => Object.values(c).flat()));
                    const yearDetails = document.createElement('details');
                    yearDetails.open = true;
                    const yearSummary = createCategorySummary(year, yearQuestions);
                    yearSummary.classList.add('text-xl', 'font-bold', 'text-gray-700');
                    yearDetails.appendChild(yearSummary);
                    pathwayDisplay.appendChild(yearDetails);

                    const rcs = Object.keys(grouped[year]).sort();
                    rcs.forEach(rc => {
                        const rcQuestions = Object.values(grouped[year][rc]).flatMap(c => Object.values(c).flat());
                        const rcDetails = document.createElement('details');
                        rcDetails.open = true;
                        const rcSummary = createCategorySummary(rc, rcQuestions);
                        rcSummary.classList.add('text-lg', 'font-semibold', 'text-gray-600');
                        rcDetails.appendChild(rcSummary);
                        yearDetails.appendChild(rcDetails);

                        const clusters = Object.keys(grouped[year][rc]).sort();
                        clusters.forEach(clusterName => {
                            const clusterQuestions = Object.values(grouped[year][rc][clusterName]).flat();
                            const clusterDetails = document.createElement('details');
                            clusterDetails.open = true;
                            const clusterSummary = createCategorySummary(clusterName, clusterQuestions);
                            clusterSummary.classList.add('font-medium', 'text-gray-500');
                            clusterDetails.appendChild(clusterSummary);
                            rcDetails.appendChild(clusterDetails);

                            const teksList = Object.keys(grouped[year][rc][clusterName]).sort();
                            teksList.forEach(teksName => {
                                const questions = grouped[year][rc][clusterName][teksName];
                                const teksRow = createTeksRow(teksName, questions);
                                teksRow.classList.add('ml-4');
                                clusterDetails.appendChild(teksRow);
                            });
                        });
                    });
                });
            }

           
            function renderDashboardByCluster(container) {
                const subjectData = getCurrentSubjectData();
                const groupedByCluster = subjectData.allQuestions.reduce((acc, q) => {
                    (acc[q.cluster || 'Uncategorized'] = acc[q.cluster || 'Uncategorized'] || {})[q.teks] = (acc[q.cluster || 'Uncategorized'][q.teks] || []).concat(q);
                    return acc;
                }, {});

                for (const clusterName in groupedByCluster) {
                    const clusterQuestions = Object.values(groupedByCluster[clusterName]).flat();
                    const clusterDetails = document.createElement('details');
                    clusterDetails.open = true;
                    
                    const clusterSummary = createCategorySummary(clusterName, clusterQuestions);
                    clusterSummary.classList.add('text-xl', 'font-bold', 'text-gray-800', 'p-0');
                    clusterDetails.appendChild(clusterSummary);
                    
                    const teksContainer = document.createElement('div');
                    teksContainer.className = 'space-y-3 mt-2';
                    clusterDetails.appendChild(teksContainer);

                    for (const teksName in groupedByCluster[clusterName]) {
                        const questions = groupedByCluster[clusterName][teksName];
                        const teksRow = createTeksRow(teksName, questions);
                        teksContainer.appendChild(teksRow);
                    }
                    pathwayDisplay.appendChild(clusterDetails);
                }
            }


            /**
             * Starts a practice or quiz pathway.
             * @param {string} teks The TEKS standard for the pathway.
             * @param {Array<Object>} questions The questions in the pathway.
             * @param {Object} options Configuration options (isQuiz, timerSettings).
             */
        /**
 * Starts a practice or quiz pathway.
 * FIXED: Automatically converts ID strings into full Question Objects.
 */
function startPathway(teks, questions, options = {}, startIndex = 0) {
    // --- THE FIX: Rehydrate Questions ---
    // If the buttons sent us IDs (strings), look up the real objects now.
    if (questions && questions.length > 0 && typeof questions[0] === 'string') {
        const subjectData = getCurrentSubjectData();
        const allQs = subjectData.allQuestions || [];
        // Map ID -> Real Object
        questions = questions.map(id => allQs.find(q => q.id === id)).filter(q => q);
    }
    // ------------------------------------

    const { isQuiz = false, timerSettings = null } = options;
    const subjectData = getCurrentSubjectData();
    
    // Ensure mastery tracking exists
    if (!subjectData.masteryState[teks]) {
        subjectData.masteryState[teks] = {};
    }

    // Initialize unstarted questions
    questions.forEach((q, i) => {
        // We use the question's unique ID for tracking if possible, 
        // but for now, we map it to the index in this specific pathway set
        if (subjectData.masteryState[teks][i] === undefined) {
            subjectData.masteryState[teks][i] = 'not-started';
        }
    });

    AppState.currentPathway = { 
        teks, 
        questions, 
        currentIndex: startIndex, 
        activeQuestion: null, 
        userSelections: [], 
        graphingPoints: [], 
        flagged: {}, 
        isQuiz,
        timerSettings,
        startTime: new Date()
    };

    showProblemView();
    renderProblem(questions[startIndex]); 
}

// Ensure it's accessible to HTML buttons
window.startPathway = startPathway;
            /**
             * Switches the view to the main dashboard.
             */
            function showDashboard() {
                problemView.classList.add('hidden');
                resultsView.classList.add('hidden');
                dashboardView.classList.remove('hidden');
                homeBtn.classList.add('hidden');
                renderDashboard(); 
            }

            /**
             * Switches the view to the problem/student view.
             */
            function showProblemView() {
                dashboardView.classList.add('hidden');
                resultsView.classList.add('hidden');
                problemView.classList.remove('hidden');
                homeBtn.classList.remove('hidden');
            }

           
function startPathwayAtIndex(teksName, questions, startIndex) {
                // Pass the index directly so it loads ONCE, correctly.
                startPathway(teksName, questions, { isQuiz: false }, startIndex);
            }

/**
 * Renders a single problem/question for the student.
 * FIXED: Added safety check at the top to stop crashes if question is undefined.
 */
async function renderProblem(question) {
    // --- SAFETY CHECK ---
    if (!question) {
        console.warn("Attempted to render an undefined question.");
        return;
    }
    // --------------------

    // Get our containers
    const passageContainer = document.getElementById('passage-container');
    const passageWrapper = document.getElementById('passage-content-wrapper');
    const questionContent = document.getElementById('scalable-content');
    const problemViewContainer = document.getElementById('problem-view');
    
    problemViewContainer.classList.add('fade-out');
    if(AppState.questionTimer) clearInterval(AppState.questionTimer);
    AppState.zoomLevel = 1.0; 
    AppState.passageZoomLevel = 1.0; 
    timerDisplay.textContent = '';

    // --- Paired Passage Logic ---
    const newPassagePages = question.passagePageNums || [];
    const oldPassagePages = AppState.currentPathway.activeQuestion?.passagePageNums || [];
    const passagesHaveChanged = JSON.stringify(newPassagePages) !== JSON.stringify(oldPassagePages);

    const gridEl = document.getElementById('problem-view-grid');

    if (passagesHaveChanged) {
        passageWrapper.innerHTML = ''; 

        if (newPassagePages.length > 0) {
            // English/Reading Mode
            passageContainer.style.display = 'block';
            gridEl.style.gridTemplateColumns = ''; 

            try {
                const subjectData = getCurrentSubjectData();
                const docIndex = question.pdfIndex !== undefined ? question.pdfIndex : 0;
                const activePdf = subjectData.pdfDocs[docIndex]; 

                if (activePdf) {
                    for (const pageNum of newPassagePages) {
                        const page = await activePdf.getPage(pageNum);
                        const viewport = page.getViewport({ scale: 2.5 });
                        const passageCanvas = document.createElement('canvas');
                        passageCanvas.width = viewport.width;
                        passageCanvas.height = viewport.height;
                        passageCanvas.style.marginBottom = '1rem'; 
                        await page.render({ canvasContext: passageCanvas.getContext('2d'), viewport }).promise;
                        passageWrapper.appendChild(passageCanvas);
                    }
                }
            } catch (e) {
                console.error("Failed to render passage canvas(es):", e);
                passageWrapper.innerHTML = '<p>Error loading passage(s).</p>';
            }
        } else {
            // Math/Science Mode
            passageContainer.style.display = 'none'; 
            gridEl.style.gridTemplateColumns = 'repeat(1, minmax(0, 1fr))';
        }
    } else if (newPassagePages.length > 0) {
        passageContainer.style.display = 'block';
        gridEl.style.gridTemplateColumns = ''; 
    } else {
        passageContainer.style.display = 'none';
        gridEl.style.gridTemplateColumns = 'repeat(1, minmax(0, 1fr))';
    }

    setTimeout(async () => {
        AppState.currentPathway.activeQuestion = question;
        AppState.currentPathway.userSelections = [];
        AppState.currentPathway.graphingPoints = [];
        
        // Difficulty Badge Logic
        const diff = question.difficulty || 'Unrated';
        let badgeColor = 'bg-gray-100 text-gray-800 border-gray-200'; 
        
        if (diff === 'Masters') badgeColor = 'bg-purple-100 text-purple-800 border-purple-200';
        else if (diff === 'Meets') badgeColor = 'bg-blue-100 text-blue-800 border-blue-200';
        else if (diff === 'Approaches') badgeColor = 'bg-green-100 text-green-800 border-green-200';

   progressIndicator.innerHTML = `
            <span class="mr-3">Problem ${AppState.currentPathway.currentIndex + 1} of ${AppState.currentPathway.questions.length}</span>
            <span class="px-2 py-1 text-xs font-bold rounded border ${badgeColor}">${diff}</span>
        `;

        explanationBox.classList.add('hidden');
        correctAnswerContainer.classList.add('hidden');
        feedbackMessage.textContent = ''; 
        feedbackMessage.className = 'mt-4 text-center text-lg font-bold'; 
        answerInterface.innerHTML = '';
        retryProblemBtn.classList.add('hidden');
        
        renderClickableProgressBar();
        updateNavButtons();

        if (AppState.currentPathway.isQuiz && AppState.currentPathway.timerSettings) {
            startQuestionTimer();
        }

        const subjectData = getCurrentSubjectData();
        
        if (!subjectData.pdfDocs || subjectData.pdfDocs.length === 0) {
            showCustomModal("PDF Missing", "Please re-upload the PDF for this subject to view questions.", showDashboard);
            return;
        }

        questionContent.innerHTML = ''; 

        const canvases = await createQuestionCanvases(question, 2.5);
        canvases.forEach((canvas, index) => {
            if (index === 0 && canvases.length === 1) {
                canvas.id = 'problem-canvas';
            }
            questionContent.appendChild(canvas);
        });
        
        await renderDynamicAnswerInterface(question);
        updateTeksContext(question);
        problemViewContainer.classList.remove('fade-out');
    }, 150); 
}
            
/**
 * Renders the clickable progress bar at the top of the student view.
 * FIXED: Now correctly handles Quiz status strings ('correct'/'incorrect') so boxes don't stay grey.
 */
function renderClickableProgressBar() {
    clickableProgressBar.innerHTML = '';
    const pathway = AppState.currentPathway;
    const subjectData = getCurrentSubjectData();
    const mastery = subjectData.masteryState[pathway.teks] || {}; // Safety fallback

    // Helper to safely convert score/status to CSS class
    const getDisplayStatusClass = (score, pointsPossible) => {
        // 1. Handle Quiz Mode Strings (The Fix!)
        if (score === 'correct' || score === 'incorrect') {
            // In a quiz, we just want to show "Answered" (Blue), not the result yet.
            // We can reuse 'current' or 'partial' styles, or add a specific 'answered' style.
            // Let's use 'answered' (we'll add the CSS below) or map to 'current' for blue.
            return 'answered'; 
        }

        // 2. Handle Numeric Scores (Practice Mode)
        if (score === undefined || score === 'not-started' || (typeof score === 'number' && isNaN(score))) {
            return 'not-started';
        }
        
        if (score === pointsPossible) return 'correct';
        if (score > 0) return 'partial';
        return 'incorrect';
    };

    pathway.questions.forEach((q, index) => {
        const rawStatus = mastery[index]; // Could be number OR string
        const pointsPossible = getQuestionPointsPossible(q);
        const statusClass = getDisplayStatusClass(rawStatus, pointsPossible);

        const box = document.createElement('div');
        // If status is 'answered', we manually style it blue here to avoid complex CSS changes
        if (statusClass === 'answered') {
            box.className = 'status-box clickable-status-box bg-blue-500 border-blue-600';
            box.title = "Answered";
        } else {
            box.className = `status-box clickable-status-box status-${statusClass}`;
            box.title = `Question ${index + 1}`;
        }

        // Highlight Current Question
        if (index === pathway.currentIndex) {
            box.classList.add('current');
            box.style.borderColor = '#2563eb'; // Bright Blue Border
            box.style.boxShadow = '0 0 0 3px rgba(37, 99, 235, 0.5)';
        }

        // Show Flag
        if (pathway.flagged && pathway.flagged[index]) { 
            box.classList.add('status-flagged');
        }
        
        box.dataset.index = index;
        
        // Click Logic
        if (pathway.isQuiz) {
             // In quiz, allow jumping to any question (answered or not)
             box.onclick = () => jumpToProblem(index);
        } else {
             box.onclick = () => jumpToProblem(index);
        }
        
        clickableProgressBar.appendChild(box);
    });
}



            /**
             * Allows jumping to a specific problem in practice mode.
             * @param {number} index The index of the problem to jump to.
             */
            function jumpToProblem(index) {
                AppState.currentPathway.currentIndex = index;
                renderProblem(AppState.currentPathway.questions[index]);
            }

          /**
 * Updates the text and visibility of navigation buttons.
 * NEW: Injects the Hint button into the bottom navigation bar.
 */
function updateNavButtons() {
    const { currentIndex, questions, isQuiz } = AppState.currentPathway;
    
    // Standard toggles
    previousProblemBtn.classList.toggle('hidden', isQuiz);
    skipProblemBtn.classList.toggle('hidden', !isQuiz);
    backToDashboardBtn.classList.toggle('hidden', isQuiz);

    // Text update
    if (currentIndex === questions.length - 1) {
        nextProblemBtn.textContent = "Finish";
    } else {
        nextProblemBtn.textContent = "Next";
    }

    // --- NEW: INJECT HINT BUTTON ---
    const navContainer = document.getElementById('navigation-controls');
    let hintBtn = document.getElementById('bottom-hint-btn');

    // If button doesn't exist, create it
    if (!hintBtn) {
        hintBtn = document.createElement('button');
        hintBtn.id = 'bottom-hint-btn';
        hintBtn.className = "flex items-center gap-2 px-4 py-2 bg-yellow-100 text-yellow-800 font-bold rounded-md hover:bg-yellow-200 transition-colors border border-yellow-300 shadow-sm mr-2";
        hintBtn.innerHTML = `<span>üí°</span> Hint`;
        hintBtn.onclick = triggerHint;
        
        // Insert it BEFORE the Next button
        navContainer.insertBefore(hintBtn, nextProblemBtn);
    }

    // Only show Hint button in Practice Mode (not Quiz)
    if (isQuiz) {
        hintBtn.classList.add('hidden');
    } else {
        hintBtn.classList.remove('hidden');
    }
}

          /**
 * Renders the appropriate answer interface based on the question type.
 * FIXED: Added safe check for itemType to prevent crashes.
 */
async function renderDynamicAnswerInterface(question) {
    answerInterface.innerHTML = '';
    
    // --- SAFETY CHECK ---
    const type = (question.itemType || 'multiple choice').toLowerCase();
    // --------------------
    
    if (type.includes('multiple choice') || type.includes('multipart') || type.includes('multiselect')) {
        renderMultipleChoiceInterface(question);
    } else if (type.includes('hot spot')) {
        renderHotspotInterface(question);
    } else if (type.includes('drag and drop')) {
        renderDragAndDropInterface(question);
    } else if (type.includes('short constructed response') || type.includes('text entry') || type.includes('equation editor')) {
        renderTextEntryInterface(question);
    } else if (type.includes('inline choice')) {
        renderInlineChoiceInterface(question);
    } else if (type.includes('graphing')) {
        renderGraphingInterface(question);
    } else {
            answerInterface.innerHTML = `<p class="text-center text-gray-600 font-semibold">This question type is not yet interactive.</p>`;
    }
}

   /**
             * Renders the interface for multiple choice questions.
             * @param {Object} question The question object.
             */
            function renderMultipleChoiceInterface(question) {
                if (!question.answerText || question.answerText.length === 0) {
                    answerInterface.innerHTML = `<p class="text-center text-gray-500">This question is not yet configured. Please set the correct answer in the Review & Edit screen.</p>`;
                    return;
                }

                const createAndAppend = (tag, parent, text = '', classes = []) => {
                    const el = document.createElement(tag);
                    if (text) el.textContent = text;
                    if (classes.length) el.classList.add(...classes);
                    parent.appendChild(el);
                    return el;
                };

                const isMultipart = question.itemType.toLowerCase().includes('multipart');
                const isMultiSelect = question.answerText.length > 1 && !isMultipart;

                if (isMultiSelect) {
                    const instructionText = question.answerText.length === 2 ? "Select TWO correct answers." : `Select ${question.answerText.length} correct answers.`;
                    createAndAppend('p', answerInterface, instructionText, ['font-bold', 'text-lg', 'mb-4', 'text-center']);
                    const options = ['A', 'B', 'C', 'D'].some(opt => question.answerText.includes(opt)) ? ['A', 'B', 'C', 'D', 'E'] : ['F', 'G', 'H', 'J', 'K'];
                    renderOptions(options, 0);
                } else if (isMultipart) {
                    createAndAppend('p', createAndAppend('div', answerInterface), 'Part A', ['font-bold', 'text-lg', 'mb-2']);
                    const partAOptions = ['A', 'B', 'C', 'D'].includes((question.answerText[0] || '').toUpperCase()) ? ['A', 'B', 'C', 'D'] : ['F', 'G', 'H', 'J'];
                    renderOptions(partAOptions, 0);
                    
                    const partBContainer = createAndAppend('div', answerInterface, '', ['mt-4']);
                    createAndAppend('p', partBContainer, 'Part B', ['font-bold', 'text-lg', 'mb-2']);
                    const partBOptions = ['A', 'B', 'C', 'D'].includes((question.answerText[1] || '').toUpperCase()) ? ['A', 'B', 'C', 'D'] : ['F', 'G', 'H', 'J'];
                    renderOptions(partBOptions, 1); 
                } else {
                    const options = ['A', 'B', 'C', 'D'].includes((question.answerText[0] || '').toUpperCase()) ? ['A', 'B', 'C', 'D'] : ['F', 'G', 'H', 'J'];
                    renderOptions(options, 0);
                }

                function renderOptions(opts, partIndex) {
                    const buttonContainer = createAndAppend('div', answerInterface, '', ['grid', 'grid-cols-2', 'md:grid-cols-4', 'gap-4']);
                    buttonContainer.dataset.partIndex = partIndex;

                    opts.forEach(opt => {
                        const button = createAndAppend('button', buttonContainer, opt, ['answer-button', 'px-6', 'py-3', 'text-gray-800', 'font-semibold', 'rounded-lg']);
                        button.onclick = () => handleAnswerSelection(opt, partIndex, button);
                    });
                }
            }
/**
             * Handles the logic when a user clicks a multiple choice answer.
             * @param {string} selectedOption The selected answer (e.g., 'A').
             * @param {number} partIndex The part of the question (for multipart).
             * @param {HTMLElement} buttonElement The button element that was clicked.
             */
            function handleAnswerSelection(selectedOption, partIndex, buttonElement) {
                const question = AppState.currentPathway.activeQuestion;
                const maxSelections = (question.answerText || []).length;
                const isMultiSelect = maxSelections > 1 && !question.itemType.toLowerCase().includes('multipart');
                
                // Initialize user selections array if it doesn't exist for the part
                if (!Array.isArray(AppState.currentPathway.userSelections[partIndex])) {
                    AppState.currentPathway.userSelections[partIndex] = [];
                }

                const currentSelections = AppState.currentPathway.userSelections[partIndex];
                const isSelected = buttonElement.classList.contains('selected');

                if (isMultiSelect) {
                    // --- MULTI-SELECT LOGIC (e.g., "Select TWO") ---
                    if (isSelected) {
                        // Deselect it
                        buttonElement.classList.remove('selected');
                        const indexToRemove = currentSelections.indexOf(selectedOption);
                        if (indexToRemove > -1) {
                            currentSelections.splice(indexToRemove, 1);
                        }
                    } else {
                        // Select it if not at max
                        if (currentSelections.length < maxSelections) {
                            buttonElement.classList.add('selected');
                            currentSelections.push(selectedOption);
                        }
                    }
                } else {
                    // --- SINGLE-SELECT LOGIC (Standard MCQs and Part A/B) ---
                    const parentContainer = buttonElement.parentElement;
                    parentContainer.querySelectorAll('.answer-button').forEach(btn => btn.classList.remove('selected'));
                    buttonElement.classList.add('selected');
                    AppState.currentPathway.userSelections[partIndex] = [selectedOption];
                }

                // Check if ready to submit
                const totalSelections = AppState.currentPathway.userSelections.flat().length;
                const existingSubmitBtn = document.getElementById('submit-mc-btn');
                if (existingSubmitBtn) existingSubmitBtn.remove();

                if (!AppState.currentPathway.isQuiz && totalSelections === maxSelections) {
                    const submitBtn = document.createElement('button');
                    submitBtn.id = 'submit-mc-btn';
                    submitBtn.textContent = 'Submit Answer';
                    submitBtn.className = 'w-full mt-6 px-6 py-3 bg-green-600 text-white font-semibold rounded-lg shadow-md hover:bg-green-700';
                    submitBtn.onclick = evaluateMCAnswer;
                    answerInterface.appendChild(submitBtn);
                }
            }

           /**
             * Evaluates the selected multiple choice answers.
             */
            function evaluateMCAnswer() {
                const question = AppState.currentPathway.activeQuestion;
                const userAnswers = AppState.currentPathway.userSelections.flat(); // Flatten array for easy comparison
                const correctAnswers = question.answerText;
                const isMultiSelect = correctAnswers.length > 1 && !question.itemType.toLowerCase().includes('multipart');

                let isFullyCorrect = false;
                let correctCount = 0;

                if (isMultiSelect) {
                    // For "Select TWO", sort both arrays to compare them regardless of order
                    isFullyCorrect = userAnswers.length === correctAnswers.length && 
                                     userAnswers.sort().toString() === correctAnswers.sort().toString();
                    if (isFullyCorrect) correctCount = correctAnswers.length;
                } else {
                    // For standard MCQs and Part A/B questions
                    (userAnswers || []).forEach((answer, index) => {
                        if (answer === correctAnswers[index]) {
                            correctCount++;
                        }
                    });
                    isFullyCorrect = correctCount === correctAnswers.length;
                }
                
                showFeedback(isFullyCorrect, correctCount);
            }
/**
 * Determines the maximum possible point value for a given question.
 * CRITICAL FIX: Added null check to prevent crashing the results screen if a question object is missing.
 * @param {Object} question The question object.
 * @returns {number} The max points possible (0, 1, or 2).
 */
function getQuestionPointsPossible(question) {
    // --- CRITICAL NULL CHECK: If the question object is null or invalid, return 0 points ---
    if (!question) {
        return 0;
    }
    // --- END FIX ---
    
    const type = (question.itemType || '').toLowerCase();
    // Check for question types that typically award multiple points
    if (type.includes('multipart') || type.includes('multiselect')) {
        return 2; 
    }
    // All other question types (MC, Hotspot, Text Entry) are assumed to be 1 point
    return 1;
}

         /**
             * Handles the click event for hotspot questions.
             * This is now a separate function so zoom can use it.
             */
            function handleHotspotClick(e) {
                // Don't do anything if a button is clicked
                if (e.target.tagName === 'BUTTON' || e.target.closest('button')) return;

                const canvasContainer = scalableContent;
                const rect = canvasContainer.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                // Store the user's click coordinates as a percentage of the canvas size.
                AppState.currentPathway.userSelections[0] = {
                    x: x / rect.width,
                    y: y / rect.height
                };
                
                // Show a marker where the user clicked.
                canvasContainer.querySelectorAll('.hotspot-click-marker').forEach(m => m.remove());
                const marker = document.createElement('div');
                marker.className = 'hotspot-click-marker';
                marker.style.left = `${x}px`;
                marker.style.top = `${y}px`;
                canvasContainer.appendChild(marker);

                // Add the submit button if it's not there
                if (!AppState.currentPathway.isQuiz && !document.getElementById('submit-hotspot-btn')) {
                    const submitBtn = document.createElement('button');
                    submitBtn.id = 'submit-hotspot-btn';
                    submitBtn.textContent = 'Submit Answer';
                    submitBtn.className = 'w-full px-6 py-3 mt-4 bg-blue-500 text-white font-semibold rounded-lg shadow-md hover:bg-blue-600';
                    submitBtn.onclick = evaluateHotspotAnswer;
                    answerInterface.appendChild(submitBtn);
                }
            }

            /**
             * Renders the interface for hotspot questions.
             * @param {Object} question The question object.
             */
            function renderHotspotInterface(question) {
                // Check if the teacher has defined the clickable zone yet.
                if (!question.interactiveZones || question.interactiveZones.length === 0) {
                    answerInterface.innerHTML = `<p class="text-center text-gray-500">This hotspot question is not yet configured. Please define the clickable area in the Review & Edit screen.</p>`;
                    return;
                }

                const canvasContainer = scalableContent;
                canvasContainer.style.cursor = 'pointer';

                // Remove any old listener before adding a new one
                canvasContainer.removeEventListener('click', handleHotspotClick);
                // Add the new, reusable listener
                canvasContainer.addEventListener('click', handleHotspotClick);
            }
            


function evaluateHotspotAnswer() {
    const question = AppState.currentPathway.activeQuestion;
    const userClick = AppState.currentPathway.userSelections[0]; 
    
    let isCorrect = false;
    // Loop through ALL defined zones for the question
    if (userClick && question.interactiveZones && question.interactiveZones.length > 0) {
        for (const zone of question.interactiveZones) {
            const translatedZone = translateZoneCoordinates(zone, question);
            if (userClick.x >= translatedZone.x &&
                userClick.x <= translatedZone.x + translatedZone.width &&
                userClick.y >= translatedZone.y &&
                userClick.y <= translatedZone.y + translatedZone.height) {
                
                isCorrect = true;
                break; // Found a match, no need to check other zones
            }
        }
    }
    
    showFeedback(isCorrect);
}

            /**
             * Renders the interface for text entry questions.
             * @param {Object} question The question object.
             */
            function renderTextEntryInterface(question) {
                const textInput = document.createElement('textarea');
                textInput.id = 'text-entry-input';
                textInput.className = 'w-full p-2 border rounded-md text-lg';
                textInput.rows = 4;
                textInput.placeholder = 'Type your answer here...';
                answerInterface.appendChild(textInput);

                if (!AppState.currentPathway.isQuiz) {
                    const submitBtn = document.createElement('button');
                    submitBtn.textContent = 'Submit Answer';
                    submitBtn.className = 'w-full mt-4 px-6 py-3 bg-green-600 text-white font-semibold rounded-lg shadow-md hover:bg-green-700';
                    submitBtn.onclick = () => {
                        const userAnswer = textInput.value.toLowerCase().trim();
                        const correctAnswer = (question.textEntryAnswer || "").toLowerCase().trim();
                        const isCorrect = userAnswer === correctAnswer;
                        showFeedback(isCorrect);
                    };
                    answerInterface.appendChild(submitBtn);
                }
            }
            
            /**
             * Renders the interface for drag-and-drop questions.
             * @param {Object} question The question object.
             */
            function renderDragAndDropInterface(question) {
                // Check for teacher setup.
                if (question.interactiveZones && question.interactiveZones.length > 0 && question.draggableOptions && question.draggableOptions.length > 0) {
                    // Create the drop zones on the canvas.
                    question.interactiveZones.forEach((zone) => {
                        const dropZone = document.createElement('div');
                        dropZone.className = 'drop-zone';
                        dropZone.dataset.zoneId = zone.id;

                        const translatedZone = translateZoneCoordinates(zone, question);
                        
                        dropZone.style.left = `${translatedZone.x * 100}%`;
                        dropZone.style.top = `${translatedZone.y * 100}%`;
                        dropZone.style.width = `${translatedZone.width * 100}%`;
                        dropZone.style.height = `${translatedZone.height * 100}%`;
                        
                        scalableContent.appendChild(dropZone);
                    });

                    // Create the bank of draggable items.
                    const dragItemsContainer = document.createElement('div');
                    dragItemsContainer.className = 'flex flex-wrap gap-2 justify-center p-4 bg-gray-100 rounded-lg mt-4';
                    question.draggableOptions.forEach(opt => {
                        const item = document.createElement('div');
                        item.className = 'drag-item';
                        item.textContent = opt;
                        item.draggable = true;
                        dragItemsContainer.appendChild(item);
                    });
                    answerInterface.appendChild(dragItemsContainer);
                    
                    if (!AppState.currentPathway.isQuiz) {
                        const submitBtn = document.createElement('button');
                        submitBtn.textContent = 'Check Answer';
                        submitBtn.className = 'w-full px-6 py-3 mt-4 bg-blue-500 text-white font-semibold rounded-lg shadow-md hover:bg-blue-600';
                        submitBtn.onclick = evaluateDragAndDropAnswer;
                        answerInterface.appendChild(submitBtn);
                    }

                    // --- Mouse Drag and Drop Events ---
                    answerInterface.addEventListener('dragstart', e => {
                        if (e.target.classList.contains('drag-item')) {
                            AppState.draggedItem = e.target;
                            setTimeout(() => e.target.classList.add('invisible'), 0);
                        }
                    });
                     answerInterface.addEventListener('dragend', e => {
                        if (AppState.draggedItem) AppState.draggedItem.classList.remove('invisible');
                    });
                    scalableContent.addEventListener('dragover', e => e.preventDefault());
                    scalableContent.addEventListener('drop', e => {
                        e.preventDefault();
                        const zone = e.target.closest('.drop-zone');
                        if (zone && AppState.draggedItem) {
                            if(zone.children.length > 0) return; // Prevent dropping on an occupied zone
                            const clone = AppState.draggedItem.cloneNode(true);
                            clone.classList.remove('invisible');
                            zone.appendChild(clone);
                        }
                    });

                    // --- Touch Drag and Drop Events ---
                    answerInterface.addEventListener('touchstart', e => {
                        if (e.target.classList.contains('drag-item')) {
                            e.preventDefault();
                            AppState.draggedItem = e.target;
                            
                            // Create a ghost element for visual feedback
                            const ghost = e.target.cloneNode(true);
                            ghost.classList.add('touch-drag-ghost');
                            document.body.appendChild(ghost);
                            AppState.touchDragGhost = ghost;

                            const touch = e.touches[0];
                            ghost.style.left = `${touch.clientX}px`;
                            ghost.style.top = `${touch.clientY}px`;
                        }
                    });

                    document.addEventListener('touchmove', e => {
                        if (AppState.draggedItem && AppState.touchDragGhost) {
                            e.preventDefault();
                            const touch = e.touches[0];
                            AppState.touchDragGhost.style.left = `${touch.clientX}px`;
                            AppState.touchDragGhost.style.top = `${touch.clientY}px`;

                            // Highlight drop zone
                            const targetElement = document.elementFromPoint(touch.clientX, touch.clientY);
                            document.querySelectorAll('.drop-zone').forEach(dz => dz.classList.remove('dragover'));
                            if (targetElement && targetElement.closest('.drop-zone')) {
                                targetElement.closest('.drop-zone').classList.add('dragover');
                            }
                        }
                    });

                    document.addEventListener('touchend', e => {
                        if (AppState.draggedItem && AppState.touchDragGhost) {
                            e.preventDefault();
                            const touch = e.changedTouches[0];
                            
                            AppState.touchDragGhost.style.display = 'none';
                            const targetElement = document.elementFromPoint(touch.clientX, touch.clientY);
                            AppState.touchDragGhost.style.display = '';
                            
                            document.querySelectorAll('.drop-zone').forEach(dz => dz.classList.remove('dragover'));
                            
                            if (targetElement) {
                                const zone = targetElement.closest('.drop-zone');
                                if (zone && zone.children.length === 0) {
                                    const clone = AppState.draggedItem.cloneNode(true);
                                    zone.appendChild(clone);
                                }
                            }
                            
                            // Cleanup
                            AppState.touchDragGhost.remove();
                            AppState.touchDragGhost = null;
                            AppState.draggedItem = null;
                        }
                    });


                } else {
                    answerInterface.innerHTML = `<p class="text-center text-gray-500">This drag & drop question is not yet configured. Please define drop zones and answer options in the Review & Edit screen.</p>`;
                }
            }
            
            /**
             * Translates global page coordinates for an interactive zone to local coordinates relative to the cropped canvas.
             * @param {Object} zone The interactive zone object.
             * @param {Object} question The question object.
             * @returns {Object} The translated zone coordinates.
             */
            function translateZoneCoordinates(zone, question) {
                const { cropBox, pageDimensions } = question;
                if (!cropBox) return zone; 

                const cropWidth = cropBox.width * pageDimensions.width;
                const cropHeight = cropBox.height * pageDimensions.height;
                const cropX = cropBox.x * pageDimensions.width;
                const cropY = cropBox.y * pageDimensions.height;

                const zoneAbsX = zone.x * pageDimensions.width;
                const zoneAbsY = zone.y * pageDimensions.height;
                const zoneAbsWidth = zone.width * pageDimensions.width;
                const zoneAbsHeight = zone.height * pageDimensions.height;
                
                const newRelX = zoneAbsX - cropX;
                const newRelY = zoneAbsY - cropY;

                return {
                    x: newRelX / cropWidth,
                    y: newRelY / cropHeight,
                    width: zoneAbsWidth / cropWidth,
                    height: zoneAbsHeight / cropHeight
                };
            }

            /**
             * Evaluates the user's answers for a drag-and-drop question.
             */
            function evaluateDragAndDropAnswer() {
                const question = AppState.currentPathway.activeQuestion;
                let allCorrect = true;
                if (!question.interactiveZones || question.interactiveZones.length === 0) allCorrect = false;

                question.interactiveZones.forEach(zone => {
                    const dropZoneEl = scalableContent.querySelector(`.drop-zone[data-zone-id="${zone.id}"]`);
                    const droppedItem = dropZoneEl ? dropZoneEl.querySelector('.drag-item') : null;
                    const droppedAnswer = droppedItem ? droppedItem.textContent.trim() : null;
                    
                    if (droppedAnswer !== zone.correctAnswer) {
                        allCorrect = false;
                    }
                });
                showFeedback(allCorrect);
            }

            /**
             * Renders the interface for inline choice (dropdown) questions.
             * @param {Object} question The question object.
             */
        
function renderInlineChoiceInterface(question) {
    const container = document.createElement('div');
    container.className = 'text-center text-lg p-4 bg-gray-50 rounded-lg border border-gray-200';
    
    // Safety Check: Do we have answers?
    if (!question.inlineChoiceAnswer || question.inlineChoiceAnswer.length === 0) {
            container.innerHTML = `
            <div class="flex flex-col items-center justify-center p-4 text-gray-500">
                <p class="mb-2 italic">Dropdown options not detected automatically.</p>
                <p class="text-xs bg-yellow-100 text-yellow-800 px-2 py-1 rounded">
                    Use "Review & Edit" to configure the dropdowns for this question.
                </p>
            </div>`;
            answerInterface.appendChild(container);
            return;
    }

    // 1. Instructions
    const instruction = document.createElement('p');
    instruction.className = 'mb-6 font-semibold text-gray-700 border-b pb-2';
    instruction.textContent = `Select the correct option for each blank in the image above:`;
    container.appendChild(instruction);

    // 2. Container for Dropdowns
    const flexContainer = document.createElement('div');
    flexContainer.className = 'flex flex-wrap items-center justify-center gap-6';
    
    // 3. Dynamically create a dropdown for EACH required answer part
    question.inlineChoiceAnswer.forEach((ans, index) => {
        const wrapper = document.createElement('div');
        wrapper.className = 'flex flex-col items-center';
        
        const label = document.createElement('span');
        label.className = 'text-xs uppercase font-bold text-gray-400 mb-1';
        label.textContent = `Blank #${index + 1}`;
        wrapper.appendChild(label);

        const select = document.createElement('select');
        select.className = 'inline-choice-select p-3 border-2 border-indigo-100 rounded-lg shadow-sm bg-white focus:border-indigo-500 focus:ring-indigo-500 text-gray-700 font-medium';
        select.dataset.index = index;
        
        // Add a default "Select..." option
        const defaultOpt = document.createElement('option');
        defaultOpt.value = "";
        defaultOpt.textContent = "Select Option...";
        select.appendChild(defaultOpt);

        // Create the CORRECT answer option
        const correctOpt = document.createElement('option');
        correctOpt.value = ans;
        correctOpt.textContent = ans; 

        // Create the DISTRACTOR option
        const distractOpt = document.createElement('option');
        distractOpt.value = "Incorrect Option";
        distractOpt.textContent = "(Incorrect Option)";

        // FIXED: Randomizer Logic
        // We simply choose which order to append them in.
        if (Math.random() > 0.5) {
            select.appendChild(distractOpt);
            select.appendChild(correctOpt);
        } else {
            select.appendChild(correctOpt);
            select.appendChild(distractOpt);
        }

        wrapper.appendChild(select);
        flexContainer.appendChild(wrapper);
    });

    container.appendChild(flexContainer);
    answerInterface.appendChild(container);

    // 4. Submit Button
    if (!AppState.currentPathway.isQuiz) {
        const submitBtn = document.createElement('button');
        submitBtn.textContent = 'Submit Answer';
        submitBtn.className = 'w-full mt-6 px-6 py-3 bg-green-600 text-white font-semibold rounded-lg shadow-md hover:bg-green-700 transition-all';
        submitBtn.onclick = evaluateInlineChoiceAnswer;
        answerInterface.appendChild(submitBtn);
    }
}

            /**
             * Evaluates the answers for an inline choice question.
             */
            function evaluateInlineChoiceAnswer() {
                const question = AppState.currentPathway.activeQuestion;
                const selects = answerInterface.querySelectorAll('.inline-choice-select');
                const userAnswers = [];
                selects.forEach(select => {
                    userAnswers.push(select.value);
                });
                
                const isCorrect = JSON.stringify(userAnswers) === JSON.stringify(question.inlineChoiceAnswer);
                showFeedback(isCorrect);
            }

       // ADD THIS ENTIRE NEW FUNCTION
            
            /**
             * Renders a question's PDF page(s) to an array of canvas elements.
             * This is a reusable function for both student view and printing.
             * @param {Object} question The question object.
             * @param {number} scale The rendering scale (e.g., 2.0 for student view, 1.5 for print)
             * @returns {Promise<HTMLCanvasElement[]>} A promise that resolves to an array of canvas elements.
             */

async function createQuestionCanvases(question, scale = 2.0, useCrop = true) {
    const canvases = [];
    
    // Safety check
    if (!question) return canvases;

    const subjectData = getCurrentSubjectData();
    const pdfIndex = question.pdfIndex !== undefined ? question.pdfIndex : 0;
    const pdfDoc = subjectData.pdfDocs[pdfIndex];

    if (!pdfDoc) {
        console.error(`PDF Doc not found for index ${pdfIndex}.`);
        return canvases;
    }

    try {
        // Handle multi-page questions
        if (question.pageNums && question.pageNums.length > 0) {
            for (const pageNum of question.pageNums) {
                // Validate page number
                if (pageNum < 1 || pageNum > pdfDoc.numPages) continue;

                const page = await pdfDoc.getPage(pageNum);
                const viewport = page.getViewport({ scale });
                const canvas = document.createElement('canvas');
                canvas.width = viewport.width;
                canvas.height = viewport.height;
                canvas.style.display = 'block';
                canvas.style.marginBottom = '1rem';
                await page.render({ canvasContext: canvas.getContext('2d'), viewport }).promise;
                canvases.push(canvas);
            }
        } else { 
            // Handle single-page questions
            // Validate page number
            if (!question.pageNum || question.pageNum < 1 || question.pageNum > pdfDoc.numPages) {
                console.error(`Invalid page number ${question.pageNum} for question ${question.id}`);
                return canvases;
            }

            const canvas = document.createElement('canvas');
            const page = await pdfDoc.getPage(question.pageNum);
            const viewport = page.getViewport({ scale });
            
            const offscreenCanvas = document.createElement('canvas');
            const offscreenContext = offscreenCanvas.getContext('2d');
            offscreenCanvas.width = viewport.width;
            offscreenCanvas.height = viewport.height;
            await page.render({ canvasContext: offscreenContext, viewport }).promise;

            if (question.cropBox && useCrop) {
                const { x, y, width, height } = question.cropBox;
                const sx = x * offscreenCanvas.width;
                const sy = y * offscreenCanvas.height;
                const sWidth = width * offscreenCanvas.width;
                const sHeight = height * offscreenCanvas.height;

                canvas.width = sWidth;
                canvas.height = sHeight;

                if (sWidth > 0 && sHeight > 0) {
                    canvas.getContext('2d').drawImage(
                        offscreenCanvas,
                        sx, sy, sWidth, sHeight,
                        0, 0, canvas.width, canvas.height
                    );
                } else { 
                    canvas.width = offscreenCanvas.width;
                    canvas.height = offscreenCanvas.height;
                    canvas.getContext('2d').drawImage(offscreenCanvas, 0, 0);
                }
            } else {
                canvas.width = offscreenCanvas.width;
                canvas.height = offscreenCanvas.height;
                canvas.getContext('2d').drawImage(offscreenCanvas, 0, 0);
            }
            canvases.push(canvas);
        }
    } catch (error) {
        console.error(`Error rendering canvas for question ${question.id}:`, error);
    }
    
    return canvases;
}
 // --- NEW INTERACTIVE GRAPHING FUNCTIONS ---
            function renderGraphingInterface(question) {
                // Add the graph type selector UI
                const selectorContainer = document.createElement('div');
                selectorContainer.className = 'graph-type-selector';
                selectorContainer.innerHTML = `
                    <button class="graph-type-btn active" data-type="line">Line</button>
                    <button class="graph-type-btn" data-type="quadratic" disabled>Parabola</button>
                    <button class="graph-type-btn" data-type="exponential" disabled>Exponential</button>
                `;
                answerInterface.appendChild(selectorContainer);
                
                const canvas = document.createElement('canvas');
                canvas.id = 'graphing-canvas';
                canvas.width = 500;
                canvas.height = 500;
                answerInterface.appendChild(canvas);

                const ctx = canvas.getContext('2d');
                const range = { x: 10, y: 10 };
                let dragState = {
                    isDragging: false,
                    target: null, // can be 'p1', 'p2', or 'line'
                    offsetX: 0,
                    offsetY: 0
                };

                // Initialize the current graphing mode
                AppState.currentPathway.graphingMode = 'line';

                const redrawCanvas = () => {
                    drawGrid(ctx, canvas.width, canvas.height, range);
                    const points = AppState.currentPathway.graphingPoints;
                    if (points.length > 0) drawPoint(ctx, points[0], '#ef4444');
                    if (points.length > 1) {
                        drawPoint(ctx, points[1], '#3b82f6');
                        drawLine(ctx, points[0], points[1]);
                    }
                };

               // --- THIS IS THE CORRECTED getMousePos ---
                const getMousePos = (e) => {
                    const rect = canvas.getBoundingClientRect();
                    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                    
                    // Calculate the raw offset relative to the displayed canvas
                    const rawX = clientX - rect.left;
                    const rawY = clientY - rect.top;
                    
                    // Calculate scaling factors
                    const scaleX = canvas.width / rect.width;   // internal width / displayed width
                    const scaleY = canvas.height / rect.height; // internal height / displayed height
                    
                    // Return scaled coordinates
                    return {
                        x: rawX * scaleX,
                        y: rawY * scaleY
                    };
                };

                const handleInteractionStart = (e) => {
                    e.preventDefault();
                    const pos = getMousePos(e);
                    const points = AppState.currentPathway.graphingPoints;

                    // If we have a full line, check for dragging first
                    if (points.length >= 2) {
                        const p1Dist = Math.hypot(pos.x - points[0].x, pos.y - points[0].y);
                        const p2Dist = Math.hypot(pos.x - points[1].x, pos.y - points[1].y);

                        if (p1Dist < 10) {
                            dragState = { isDragging: true, target: 'p1' };
                            return;
                        } else if (p2Dist < 10) {
                            dragState = { isDragging: true, target: 'p2' };
                            return;
                        } else {
                             dragState = { isDragging: true, target: 'line', offsetX: pos.x - points[0].x, offsetY: pos.y - points[0].y };
                             return;
                        }
                    }

                    // *** THIS IS THE FIX: If not dragging, add a point ***
                    if (points.length < 2) {
                        AppState.currentPathway.graphingPoints.push(pos);
                        redrawCanvas();
                        // If this was the second point, show the submit button
                        if (points.length === 2 && !AppState.currentPathway.isQuiz && !document.getElementById('submit-graph-btn')) {
                            const submitBtn = document.createElement('button');
                            submitBtn.id = "submit-graph-btn";
                            submitBtn.textContent = 'Submit Answer';
                            submitBtn.className = 'w-full mt-4 px-6 py-3 bg-green-600 text-white font-semibold rounded-lg shadow-md hover:bg-green-700';
                            submitBtn.onclick = evaluateGraphingAnswer;
                            answerInterface.appendChild(submitBtn);
                        }
                    }
                };

                const handleInteractionMove = (e) => {
                    if (!dragState.isDragging) return;
                    e.preventDefault();
                    const pos = getMousePos(e);
                    const points = AppState.currentPathway.graphingPoints;

                    if (dragState.target === 'p1') {
                        points[0] = { x: pos.x, y: pos.y };
                    } else if (dragState.target === 'p2') {
                        points[1] = { x: pos.x, y: pos.y };
                    } else if (dragState.target === 'line') {
                        const dx = (pos.x - dragState.offsetX) - points[0].x;
                        const dy = (pos.y - dragState.offsetY) - points[0].y;
                        points[0].x += dx;
                        points[0].y += dy;
                        points[1].x += dx;
                        points[1].y += dy;
                    }
                    redrawCanvas();
                };

                const handleInteractionEnd = (e) => {
                    dragState.isDragging = false;
                };

                // Assign all events
                canvas.addEventListener('mousedown', handleInteractionStart);
                canvas.addEventListener('mousemove', handleInteractionMove);
                canvas.addEventListener('mouseup', handleInteractionEnd);
                canvas.addEventListener('mouseleave', handleInteractionEnd);
                canvas.addEventListener('touchstart', handleInteractionStart);
                canvas.addEventListener('touchmove', handleInteractionMove);
                canvas.addEventListener('touchend', handleInteractionEnd);
                
                redrawCanvas();
            }

            function drawGrid(ctx, width, height, range) {
                ctx.clearRect(0, 0, width, height);
                ctx.strokeStyle = '#e2e8f0';
                ctx.lineWidth = 1;
                const origin = { x: width / 2, y: height / 2 };
                const stepX = width / (range.x * 2);
                const stepY = height / (range.y * 2);

                for (let i = -range.x; i <= range.x; i++) {
                    ctx.beginPath();
                    ctx.moveTo(origin.x + i * stepX, 0);
                    ctx.lineTo(origin.x + i * stepX, height);
                    ctx.stroke();
                }
                for (let i = -range.y; i <= range.y; i++) {
                    ctx.beginPath();
                    ctx.moveTo(0, origin.y + i * stepY);
                    ctx.lineTo(width, origin.y + i * stepY);
                    ctx.stroke();
                }

                ctx.strokeStyle = '#4b5563';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, origin.y);
                ctx.lineTo(width, origin.y);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(origin.x, 0);
                ctx.lineTo(origin.x, height);
                ctx.stroke();
            }

            function drawPoint(ctx, point, color) {
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(point.x, point.y, 8, 0, 2 * Math.PI);
                ctx.fill();
            }

            function drawLine(ctx, p1, p2) {
                ctx.strokeStyle = '#3b82f6';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();
            }
            
            function evaluateGraphingAnswer() {
                const question = AppState.currentPathway.activeQuestion;
                if (!question.graphingAnswer || question.graphingAnswer.length < 2 || AppState.currentPathway.graphingPoints.length < 2) {
                    showFeedback(false);
                    return;
                }

                const parsePoint = str => {
                    const coords = str.match(/-?\d+/g);
                    return { x: parseInt(coords[0]), y: parseInt(coords[1]) };
                };
                const correctP1 = parsePoint(question.graphingAnswer[0]);
                const correctP2 = parsePoint(question.graphingAnswer[1]);

                const correctSlope = (correctP2.y - correctP1.y) / (correctP2.x - correctP1.x);
                const correctYIntercept = correctP1.y - correctSlope * correctP1.x;

                const canvas = document.getElementById('graphing-canvas');
                const range = { x: 10, y: 10 };
                const origin = { x: canvas.width / 2, y: canvas.height / 2 };
                const stepX = canvas.width / (range.x * 2);
                const stepY = canvas.height / (range.y * 2);
                
                const toGridCoords = p => ({
                    x: (p.x - origin.x) / stepX,
                    y: -(p.y - origin.y) / stepY
                });

                const userP1 = toGridCoords(AppState.currentPathway.graphingPoints[0]);
                const userP2 = toGridCoords(AppState.currentPathway.graphingPoints[1]);

                const userSlope = (userP2.y - userP1.y) / (userP2.x - userP1.x);
                const userYIntercept = userP1.y - userSlope * userP1.x;
                
                const slopeMatch = Math.abs(userSlope - correctSlope) < 0.1; 
                const interceptMatch = Math.abs(userYIntercept - correctYIntercept) < 0.5;

                showFeedback(slopeMatch && interceptMatch);
            }

            /**
             * Updates the TEKS context box with the current question's information.
             */
            function updateTeksContext(question){
                teksContextNew.innerHTML = `<span class="font-bold">${question.teks}</span>: ${question.teksDescription || ''}`;
                teksContextOld.textContent = question.oldTeks ? `Formerly: ${question.oldTeks}` : '';
            }

            /**
             * Toggles the visibility of the TEKS context box.
             */
            function toggleTeksVisibility() {
                const isHidden = teksContextDiv.classList.toggle('hidden');
                toggleTeksBtn.textContent = isHidden ? 'Show Standard' : 'Hide Standard';
            }
            
/**
 * Shows feedback to the user after they answer a question in practice mode.
 * UPDATED: Calculates and saves raw points earned for variable point scoring.
 * @param {boolean} isOverallCorrect Whether the answer was fully correct.
 * @param {number} correctCount The number of correct parts/points earned.
 */
function showFeedback(isOverallCorrect, correctCount = 0) {
    const subjectData = getCurrentSubjectData();
    const pathway = AppState.currentPathway;
    const question = pathway.activeQuestion;
    const pointsPossible = getQuestionPointsPossible(question);

    // --- QUIZ MODE: SILENT EXECUTION ---
    if (pathway.isQuiz) {
        // 1. Save the Score (Using the exact inputs from the Practice Engine)
        // If correctCount is provided (partial credit), use it. Otherwise calc based on boolean.
        let scoreToSave = 0;
        
        if (correctCount > 0) {
            scoreToSave = correctCount;
        } else {
            scoreToSave = isOverallCorrect ? pointsPossible : 0;
        }

        subjectData.masteryState[pathway.teks][pathway.currentIndex] = scoreToSave;
        
        // 2. Advance Immediately (No visual feedback)
        if (pathway.currentIndex < pathway.questions.length - 1) {
            pathway.currentIndex++;
            renderProblem(pathway.questions[pathway.currentIndex]);
        } else {
            renderResultsScreen();
        }
        return; // EXIT HERE so no UI updates happen
    }

    // --- Practice Mode Logic ---
    
    // 2. Lock Interface
    answerInterface.querySelectorAll('button, textarea, select, canvas').forEach(el => {
        el.classList.add('disabled');
        el.onclick = null;
    });
    scalableContent.style.cursor = 'default';

    // 3. Determine Specific Feedback Text (Red/Green Box)
    let specificFeedback = "";
    const isMultipart = (question.itemType || "").toLowerCase().includes('multipart');
    
    // Logic for Rationales (Display only)
    if (question.rationaleMap && pathway.userSelections.length > 0) {
        
        // Loop through EVERY selection (Handles Part A and Part B)
        pathway.userSelections.flat().forEach((userChoice, index) => {
            let lookupKey = userChoice;
            let label = `Option ${userChoice}`;

            // --- SMART KEY DETECTION ---
            const hasMultipartKeys = Object.keys(question.rationaleMap).some(k => k.startsWith('Part'));
            
            if (hasMultipartKeys) {
                const prefix = index === 0 ? "PartA_" : "PartB_";
                let normalizedLetter = userChoice;
                const mapToStandard = {'F':'A', 'G':'B', 'H':'C', 'J':'D'};
                if (index === 1 && mapToStandard[userChoice]) {
                    normalizedLetter = mapToStandard[userChoice];
                }
                lookupKey = `${prefix}${normalizedLetter}`;
                label = index === 0 ? `Part A (Option ${userChoice})` : `Part B (Option ${userChoice})`;
            }

            // --- NEW: PER-PART GRADING LOGIC (Same logic as used for the score) ---
            let isPartCorrect = false;
            
            if (isMultipart) {
                const correctForPart = question.answerText && question.answerText[index];
                if (correctForPart && userChoice === correctForPart) {
                    isPartCorrect = true;
                }
            } else {
                if (question.answerText && question.answerText.includes(userChoice)) {
                    isPartCorrect = true;
                }
            }

            // Set color based on THIS part's correctness, not the overall score
            const colorClass = isPartCorrect 
                ? "bg-green-50 border-green-200 text-green-800" 
                : "bg-red-50 border-red-200 text-red-800";
            
            const icon = isPartCorrect ? "‚úÖ" : "‚ùå";

            // Perform the Lookup and Display
            if (question.rationaleMap[lookupKey]) {
                specificFeedback += `
                    <div class="mt-2 p-3 rounded border ${colorClass} text-left text-sm">
                        <span class="font-bold block mb-1">${icon} Explanation for ${label}:</span>
                        ${question.rationaleMap[lookupKey]}
                    </div>`;
            } else {
                // Fallback if we have no rationale but want to show right/wrong status
                specificFeedback += `
                    <div class="mt-2 p-3 rounded border ${colorClass} text-left text-sm">
                        <span class="font-bold block mb-1">${icon} Selection: ${label}</span>
                        (No detailed explanation available)
                    </div>`;
            }
        });
    }

    // 4. Show Header Status 
    feedbackMessage.innerHTML = '';
    
    let headerText = "";
    if (isOverallCorrect) {
        headerText = "Correct! Great job.";
    } else if (correctCount > 0) {
        // Use raw points to show feedback
        headerText = `Partially Correct. (${correctCount} of ${pointsPossible} points earned)`;
    } else {
        headerText = "Incorrect.";
    }

    const headerHtml = `<div class="${isOverallCorrect ? 'text-green-600' : 'text-red-600'} text-lg font-bold">
                            ${headerText}
                        </div>`;
    
    feedbackMessage.innerHTML = headerHtml + specificFeedback;

    // 5. Highlight Buttons (Display only)
    answerInterface.querySelectorAll('.answer-button.selected').forEach(btn => {
        if (isOverallCorrect) {
            btn.classList.add('correct');
        } else {
             btn.classList.add('incorrect');
        }
    });

    // 6. Handle "Correct Answer" Strip Visibility
    if (isOverallCorrect) {
        const answerString = question.answerText?.join(', ') || 'N/A';
        correctAnswerDisplay.textContent = `The correct answer is: ${answerString}`;
        correctAnswerContainer.classList.remove('hidden');
        showConfetti();
    } else {
        correctAnswerContainer.classList.add('hidden');
    }

    // 7. Update State (SAVE THE NUMERICAL SCORE)
    const scoreToSave = correctCount; // Save the raw points earned (0, 1, or 2)
    subjectData.masteryState[pathway.teks][pathway.currentIndex] = scoreToSave;
    renderClickableProgressBar();

    retryProblemBtn.classList.toggle('hidden', isOverallCorrect);
    saveState();
}
            
function showConfetti() {
    const container = document.getElementById('confetti-container');
    // Get current theme settings
    const theme = SubjectThemes[AppState.currentSubject] || SubjectThemes['Algebra 1'];
    const colors = theme.confettiColors;
    
    for (let i = 0; i < 60; i++) {
        const confetti = document.createElement('div');
        confetti.className = 'confetti';
        
        // Apply Shape Class
        if (theme.confettiShape === 'star') confetti.classList.add('confetti-star');
        else if (theme.confettiShape === 'triangle') confetti.classList.add('confetti-triangle');
        else if (theme.confettiShape === 'circle') confetti.style.borderRadius = '50%';
        
        // Random Positioning
        confetti.style.left = `${Math.random() * 100}vw`;
        confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
        confetti.style.animationDelay = `${Math.random() * 0.5}s`;
        confetti.style.transform = `rotate(${Math.random() * 360}deg)`;
        
        container.appendChild(confetti);

        setTimeout(() => {
            confetti.remove();
        }, 5500);
    }
}
  
/**
             * Renders a visual overlay on the review canvas to show where text items were detected.
             * @param {Event} event The click event from the button.
             */
            function renderDebugOverlay(event) {
                const questionId = event.target.dataset.questionId;
                const question = getCurrentSubjectData().allQuestions.find(q => q.id === questionId);
                const container = document.getElementById(`scalable-content-review-${question.id}`);
                const canvas = container.querySelector('.review-canvas');

                if (!question || !canvas) return;

                // Clear any previous overlays
                container.querySelectorAll('.debug-text-box').forEach(box => box.remove());

                const canvasRect = canvas.getBoundingClientRect();

                question.rawItems.forEach(item => {
                    // pdf.js coordinates have origin at bottom-left, so we need to convert
                    // item.transform[4] is x-coordinate
                    // item.transform[5] is y-coordinate from the bottom
                    const x = item.transform[4];
                    const y = item.transform[5];
                    const width = item.width;
                    const height = item.height;

                    // Convert to top-left origin for CSS absolute positioning
                    const top = canvasRect.height - y - height;
                    const left = x;

                    const box = document.createElement('div');
                    box.className = 'debug-text-box';
                    box.style.position = 'absolute';
                    box.style.left = `${left}px`;
                    box.style.top = `${top}px`;
                    box.style.width = `${width}px`;
                    box.style.height = `${height}px`;
                    box.style.backgroundColor = 'rgba(255, 255, 0, 0.3)'; // Semi-transparent yellow
                    box.style.border = '1px solid #f59e0b'; // Orange border
                    box.style.pointerEvents = 'none'; // So it doesn't interfere with clicks
                    box.title = item.str; // Show the text on hover for debugging
                    container.appendChild(box);
                });
            }
        
            function updateDraggableOptions(event) {
                const questionId = event.target.dataset.questionId;
                const question = getCurrentSubjectData().allQuestions.find(q => q.id === questionId);
                if (question) {
                    // Read comma-separated values, trim whitespace, and filter out empty strings
                    question.draggableOptions = event.target.value.split(',').map(s => s.trim()).filter(Boolean);
                    // Re-render the editor to show the new bank and check for zone matches
                    setupAnswerKeyEditor(question);
                }
            }

            /**
             * Clears all defined interactive zones for a question.
             */
            function clearInteractiveZones(event) {
                const questionId = event.target.dataset.questionId;
                const question = getCurrentSubjectData().allQuestions.find(q => q.id === questionId);
                if (question) {
                    question.interactiveZones = [];
                    redrawZones(question);
                    if (question.itemType.toLowerCase().includes('drag and drop')) {
                        setupAnswerKeyEditor(question);
                    }
                }
            }
            
            /**
             * Redraws the interactive zone boxes on the review canvas.
             */
            function redrawZones(question) {
                const container = document.getElementById(`scalable-content-review-${question.id}`);
                container.querySelectorAll('.drawn-box').forEach(box => box.remove());
                question.interactiveZones.forEach(zone => {
                    const box = document.createElement('div');
                    box.className = 'drawn-box';
                    box.style.left = `${zone.x * 100}%`;
                    box.style.top = `${zone.y * 100}%`;
                    box.style.width = `${zone.width * 100}%`;
                    box.style.height = `${zone.height * 100}%`;
                    box.dataset.id = zone.id;
                    
                    const deleteBtn = document.createElement('div');
                    deleteBtn.className = 'delete-btn';
                    deleteBtn.innerHTML = '&times;';
                    deleteBtn.onclick = (e) => {
                        e.stopPropagation();
                        question.interactiveZones = question.interactiveZones.filter(z => z.id !== zone.id);
                        redrawZones(question);
                         if (question.itemType.toLowerCase().includes('drag and drop')) {
                            setupAnswerKeyEditor(question);
                        }
                    };
                    box.appendChild(deleteBtn);
                    
                    makeBoxDraggable(box, zone, question);
                    container.appendChild(box);
                });
            }

            // REPLACE your current enterLayoutEditorMode function with this one

// REPLACE your current enterLayoutEditorMode function with this one

function enterLayoutEditorMode(event) {
    const questionId = event.target.dataset.questionId;
    const question = getCurrentSubjectData().allQuestions.find(q => q.id === questionId);
    const canvas = document.querySelector(`#review-container-${question.id} .review-canvas`); // Target the first canvas
    const container = document.getElementById(`scalable-content-review-${question.id}`);

    if (!question || !canvas || container.querySelector('.layout-editor-overlay')) return;

    const overlay = document.createElement('div');
    overlay.className = 'layout-editor-overlay layout-editor-active';
    container.appendChild(overlay);

    let startX, startY, selectionBox;

    const getCoords = (e) => {
        if (e.touches) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: e.touches[0].clientX - rect.left,
                y: e.touches[0].clientY - rect.top
            };
        }
        return { x: e.offsetX, y: e.offsetY };
    }

    const startDraw = (e) => {
        e.preventDefault();
        const coords = getCoords(e);
        startX = coords.x;
        startY = coords.y;
        selectionBox = document.createElement('div');
        selectionBox.className = 'selection-box';
        selectionBox.style.left = `${startX}px`;
        selectionBox.style.top = `${startY}px`;
        overlay.appendChild(selectionBox);
    };

    const draw = (e) => {
        if (selectionBox) {
            e.preventDefault();
            const coords = getCoords(e);
            const width = coords.x - startX;
            const height = coords.y - startY;
            selectionBox.style.width = `${Math.abs(width)}px`;
            selectionBox.style.height = `${Math.abs(height)}px`;
            if (width < 0) selectionBox.style.left = `${coords.x}px`;
            if (height < 0) selectionBox.style.top = `${coords.y}px`;
        }
    };

    const endDraw = (e) => {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const endCoords = getCoords(e.changedTouches ? e.changedTouches[0] : e);

        const newZone = {
            id: `zone-${Date.now()}`,
            x: Math.min(startX, endCoords.x) / rect.width,
            y: Math.min(startY, endCoords.y) / rect.height,
            width: Math.abs(endCoords.x - startX) / rect.width,
            height: Math.abs(endCoords.y - startY) / rect.height,
            correctAnswer: null
        };

        if(question.itemType.toLowerCase().includes('hot spot')) {
            question.interactiveZones = [newZone];
            question.needsReview = false;
        } else {
            question.interactiveZones.push(newZone);
        }

        redrawZones(question);
        if (question.itemType.toLowerCase().includes('drag and drop')) {
            setupAnswerKeyEditor(question);
        }
        overlay.remove();
    };

    overlay.addEventListener('mousedown', startDraw);
    overlay.addEventListener('mousemove', draw);
    overlay.addEventListener('mouseup', endDraw);
    overlay.addEventListener('touchstart', startDraw);
    overlay.addEventListener('touchmove', draw);
    overlay.addEventListener('touchend', endDraw);
}
            /**
             * Makes the interactive zone boxes draggable and resizable in the review modal.
             */
            function makeBoxDraggable(boxElement, zone, question) {
                const startDrag = (e) => {
                    e.preventDefault();
                    e.stopPropagation();

                    AppState.isDraggingBox = true;
                    AppState.draggedBoxElement = boxElement;
                    AppState.draggedBoxZone = zone;
                    AppState.draggedBoxQuestion = question;
                    
                    const rect = boxElement.parentElement.getBoundingClientRect();
                    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                    const clientY = e.touches ? e.touches[0].clientY : e.clientY;

                    AppState.dragStartX = clientX - boxElement.getBoundingClientRect().left + rect.left;
                    AppState.dragStartY = clientY - boxElement.getBoundingClientRect().top + rect.top;
                };

                const drag = (e) => {
                    if (!AppState.isDraggingBox || !AppState.draggedBoxElement) return;
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                    const clientY = e.touches ? e.touches[0].clientY : e.clientY;

                    const containerRect = AppState.draggedBoxElement.parentElement.getBoundingClientRect();
                    let newX = clientX - AppState.dragStartX;
                    let newY = clientY - AppState.dragStartY;

                    // Constrain to parent bounds
                    newX = Math.max(0, Math.min(newX, containerRect.width - AppState.draggedBoxElement.offsetWidth));
                    newY = Math.max(0, Math.min(newY, containerRect.height - AppState.draggedBoxElement.offsetHeight));

                    AppState.draggedBoxElement.style.left = `${newX}px`;
                    AppState.draggedBoxElement.style.top = `${newY}px`;
                };

                const endDrag = (e) => {
                    if (!AppState.isDraggingBox || !AppState.draggedBoxElement) return;
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const containerRect = AppState.draggedBoxElement.parentElement.getBoundingClientRect();
                    const finalX = parseFloat(AppState.draggedBoxElement.style.left);
                    const finalY = parseFloat(AppState.draggedBoxElement.style.top);

                    // Update the zone data with new percentage-based coordinates
                    AppState.draggedBoxZone.x = finalX / containerRect.width;
                    AppState.draggedBoxZone.y = finalY / containerRect.height;

                    // Reset dragging state
                    AppState.isDraggingBox = false;
                    AppState.draggedBoxElement = null;
                    AppState.draggedBoxZone = null;
                    AppState.draggedBoxQuestion = null;
                };

                boxElement.addEventListener('mousedown', startDrag);
                document.addEventListener('mousemove', drag);
                document.addEventListener('mouseup', endDrag);
                boxElement.addEventListener('touchstart', startDrag);
                document.addEventListener('touchmove', drag);
                document.addEventListener('touchend', endDrag);
            }

            /**
             * Sets up the answer key editor for drag-and-drop questions in the review modal.
             */
            function setupAnswerKeyEditor(question) {
                const keyZonesContainer = document.getElementById(`key-zones-${question.id}`);
                const bankContainer = document.getElementById(`dnd-bank-${question.id}`);
                if (!keyZonesContainer || !bankContainer) return;
                
                keyZonesContainer.innerHTML = ''; 
                bankContainer.innerHTML = '';
                
                question.draggableOptions.forEach(opt => {
                    const item = document.createElement('div');
                    item.className = 'drag-item';
                    item.textContent = opt;
                    item.draggable = true;
                    bankContainer.appendChild(item);
                });

                question.interactiveZones.forEach((zone, index) => {
                    const keyZone = document.createElement('div');
                    keyZone.className = 'key-drop-zone';
                    keyZone.dataset.zoneId = zone.id;
                    keyZone.innerHTML = `<span class="drop-zone-label">Box ${index + 1}</span>`;
                    if (zone.correctAnswer) {
                        const item = document.createElement('div');
                        item.className = 'drag-item';
                        item.textContent = zone.correctAnswer;
                        keyZone.appendChild(item);
                    }
                    keyZonesContainer.appendChild(keyZone);
                });

                bankContainer.addEventListener('dragstart', e => {
                    if(e.target.classList.contains('drag-item')) {
                        AppState.draggedItem = e.target;
                    }
                });

                keyZonesContainer.addEventListener('dragover', e => {
                    e.preventDefault();
                    const zone = e.target.closest('.key-drop-zone');
                    if (zone) zone.classList.add('dragover');
                });

                keyZonesContainer.addEventListener('dragleave', e => {
                    const zone = e.target.closest('.key-drop-zone');
                    if (zone) zone.classList.remove('dragover');
                });

                keyZonesContainer.addEventListener('drop', e => {
                    e.preventDefault();
                    const zone = e.target.closest('.key-drop-zone');
                    if (zone && AppState.draggedItem) {
                        zone.classList.remove('dragover');
                        const targetZone = getCurrentSubjectData().allQuestions.find(q => q.id === question.id).interactiveZones.find(z => z.id === zone.dataset.zoneId);
                        if (targetZone) {
                            targetZone.correctAnswer = AppState.draggedItem.textContent;
                            
                            // Check if all zones are filled to mark as reviewed
                            const allZonesFilled = question.interactiveZones.every(z => z.correctAnswer);
                            if (allZonesFilled) {
                                question.needsReview = false;
                            }
                            setupAnswerKeyEditor(question);
                        }
                    }
                });
            }

       /**
             * Updates the zoom level of a specific target (passage or question).
             */
            function updateZoom(amount, target) {
                const passageContent = document.getElementById('passage-content-wrapper');

                if (target === 'passage' && passageContent) {
                    // Update and apply zoom ONLY for the passage
                    AppState.passageZoomLevel = Math.max(0.5, Math.min(3, AppState.passageZoomLevel + amount));
                    passageContent.style.transform = `scale(${AppState.passageZoomLevel})`;
                    passageContent.style.transformOrigin = 'top left';

                } else if (target === 'question') {
                    // Update and apply zoom ONLY for the question
                    AppState.zoomLevel = Math.max(0.5, Math.min(3, AppState.zoomLevel + amount));
                    scalableContent.style.transform = `scale(${AppState.zoomLevel})`;
                }
            }

            function showHistoryModal() {
    const modalId = 'history-modal';
    document.getElementById(modalId)?.remove();

    const subjectData = getCurrentSubjectData();
    const history = subjectData.resultHistory || [];
    const sortedHistory = [...history].sort((a, b) => b.id - a.id);

    let listHTML = '';

    if (sortedHistory.length === 0) {
        listHTML = `
            <div class="text-center p-8 text-gray-500">
                <p class="text-4xl mb-2">üìú</p>
                <p>No history found yet.</p>
            </div>`;
    } else {
        listHTML = sortedHistory.map(item => {
            const targets = AppState.difficultySettings.targets;
            let badgeClass = "bg-red-100 text-red-700 border-red-200";
            let label = "Did Not Meet";
            
            if (item.percent >= targets.masters) {
                badgeClass = "bg-purple-100 text-purple-700 border-purple-200";
                label = "Masters";
            } else if (item.percent >= targets.meets) {
                badgeClass = "bg-blue-100 text-blue-700 border-blue-200";
                label = "Meets";
            } else if (item.percent >= targets.approaches) {
                badgeClass = "bg-green-100 text-green-700 border-green-200";
                label = "Approaches";
            }

            // ADDED: onclick event and cursor-pointer class
            return `
            <div onclick="viewHistoryResult(${item.id})" class="cursor-pointer flex items-center justify-between p-4 bg-white border border-gray-100 rounded-lg shadow-sm hover:shadow-md hover:border-indigo-300 transition-all mb-3 group">
                <div>
                    <div class="flex items-center gap-2 mb-1">
                        <span class="font-bold text-gray-800 text-md group-hover:text-indigo-600 transition-colors">${item.title}</span>
                    </div>
                    <div class="text-xs text-gray-500 font-mono">${item.date}</div>
                </div>
                <div class="text-right">
                    <div class="font-bold text-lg text-gray-900">${item.score}/${item.total}</div>
                    <div class="inline-block px-2 py-0.5 rounded text-[10px] font-bold uppercase border ${badgeClass}">
                        ${label} (${item.percent}%)
                    </div>
                </div>
            </div>`;
        }).join('');
    }

    const modalHtml = `
        <div id="${modalId}" class="fixed inset-0 bg-gray-900 bg-opacity-50 flex items-center justify-center p-4 z-50 backdrop-blur-sm">
            <div class="bg-white rounded-xl shadow-2xl w-full max-w-2xl max-h-[80vh] flex flex-col overflow-hidden">
                <div class="p-5 border-b flex justify-between items-center bg-gray-50">
                    <div>
                        <h2 class="text-xl font-bold text-gray-800">Student History</h2>
                        <p class="text-xs text-gray-500">Click any row to view full details.</p>
                    </div>
                    <div class="flex gap-3">
                        <button id="clear-history-btn" class="text-xs text-red-500 hover:text-red-700 underline font-semibold">Clear History</button>
                        <button onclick="document.getElementById('${modalId}').remove()" class="text-gray-400 hover:text-gray-700 text-2xl font-bold">&times;</button>
                    </div>
                </div>
                <div class="p-5 overflow-y-auto bg-gray-50 flex-grow">${listHTML}</div>
                <div class="p-4 border-t bg-white flex justify-end">
                    <button onclick="document.getElementById('${modalId}').remove()" class="px-6 py-2 bg-gray-800 text-white font-bold rounded-lg hover:bg-gray-700">Close</button>
                </div>
            </div>
        </div>
    `;

    document.body.insertAdjacentHTML('beforeend', modalHtml);

    document.getElementById('clear-history-btn').addEventListener('click', () => {
        if(confirm("Delete all history?")) {
            subjectData.resultHistory = [];
            saveState();
            showHistoryModal();
        }
    });
}
/**
 * Reconstructs a past quiz result and displays it.
 */
function viewHistoryResult(id) {
    const subjectData = getCurrentSubjectData();
    const item = subjectData.resultHistory.find(i => i.id === id);
    
    if(!item) {
        alert("Could not load this history item.");
        return;
    }

    // 1. Rehydrate Questions (Convert saved IDs back to real objects)
    // We filter(Boolean) just in case a question ID no longer exists (e.g. new PDF uploaded)
    const questions = (item.questionIds || []).map(qid => 
        subjectData.allQuestions.find(q => q.id === qid)
    ).filter(Boolean);

    if(questions.length === 0) {
        alert("The questions for this result are no longer compatible with the current PDF.");
        return;
    }

    // 2. Mock the Pathway in "Review Mode"
    AppState.currentPathway = {
        teks: item.title,
        questions: questions,
        currentIndex: 0,
        isQuiz: true, 
        isHistoryReview: true,   // <--- This flag tells renderResultsScreen to use saved scores
        savedScores: item.savedScores || {} // <--- The specific snapshot of scores
    };

    // 3. Close Modal & Show Results
    document.getElementById('history-modal')?.remove();
    renderResultsScreen();
}

            /**
             * Populates the filter options for the custom pathway generator.
             */
     function populateCustomFilters() {
    const subjectData = getCurrentSubjectData();
    
    // 1. Calculate Counts
    const counts = {
        difficulty: {},
        year: {},
        reportingCategory: {},
        cluster: {},
        itemType: {}
    };

    subjectData.allQuestions.forEach(q => {
        if(q.difficulty) counts.difficulty[q.difficulty] = (counts.difficulty[q.difficulty] || 0) + 1;
        if(q.year) counts.year[q.year] = (counts.year[q.year] || 0) + 1;
        if(q.reportingCategory) counts.reportingCategory[q.reportingCategory] = (counts.reportingCategory[q.reportingCategory] || 0) + 1;
        if(q.cluster) counts.cluster[q.cluster] = (counts.cluster[q.cluster] || 0) + 1;
        if(q.itemType) counts.itemType[q.itemType] = (counts.itemType[q.itemType] || 0) + 1;
    });

    // 2. Define Filter Groups
    const filters = {
        'Difficulty': { 
            dbKey: 'difficulty',
            values: ['Masters', 'Meets', 'Approaches', 'Unrated'] 
        },
        'Year': { 
            dbKey: 'year',
            values: [...new Set(subjectData.allQuestions.map(q => q.year))].filter(Boolean).sort((a,b) => b-a) 
        },
        'Reporting Category': { 
            dbKey: 'reportingCategory',
            values: [...new Set(subjectData.allQuestions.map(q => q.reportingCategory))].filter(Boolean).sort() 
        },
        'Cluster': { 
            dbKey: 'cluster',
            values: [...new Set(subjectData.allQuestions.map(q => q.cluster))].filter(Boolean).sort() 
        },
        'Item Type': { 
            dbKey: 'itemType',
            values: [...new Set(subjectData.allQuestions.map(q => q.itemType))].filter(Boolean).sort() 
        },
    };

    filterContainer.innerHTML = '';
    
    // 3. Render Groups
    for (const label in filters) {
        const groupData = filters[label];
        
        const group = document.createElement('div');
        group.className = 'mb-4';
        group.innerHTML = `<div class="flex justify-between items-center mb-2">
                            <h3 class="font-semibold">${label}</h3>
                            <button class="text-sm text-blue-600 hover:underline select-all-btn" data-group-id="filter-${label.toLowerCase().replace(/ /g, '-')}">Select All</button>
                         </div>`;
        
        const checkboxContainer = document.createElement('div');
        checkboxContainer.className = 'filter-group space-y-1'; // Added space-y-1 for breathing room
        checkboxContainer.id = `filter-${label.toLowerCase().replace(/ /g, '-')}`;
        
        groupData.values.forEach(value => {
            const count = counts[groupData.dbKey][value] || 0;
            const labelEl = document.createElement('label');
            // Added hover effect and pointer cursor
            labelEl.className = 'flex items-center w-full cursor-pointer hover:bg-gray-50 p-1 rounded';
            
            labelEl.innerHTML = `
                <input type="checkbox" class="rounded mr-2" data-filter-key="${label}" value="${value}">
                <span class="text-sm text-gray-700 whitespace-nowrap">${value}</span>
                
                <div class="flex-grow border-b-2 border-dotted border-gray-300 mx-2 relative top-1"></div>
                
                <span class="text-xs text-gray-500 font-mono bg-gray-100 px-2 py-0.5 rounded-full border border-gray-200">${count}</span>
            `;
            checkboxContainer.appendChild(labelEl);
        });
        
        group.appendChild(checkboxContainer);
        filterContainer.appendChild(group);
    }
    
    document.querySelectorAll('.select-all-btn').forEach(btn => {
        btn.onclick = (e) => {
            const groupId = e.target.dataset.groupId;
            const checkboxes = document.querySelectorAll(`#${groupId} input[type="checkbox"]`);
            const shouldCheck = Array.from(checkboxes).some(cb => !cb.checked);
            checkboxes.forEach(cb => cb.checked = shouldCheck);
        };
    });
}
      // --- SORTING COMPARATORS ---

/**
 * Sorts questions by Year (Descending) then Question Number (Ascending).
 */
function logicalSortComparator(a, b) {
    const yearA = parseInt(a.year, 10);
    const yearB = parseInt(b.year, 10);
    const numA = parseInt(a.id.match(/Q(\d+)/)[1], 10);
    const numB = parseInt(b.id.match(/Q(\d+)/)[1], 10);

    // 1. Sort by Year (Descending)
    if (yearA !== yearB) {
        return yearB - yearA;
    }
    
    // 2. Sort by Question Number (Ascending)
    return numA - numB;
}

/**
 * Sorts questions by Question Number (Ascending) then Year (Ascending).
 */
function numericalSortComparator(a, b) {
    const yearA = parseInt(a.year, 10);
    const yearB = parseInt(b.year, 10);
    const numA = parseInt(a.id.match(/Q(\d+)/)[1], 10);
    const numB = parseInt(b.id.match(/Q(\d+)/)[1], 10);

    // 1. Sort by Question Number (Ascending)
    if (numA !== numB) {
        return numA - numB;
    }
    
    // 2. Sort by Year (Ascending)
    return yearA - yearB;
}

/**
 * Generates and saves a custom pathway based on the selected filters and sort order.
 * UPDATED: Includes logic to sort questions based on user selection.
 */
function generateCustomPathway() {
    const selectedFilters = {};
    let filterDescription = [];
    filterContainer.querySelectorAll('input[type="checkbox"]:checked').forEach(cb => {
        const key = cb.dataset.filterKey;
        if (!selectedFilters[key]) {
            selectedFilters[key] = [];
        }
        selectedFilters[key].push(cb.value);
    });

    // Get the selected sort order
    const sortDropdown = document.getElementById('pathway-sort-dropdown');
    const sortMethod = sortDropdown ? sortDropdown.value : 'logical';

    Object.entries(selectedFilters).forEach(([key, values]) => {
        if (values.length > 0) {
            filterDescription.push(`${key}: ${values.join(', ')}`);
        }
    });

    const subjectData = getCurrentSubjectData();
    let filteredQuestions = subjectData.allQuestions.filter(q => {
        return Object.entries(selectedFilters).every(([key, values]) => {
            let propName;
            
            if (key === 'Difficulty') propName = 'difficulty'; 
            else if (key === 'Reporting Category') propName = 'reportingCategory';
            else if (key === 'Cluster') propName = 'cluster';
            else if (key === 'Year') propName = 'year';
            else if (key === 'Item Type') propName = 'itemType';
            
            else return true;

            return values.includes(q[propName]);
        });
    });

    if (filteredQuestions.length === 0) {
        showCustomModal('No Questions Found', 'No questions match the selected filters.', null);
        return;
    }

    // --- APPLY SORTING LOGIC ---
    if (sortMethod === 'random') {
        filteredQuestions.sort(() => Math.random() - 0.5); // Random Shuffle
    } else if (sortMethod === 'numerical') {
        filteredQuestions.sort(numericalSortComparator);
    } else { // Default to 'logical'
        filteredQuestions.sort(logicalSortComparator);
    }

    const filteredQuestionIds = filteredQuestions.map(q => q.id); // Store IDs after sorting

    const pathwayName = filterDescription.length > 0 ? 
                        `${filterDescription.join(' | ')} (${filteredQuestionIds.length} items)` :
                        `Custom Pathway (${filteredQuestionIds.length} items)`;

    const newPathway = {
        id: `custom-${Date.now()}`,
        name: pathwayName,
        filterDescription: filterDescription.join(' | '),
        questionIds: filteredQuestionIds,
        sortMethod: sortMethod // Save the sort method for future reference
    };

    subjectData.customPathways.unshift(newPathway);
    
    saveState();
    renderDashboard();
}
/**
 * Shows a modal allowing the user to choose the intensity of their High-Yield review.
 * @param {Array} allQuestions - All questions belonging to the Top 10 TEKS.
 * @param {string} yearLabel - The current year filter (e.g., "2025" or "All Years").
 */
function showHighYieldOptionsModal(allQuestions, yearLabel) {
    const modalId = 'high-yield-modal';
    document.getElementById(modalId)?.remove();

    // 1. Group questions by TEKS to ensure balanced sampling
    const questionsByTeks = {};
    allQuestions.forEach(q => {
        if (!questionsByTeks[q.teks]) questionsByTeks[q.teks] = [];
        questionsByTeks[q.teks].push(q);
    });
    const teksCount = Object.keys(questionsByTeks).length;

    // --- STRATEGY GENERATORS ---

    const generateWarmUp = () => {
        const selected = [];
        Object.values(questionsByTeks).forEach(group => {
            // Priority: Approaches -> Meets -> Masters -> Any
            let pick = group.find(q => q.difficulty === 'Approaches') || 
                       group.find(q => q.difficulty === 'Meets') || 
                       group[0];
            if (pick) selected.push(pick);
        });
        return selected; // ~10 questions
    };

    const generateDailyMix = () => {
        const selected = [];
        Object.values(questionsByTeks).forEach(group => {
            // Shuffle and pick 3
            const shuffled = [...group].sort(() => Math.random() - 0.5);
            selected.push(...shuffled.slice(0, 3));
        });
        return selected; // ~30 questions
    };

    const startStrategy = (strategyName, questionSet) => {
        document.getElementById(modalId).remove();
        startPathway(`‚ö° ${strategyName} (${yearLabel})`, questionSet, { isQuiz: false });
    };

    // 2. Build Modal HTML
    const modalHtml = `
        <div id="${modalId}" class="fixed inset-0 bg-gray-900 bg-opacity-60 flex items-center justify-center p-4 z-50 backdrop-blur-sm">
            <div class="bg-white rounded-xl shadow-2xl w-full max-w-4xl overflow-hidden transform transition-all scale-100">
                
                <div class="bg-gradient-to-r from-indigo-600 to-purple-600 p-6 text-white text-center">
                    <h2 class="text-3xl font-bold mb-1">Choose Your Review Strategy</h2>
                    <p class="text-indigo-100 opacity-90">Targeting the Top ${teksCount} High-Yield Standards for ${yearLabel}</p>
                </div>

                <div class="p-8 grid grid-cols-1 md:grid-cols-3 gap-6 bg-gray-50">
                    
                    <button id="btn-warmup" class="group relative bg-white p-6 rounded-xl border-2 border-green-100 hover:border-green-500 hover:shadow-xl transition-all text-left flex flex-col h-full">
                        <div class="absolute top-0 right-0 bg-green-100 text-green-700 text-xs font-bold px-3 py-1 rounded-bl-lg">FAST</div>
                        <div class="text-4xl mb-4">‚òï</div>
                        <h3 class="text-xl font-bold text-gray-800 group-hover:text-green-600 transition-colors">The Warm-Up</h3>
                        <p class="text-gray-500 text-sm mt-2 mb-4 flex-grow">A quick confidence booster. Picks the easiest available question from each high-value topic.</p>
                        <div class="mt-auto pt-4 border-t border-gray-100">
                            <span class="font-mono text-xs font-bold text-gray-400 block mb-1">Est. Time: 5-10 mins</span>
                            <span class="inline-block w-full text-center py-2 rounded-lg bg-green-50 text-green-700 font-bold group-hover:bg-green-600 group-hover:text-white transition-colors">Start ~10 Questions</span>
                        </div>
                    </button>

                    <button id="btn-dailymix" class="group relative bg-white p-6 rounded-xl border-2 border-blue-100 hover:border-blue-500 hover:shadow-xl transition-all text-left flex flex-col h-full ring-4 ring-blue-50">
                        <div class="absolute top-0 right-0 bg-blue-100 text-blue-700 text-xs font-bold px-3 py-1 rounded-bl-lg">BALANCED</div>
                        <div class="text-4xl mb-4">üéß</div>
                        <h3 class="text-xl font-bold text-gray-800 group-hover:text-blue-600 transition-colors">The Daily Mix</h3>
                        <p class="text-gray-500 text-sm mt-2 mb-4 flex-grow">The perfect workout. Randomly selects 3 questions from each standard to ensure breadth without burnout.</p>
                        <div class="mt-auto pt-4 border-t border-gray-100">
                            <span class="font-mono text-xs font-bold text-gray-400 block mb-1">Est. Time: 20-30 mins</span>
                            <span class="inline-block w-full text-center py-2 rounded-lg bg-blue-50 text-blue-700 font-bold group-hover:bg-blue-600 group-hover:text-white transition-colors">Start ~30 Questions</span>
                        </div>
                    </button>

                    <button id="btn-gauntlet" class="group relative bg-white p-6 rounded-xl border-2 border-purple-100 hover:border-purple-500 hover:shadow-xl transition-all text-left flex flex-col h-full">
                        <div class="absolute top-0 right-0 bg-purple-100 text-purple-700 text-xs font-bold px-3 py-1 rounded-bl-lg">INTENSE</div>
                        <div class="text-4xl mb-4">üî•</div>
                        <h3 class="text-xl font-bold text-gray-800 group-hover:text-purple-600 transition-colors">The Gauntlet</h3>
                        <p class="text-gray-500 text-sm mt-2 mb-4 flex-grow">Full mastery mode. Includes every single question from these high-yield standards. Not for the faint of heart.</p>
                        <div class="mt-auto pt-4 border-t border-gray-100">
                            <span class="font-mono text-xs font-bold text-gray-400 block mb-1">Est. Time: 60+ mins</span>
                            <span class="inline-block w-full text-center py-2 rounded-lg bg-purple-50 text-purple-700 font-bold group-hover:bg-purple-600 group-hover:text-white transition-colors">Start All ${allQuestions.length} Questions</span>
                        </div>
                    </button>

                </div>
                
                <div class="bg-gray-50 p-4 border-t flex justify-center">
                    <button onclick="document.getElementById('${modalId}').remove()" class="text-gray-500 hover:text-gray-700 font-semibold px-6 py-2">Cancel</button>
                </div>
            </div>
        </div>
    `;

    document.body.insertAdjacentHTML('beforeend', modalHtml);

    // 3. Attach Listeners
    document.getElementById('btn-warmup').onclick = () => startStrategy("Warm-Up", generateWarmUp());
    document.getElementById('btn-dailymix').onclick = () => startStrategy("Daily Mix", generateDailyMix());
    document.getElementById('btn-gauntlet').onclick = () => startStrategy("The Gauntlet", allQuestions);
}
            /**
             * Shows the review modal with all questions that need manual setup.
             */
            function reviewAllNeedingSetup() {
                const questionsToReview = getCurrentSubjectData().allQuestions.filter(q => q.needsReview);
                if (questionsToReview.length > 0) {
                    showReviewModal('Review All Questions Needing Setup', questionsToReview);
                } else {
                    showCustomModal('All Set!', 'There are no more questions that need manual setup.', null);
                    reviewAllContainer.classList.add('hidden');
                }
            }
            
            /**
             * Updates the "Review All" button with the count of questions needing review.
             */
            function updateReviewAllButton() {
                const questionsToReview = getCurrentSubjectData().allQuestions.filter(q => q.needsReview);
                if (questionsToReview.length > 0) {
                    reviewAllContainer.classList.remove('hidden');
                    reviewAllBtn.textContent = `Review ${questionsToReview.length} Questions Needing Setup`;
                } else {
                    reviewAllContainer.classList.add('hidden');
                }
            }

            /**
             * Resets the entire UI and application state.
             */
            function resetUI() {
                const subjectData = getCurrentSubjectData();
                subjectData.pdfDoc = null;
                subjectData.allQuestions = [];
                subjectData.masteryState = {};
                subjectData.teksToRcMap = {};
                subjectData.customPathways = [];
                statusDiv.textContent = '';
                pathwayDisplay.innerHTML = '';
                placeholderView.classList.remove('hidden');
                customPathwayBuilder.classList.add('hidden');
                reviewAllContainer.classList.add('hidden');
                showDashboard();
            }
// ADD THESE THREE NEW FUNCTIONS

            /**
             * Shows the print options modal and sets up its event listeners.
             * @param {Array<Object>} questions The array of questions to be printed.
             * @param {string} pathwayName The name of the pathway for the print header.
             */
/**
 * Shows the print options modal and sets up its event listeners.
 * Fixed to prevent "null parent" errors on repeated clicks.
 */
function showPrintOptionsModal(questions, pathwayName) {
    // Re-select elements by ID to ensure we have the live DOM nodes
    const modal = document.getElementById('print-options-modal');
    const loader = document.getElementById('print-modal-loader');
    const cancelBtn = document.getElementById('cancel-print-btn');
    const generateBtn = document.getElementById('generate-print-btn');
    const includeAnswersToggle = document.getElementById('include-answers-toggle');
    const includeRationalesToggle = document.getElementById('include-rationales-toggle');

    modal.classList.remove('hidden');
    loader.classList.add('hidden');

    // Reset toggles to default
    includeAnswersToggle.checked = false;
    includeRationalesToggle.checked = false;

    // Assign new click listeners directly (overwriting any old ones)
    cancelBtn.onclick = () => {
        modal.classList.add('hidden');
    };

    generateBtn.onclick = async () => {
        const includeAnswers = includeAnswersToggle.checked;
        const includeRationales = includeRationalesToggle.checked;

        loader.classList.remove('hidden'); // Show loader
        
        // Pass both booleans to the generation function
        await generatePrintPage(questions, includeAnswers, includeRationales, pathwayName);
        
        loader.classList.add('hidden'); // Hide loader
        modal.classList.add('hidden'); // Hide modal
    };
}
/**
 * Helper to format the correct answer string based on question type.
 */
function getAnswerStringForQuestion(question) {
    if (!question) return "Unknown";

    if (question.answerText && question.answerText.length > 0) {
        // Handles Multiple Choice, Multipart, Multiselect
        return question.answerText.join(', ');
    } else if (question.textEntryAnswer) {
        return question.textEntryAnswer;
    } else if (question.inlineChoiceAnswer) {
        return question.inlineChoiceAnswer.join(', ');
    } else if (question.graphingAnswer) {
        return "See Graph Solution";
    } else if (question.hotspotAnswer) {
        return "See Hotspot Solution";
    } else if (question.dragAndDropAnswers) {
         return question.dragAndDropAnswers.join(', ');
    }
    
    return "Not Set";
}
/**
 * UNIFIED GRADING: This sends Quiz questions to the Practice Mode graders.
 * It ensures Quizzes are graded EXACTLY the same way as Practice questions.
 */
function submitCurrentQuestion() {
    const question = AppState.currentPathway.activeQuestion;
    const type = (question.itemType || '').toLowerCase();

    // Route to the specific grader based on type
    if (type.includes('multiple') || type.includes('multipart') || type.includes('multiselect')) {
        evaluateMCAnswer();
    } else if (type.includes('hot spot')) {
        evaluateHotspotAnswer();
    } else if (type.includes('drag and drop')) {
        evaluateDragAndDropAnswer();
    } else if (type.includes('inline choice')) {
        evaluateInlineChoiceAnswer();
    } else if (type.includes('graphing')) {
        evaluateGraphingAnswer();
    } else if (type.includes('text') || type.includes('equation')) {
        // Text entry needs a custom tiny wrapper since it was inline before
        const input = document.getElementById('text-entry-input');
        if (input) {
            const val = input.value.trim().toLowerCase();
            const correct = (question.textEntryAnswer || "").toLowerCase().trim();
            showFeedback(val === correct && val !== '');
        } else {
            showFeedback(false);
        }
    } else {
        // Fallback for unknown types -> Mark incorrect and move on
        showFeedback(false);
    }
}
/**
 * Generates the printable page.
 * UPDATED: Increased rendering scale from 1.5 to 3.0 for high print resolution.
 */
async function generatePrintPage(questions, includeAnswers, includeRationales, pathwayName) {
    const printWindow = window.open('', '_blank');
    if (!printWindow) {
        showCustomModal("Popup Blocked", "Please allow popups for this site to generate a printable version.", null);
        return;
    }

    printWindow.document.write(`
        <html>
        <head>
            <title>Printable - ${pathwayName}</title>
            <style>
                body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; margin: 0; }
                .page-container { width: 8.5in; min-height: 11in; padding: 0.5in; box-sizing: border-box; margin: 0 auto; }
                .print-header { font-size: 1.5rem; font-weight: bold; text-align: center; margin-bottom: 20px; border-bottom: 2px solid #000; padding-bottom: 10px; }
                .question-container { 
                    margin-top: 20px; 
                    border-top: 1px solid #ccc;
                    padding-top: 15px;
                    page-break-inside: avoid; /* Keep question components together */
                }
                .question-title { font-weight: bold; font-size: 1.1rem; margin-bottom: 10px; }
                .question-image { 
                    width: 100%; 
                    height: auto; 
                    border: 1px solid #eee;
                    margin-bottom: 10px;
                }
                .answer-key { 
                    background-color: #f3f3f3; 
                    border: 1px solid #ddd; 
                    padding: 10px; 
                    margin-top: 10px; 
                    font-weight: bold;
                    font-size: 1.1rem;
                }
                /* NEW RATIONALE STYLES */
                .rationale-container {
                    margin-top: 10px;
                    border: 1px solid #e5e7eb;
                    border-radius: 8px;
                    padding: 10px;
                    background-color: #f9fafb;
                }
                .rationale-header {
                    font-size: 0.9rem;
                    font-weight: bold;
                    color: #4b5563;
                    margin-bottom: 5px;
                    text-transform: uppercase;
                }
                .rationale-item {
                    padding: 8px;
                    margin-bottom: 4px;
                    border-radius: 4px;
                    font-size: 0.9rem;
                    border: 1px solid;
                }
                .rationale-correct {
                    background-color: #d1fae5; /* Green-100 */
                    border-color: #34d399;     /* Green-400 */
                    color: #065f46;            /* Green-800 */
                }
                .rationale-incorrect {
                    background-color: #fee2e2; /* Red-100 */
                    border-color: #f87171;     /* Red-400 */
                    color: #991b1b;            /* Red-800 */
                }
                
                @media print {
                    body { margin: 0; }
                    .page-container { width: 100%; padding: 0; box-shadow: none; }
                    .rationale-correct { 
                        background-color: #d1fae5 !important; 
                        -webkit-print-color-adjust: exact; 
                        color-adjust: exact; 
                    }
                    .rationale-incorrect { 
                        background-color: #fee2e2 !important; 
                        -webkit-print-color-adjust: exact; 
                        color-adjust: exact; 
                    }
                }
                    /* --- MISSION LOG (CHECKLIST) STYLES --- */
.mission-log {
    background: rgba(255, 255, 255, 0.6);
    border-radius: 1.5rem;
    padding: 1.5rem;
    margin-top: 2rem; /* Puts it below the map nodes */
    border: 1px solid rgba(255, 255, 255, 0.8);
    box-shadow: inset 0 2px 4px rgba(0,0,0,0.02);
}

.mission-header {
    font-size: 0.85rem;
    font-weight: 800;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: #94a3b8;
    margin-bottom: 1rem;
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.mission-item {
    display: flex;
    justify-content: space-between;
    align-items: start; /* Aligns text to top */
    padding: 0.75rem 0;
    border-bottom: 1px dashed #cbd5e1;
    transition: background-color 0.2s;
}

.mission-item:last-child {
    border-bottom: none;
}

.mission-info {
    flex: 1;
    margin-right: 1.5rem;
}

.mission-code {
    display: inline-block;
    font-weight: 800;
    color: #334155;
    font-size: 0.9rem;
    margin-right: 0.5rem;
}

/* This fixes the "too long to read" issue */
.mission-desc {
    display: block;
    font-size: 0.9rem;
    color: #64748b;
    line-height: 1.5;
    margin-top: 0.25rem;
}

.mission-status-box {
    flex-shrink: 0;
    display: flex;
    align-items: center;
    gap: 0.5rem;
    background: white;
    padding: 0.25rem 0.75rem;
    border-radius: 9999px;
    border: 1px solid #e2e8f0;
    box-shadow: 0 1px 2px rgba(0,0,0,0.05);
}

.status-label {
    font-size: 0.7rem;
    font-weight: 700;
    text-transform: uppercase;
}
            </style>
        </head>
        <body>
            <div class="page-container">
                <h1 class="print-header">${pathwayName}</h1>
                <div id="content">Generating document...</div>
            </div>
            <div id="global-loader" class="fixed inset-0 bg-indigo-900 bg-opacity-90 z-[9999] hidden flex flex-col items-center justify-center transition-opacity duration-300 backdrop-blur-sm">
    
    <div class="relative max-w-md w-full px-6">
        <div class="bg-white rounded-2xl p-6 shadow-2xl border-4 border-indigo-200 relative">
            <div class="absolute -bottom-4 left-1/2 transform -translate-x-1/2 w-8 h-8 bg-white border-b-4 border-r-4 border-indigo-200 rotate-45"></div>
            
            <h3 class="text-indigo-600 font-bold uppercase tracking-wider text-xs mb-2">‚ú® Ms. Staar is working...</h3>
            <p id="global-loader-text" class="text-xl font-bold text-gray-800 text-center">
                "Hold on, I'm analyzing your test data!"
            </p>
        </div>

        <div class="flex justify-center mt-8">
            <div class="w-24 h-24 bg-white rounded-full border-4 border-indigo-500 shadow-xl flex items-center justify-center text-6xl relative z-10 animate-bounce">
                üë©‚Äçüè´
            </div>
        </div>
    </div>

    <div class="mt-8 w-64 h-3 bg-indigo-900 rounded-full overflow-hidden border border-indigo-700">
        <div class="h-full bg-indigo-400 animate-pulse w-full origin-left transform scale-x-50"></div>
    </div>

</div>
        </body>
        </html>
    `);
    printWindow.document.close();

    const contentDiv = printWindow.document.getElementById('content');
    contentDiv.innerHTML = ''; 

    let lastPassagePrinted = null; 

    // Loop through questions
    for (const [index, question] of questions.entries()) {
        const questionDiv = printWindow.document.createElement('div');
        questionDiv.className = 'question-container';
        
        // 1. Passage Logic
        const subjectData = getCurrentSubjectData();
        let passagePages = question.passagePageNums || [];
        let currentPassageIdentifier = passagePages.join(',');

        if (currentPassageIdentifier && currentPassageIdentifier !== lastPassagePrinted) {
            for (const pageNum of passagePages) {
                try {
                    const passagePage = await subjectData.pdfDoc.getPage(pageNum);
                    const viewport = passagePage.getViewport({ scale: 3.0 }); // <-- HIGH RES FIX HERE
                    const passageCanvas = printWindow.document.createElement('canvas');
                    passageCanvas.width = viewport.width;
                    passageCanvas.height = viewport.height;
                    
                    await passagePage.render({ canvasContext: passageCanvas.getContext('2d'), viewport }).promise;

                    const img = printWindow.document.createElement('img');
                    img.className = 'question-image';
                    img.style.borderBottom = "4px double #ccc"; // Visual separator for passage
                    img.src = passageCanvas.toDataURL('image/png');
                    questionDiv.appendChild(img);
                } catch (e) {
                    console.error("Passage render error:", e);
                }
            }
            lastPassagePrinted = currentPassageIdentifier;
        }

        // 2. Question Title
        const title = printWindow.document.createElement('h3');
        title.className = 'question-title';
        title.textContent = `Question ${index + 1} (TEKS: ${question.teks})`;
        questionDiv.appendChild(title);

        // 3. Question Image(s)
        const canvases = await createQuestionCanvases(question, 4.0); // <-- HIGH RES FIX HERE
        for (const canvas of canvases) {
            const img = printWindow.document.createElement('img');
            img.className = 'question-image';
            img.src = canvas.toDataURL('image/png'); 
            questionDiv.appendChild(img);
        }

        // 4. Rationales Logic (NEW)
        if (includeRationales && question.rationaleMap && Object.keys(question.rationaleMap).length > 0) {
            const rationaleContainer = printWindow.document.createElement('div');
            rationaleContainer.className = 'rationale-container';
            
            const header = printWindow.document.createElement('div');
            header.className = 'rationale-header';
            header.textContent = "Item Rationales:";
            rationaleContainer.appendChild(header);

            // Determine if Multipart
            const isMultipart = (question.itemType || "").toLowerCase().includes('multipart');
            const sortedKeys = Object.keys(question.rationaleMap).sort();

            sortedKeys.forEach(key => {
                // Determine if this specific key is correct
                let isCorrect = false;
                const explanation = question.rationaleMap[key];
                
                // Logic to extract letter from key (e.g., "A", "PartA_C")
                let displayLetter = key;
                let cleanLetter = key;
                
                if (key.includes('_')) {
                    // e.g. PartA_A -> Clean: A
                    cleanLetter = key.split('_')[1];
                    displayLetter = key.replace('_', ' - Option ');
                } else {
                    displayLetter = `Option ${key}`;
                }

                // Check correctness against answerText array
                if (question.answerText) {
                    if (isMultipart) {
                        // PartA keys check against answerText[0], PartB against answerText[1]
                        if (key.startsWith('PartA') && question.answerText[0] === cleanLetter) isCorrect = true;
                        if (key.startsWith('PartB') && question.answerText[1] === cleanLetter) isCorrect = true;
                    } else {
                        // Standard check: is this letter in the answer array?
                        if (question.answerText.includes(cleanLetter)) isCorrect = true;
                    }
                }

                const itemDiv = printWindow.document.createElement('div');
                itemDiv.className = `rationale-item ${isCorrect ? 'rationale-correct' : 'rationale-incorrect'}`;
                // Add Check/X icon
                const icon = isCorrect ? "‚úÖ" : "‚ùå";
                itemDiv.innerHTML = `<strong>${icon} ${displayLetter}:</strong> ${explanation}`;
                rationaleContainer.appendChild(itemDiv);
            });

            questionDiv.appendChild(rationaleContainer);
        }

        // 5. Simple Answer Key Logic (Existing)
        if (includeAnswers) {
            const answerDiv = printWindow.document.createElement('div');
            answerDiv.className = 'answer-key';
            answerDiv.textContent = `Correct Answer: ${getAnswerStringForQuestion(question)}`;
            questionDiv.appendChild(answerDiv);
        }
        
        contentDiv.appendChild(questionDiv);
    }

    // Wait for images to render before printing
    setTimeout(() => {
        printWindow.print();
    }, 1500);
}
function showCustomModal(title, message, onClose, showCancel = false, showInput = false) {
    const modalId = 'custom-alert-modal';
    document.getElementById(modalId)?.remove();

    const inputFieldHTML = showInput ? `
        <input type="number" id="custom-modal-input" placeholder="Enter 4-digit year (e.g., 2023)"
               class="mt-3 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm text-center font-bold text-lg p-2"
               min="2000" max="2099" />
    ` : '';
    
    const cancelButtonHTML = showCancel ? `<button id="cancel-custom-modal" class="w-full mt-2 px-4 py-2 bg-gray-200 text-gray-700 font-semibold rounded-md hover:bg-gray-300">Go Back</button>` : '';

    const modalHtml = `
        <div id="${modalId}" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center p-4 z-50">
            <div class="bg-white rounded-lg shadow-xl w-full max-w-sm p-6 text-center">
                <h3 class="text-xl font-bold mb-4">${title}</h3>
                <p class="text-gray-700 mb-2">${message}</p>
                ${inputFieldHTML}
                <div class="mt-6">
                    <button id="close-custom-modal" class="w-full px-4 py-2 bg-indigo-600 text-white font-semibold rounded-md hover:bg-indigo-700">OK</button>
                    ${cancelButtonHTML}
                </div>
            </div>
        </div>`;
    document.body.insertAdjacentHTML('beforeend', modalHtml);
    
    const closeModal = () => document.getElementById(modalId)?.remove();
    const inputElement = document.getElementById('custom-modal-input');

    document.getElementById('close-custom-modal').addEventListener('click', () => {
        let inputYear = showInput ? inputElement.value : null;
        closeModal();
        if (onClose) onClose(true, inputYear); // Pass true (confirmed) and the input value
    });
    
    if(showCancel) {
        document.getElementById('cancel-custom-modal').addEventListener('click', () => {
             closeModal();
             if (onClose) onClose(false, null); // Pass false (canceled)
        });
    }
}
/**
 * Shows the review modal for a single question or an array of questions.
 * UPDATED: Renders a "Solution" box for Math/Rubric questions (non-multiple choice).
 */
async function showReviewModal(title, questionsData) {
    const questions = Array.isArray(questionsData) ? questionsData : [questionsData];
    
    const reviewModalTitle = document.getElementById('review-modal-title');
    const reviewModalContent = document.getElementById('review-modal-content');
    const reviewModal = document.getElementById('review-modal');

    reviewModalTitle.textContent = title;
    reviewModalContent.innerHTML = ''; 
    reviewModal.classList.remove('hidden'); 

    for (const question of questions) {
        const item = document.createElement('div');
        item.className = 'review-item';
        item.dataset.needsReview = question.needsReview;
        item.id = `review-container-${question.id}`;

        const type = (question.itemType || "").toLowerCase();
        const isMultipart = type.includes('multipart');
        const needsInteractiveSetup = type.includes('hot spot') || type.includes('drag and drop');
        const needsCropSetup = !question.pageNums || question.pageNums.length === 0; 
        const rMap = question.rationaleMap || {};

        // 1. Helper to build standard A/B/C/D text areas
        const buildRationaleInputs = (prefix, sectionLabel) => {
            return `
                <div class="mt-2 p-2 bg-gray-100 rounded">
                    <h5 class="text-xs font-bold text-gray-500 uppercase mb-1">${sectionLabel}</h5>
                    ${['A', 'B', 'C', 'D'].map(opt => `
                        <div class="flex gap-2 items-start mb-1">
                            <span class="mt-1 text-gray-500 font-bold text-xs w-4">${opt}</span>
                            <textarea 
                                class="rationale-input flex-1 rounded border-gray-300 shadow-sm text-xs p-1 focus:border-indigo-500 focus:ring-indigo-500" 
                                rows="1" 
                                data-question-id="${question.id}" 
                                data-option="${prefix}${opt}"
                                id="rat-input-${question.id}-${prefix}${opt}"
                                placeholder="Explanation for ${opt}...">${rMap[prefix + opt] || ''}</textarea>
                        </div>
                    `).join('')}
                </div>`;
        };

        // 2. NEW HELPER: Build the "Solution" text area (For Math/Rubrics)
        // This box only appears if the parser found "Solution" text.
        const buildSolutionInput = () => {
            if (!rMap['Solution']) return ''; 
            return `
                <div class="mt-2 p-2 bg-blue-50 rounded border border-blue-200">
                    <h5 class="text-xs font-bold text-blue-700 uppercase mb-1">‚úÖ General Solution / Explanation</h5>
                    <textarea 
                        class="rationale-input w-full rounded border-blue-300 shadow-sm text-xs p-2 focus:border-blue-500 focus:ring-blue-500 font-medium text-gray-700" 
                        rows="6" 
                        data-question-id="${question.id}" 
                        data-option="Solution"
                        id="rat-input-${question.id}-Solution"
                        placeholder="General solution text found by parser...">${rMap['Solution']}</textarea>
                </div>`;
        };

        // Combine inputs: Standard Options + The New Solution Box
        let rationaleHTML = isMultipart 
            ? `<div class="grid grid-cols-1 md:grid-cols-2 gap-2">${buildRationaleInputs('PartA_', 'Part A')}${buildRationaleInputs('PartB_', 'Part B')}</div>`
            : buildRationaleInputs('', 'Rationale');
        
        // Append the solution box at the bottom
        rationaleHTML += buildSolutionInput();

        let controlsHTML = `
            <div class="bg-gray-50 p-4 rounded-lg space-y-4 h-full overflow-y-auto">
                <h3 class="font-bold text-lg text-indigo-700 border-b pb-2 sticky top-0 bg-gray-50 z-10">${question.id}</h3>
                
<div class="grid grid-cols-2 gap-4">
    <div>
        <label class="block text-sm font-medium text-gray-700">TEKS</label>
        <input type="text" id="review-teks-${question.id}" value="${question.teks || ''}" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm sm:text-sm">
    </div>
    <div>

        <label class="block text-sm font-medium text-gray-700">Reporting Category</label>
        <input type="text" id="review-rc-${question.id}" value="${question.reportingCategory || ''}" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm sm:text-sm">
    </div>
    <div class="col-span-2"> <label class="block text-sm font-medium text-gray-700">Item Type</label>
        <input type="text" id="review-itemType-${question.id}" value="${question.itemType || ''}" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm sm:text-sm">
    </div>
</div>

                <div>
                    <label class="block text-sm font-medium text-gray-700">Correct Answer(s)</label>
                    <input type="text" id="review-answer-${question.id}" value="${question.answerText ? question.answerText.join(', ') : (question.textEntryAnswer || '')}" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm sm:text-sm font-bold text-green-700">
                </div>

                <div class="border-t border-b border-gray-200 py-4">
                    <h4 class="font-semibold text-sm text-purple-800 mb-1">Smart Feedback</h4>
                    ${rationaleHTML}
                </div>
                
                ${needsCropSetup ? `
                <div class="pt-2">
                    <h4 class="font-semibold mb-2 text-xs uppercase text-gray-500">Image Tools</h4>
                    <div class="grid grid-cols-3 gap-2">
                        <button class="manual-crop-btn p-2 bg-white border border-blue-300 text-blue-700 text-xs rounded hover:bg-blue-50" data-question-id="${question.id}">Manual Crop</button>
                        <button class="auto-crop-btn p-2 bg-white border border-gray-300 text-gray-700 text-xs rounded hover:bg-gray-50" data-question-id="${question.id}">Auto-Detect</button>
                        <button class="full-page-btn p-2 bg-white border border-gray-300 text-gray-700 text-xs rounded hover:bg-gray-50" data-question-id="${question.id}">Full Page</button>
                    </div>
                </div>` : ''}

               ${needsInteractiveSetup ? `
                <div class="pt-2 border-t border-gray-200">
                    <h4 class="font-semibold mb-2 text-md text-purple-800">Interactive Zones & Key</h4>
                    
                    <div class="grid grid-cols-2 gap-2 mb-4">
                        <button class="add-zone-btn p-2 bg-green-100 text-green-700 text-xs rounded hover:bg-green-200" data-question-id="${question.id}">+ Add Zone</button>
                        <button class="clear-zones-btn p-2 bg-red-100 text-red-700 text-xs rounded hover:bg-red-200" data-question-id="${question.id}">Clear Zones</button>
                    </div>

                    ${type.includes('drag and drop') ? `
                    <div id="dnd-key-editor-${question.id}">
                        <h5 class="text-sm font-semibold mt-4 mb-2">Answer Key Mapping</h5>
                        <div id="key-zones-${question.id}" class="flex flex-wrap gap-2 p-2 border border-dashed border-purple-300 rounded-lg mb-4"></div>
                        <h5 class="text-sm font-semibold mb-1">Answer Bank Options (Source)</h5>
                        <textarea 
                            id="dnd-options-input-${question.id}"
                            class="w-full rounded-md border-gray-300 shadow-sm text-sm p-2"
                            rows="2"
                            placeholder="Type options separated by commas (e.g., Option A, Option B)"
                            data-question-id="${question.id}">${question.draggableOptions ? question.draggableOptions.join(', ') : ''}</textarea>
                        
                        <div id="dnd-bank-${question.id}" class="flex flex-wrap gap-2 p-2 bg-gray-100 rounded-lg"></div>
                    </div>
                    ` : ''}

                </div>` : ''}
            </div>
        `;

        // --- CANVAS SIDE (Left) ---
        let canvasHTML = `
            <div class="relative h-fit">
                <div class="flex justify-center space-x-2 mb-2">
                    <button class="view-toggle-btn active px-4 py-1 bg-indigo-600 text-white text-sm font-semibold rounded-full shadow-sm" data-mode="question" data-qid="${question.id}">Question Image</button>
                    <button class="view-toggle-btn px-4 py-1 bg-gray-200 text-gray-700 text-sm font-semibold rounded-full shadow-sm hover:bg-gray-300" data-mode="rationale" data-qid="${question.id}">Rationale Source</button>
                </div>

                <div id="rat-nav-${question.id}" class="hidden flex items-center justify-between bg-purple-50 p-2 rounded mb-2 border border-purple-200">
                    <button class="prev-page-btn px-2 py-1 bg-white border rounded text-xs hover:bg-gray-50" data-qid="${question.id}">‚óÄ Prev</button>
                    
                    <div class="flex items-center space-x-1">
                        <label for="rat-page-input-${question.id}" class="text-xs text-purple-800 font-bold">Page</label>
                        <input type="number" id="rat-page-input-${question.id}" value="${question.displayRationalePage || question.rationalePage || 1}" 
                               min="1" class="w-12 text-center text-xs font-bold text-purple-800 rounded border border-purple-300">
                        <span class="text-xs text-purple-800 font-bold" id="rat-total-pages-${question.id}">of ?</span>
                    </div>
                    
                    <button class="next-page-btn px-2 py-1 bg-white border rounded text-xs hover:bg-gray-50" data-qid="${question.id}">Next ‚ñ∂</button>
                    <button class="scan-page-btn ml-4 px-3 py-1 bg-purple-600 text-white text-xs font-bold rounded shadow hover:bg-purple-700" data-qid="${question.id}">‚ö° Scan This Page</button>
                </div>

                <div class="bg-white rounded-lg border shadow-sm overflow-hidden min-h-[300px] flex items-center justify-center relative">
                     <div id="scalable-content-review-${question.id}" class="scalable-content relative w-full"></div>
                </div>
            </div>
        `;

        item.innerHTML = canvasHTML + controlsHTML;
        reviewModalContent.appendChild(item);
        
        // --- LOGIC: Render Default (Question) ---
        const container = document.getElementById(`scalable-content-review-${question.id}`);
        
        const renderQuestionMode = async () => {
            container.innerHTML = '';
            const canvases = await createQuestionCanvases(question, 4.0, false); 
            canvases.forEach(c => {
                c.className = 'review-canvas w-full h-auto';
                container.appendChild(c);
            });
            if (needsCropSetup) redrawCropBox(question);
            if (needsInteractiveSetup) redrawZones(question);
        };

        const renderRationaleMode = async () => {
            const subjectData = getCurrentSubjectData();
            if (!subjectData.rationalePdfDoc) {
                container.innerHTML = `<div class="p-10 text-center text-gray-500">No Rationale PDF uploaded.<br>Please upload one in the dashboard.</div>`;
                return;
            }
            
            container.innerHTML = '<div class="loader mx-auto mt-10"></div>';
            
            try {
                const doc = subjectData.rationalePdfDoc;
                let pageNum = question.displayRationalePage || question.rationalePage || 1;
                pageNum = Math.max(1, Math.min(pageNum, doc.numPages));
                question.displayRationalePage = pageNum;
                
                document.getElementById(`rat-page-input-${question.id}`).value = pageNum;
                document.getElementById(`rat-page-input-${question.id}`).max = doc.numPages;
                document.getElementById(`rat-total-pages-${question.id}`).textContent = `of ${doc.numPages}`;
                
                const page = await doc.getPage(pageNum);
                const viewport = page.getViewport({ scale: 1.5 });
                const canvas = document.createElement('canvas');
                canvas.width = viewport.width;
                canvas.height = viewport.height;
                canvas.className = 'w-full h-auto shadow-md';
                
                await page.render({ canvasContext: canvas.getContext('2d'), viewport }).promise;
                container.innerHTML = '';
                container.appendChild(canvas);
            } catch (e) {
                container.innerHTML = `<div class="text-red-500 p-4">Error loading page: ${e.message}</div>`;
            }
        };

        await renderQuestionMode();

        // --- EVENT LISTENERS ---
        const toggles = item.querySelectorAll('.view-toggle-btn');
        const navBar = document.getElementById(`rat-nav-${question.id}`);
        
        toggles.forEach(btn => {
            btn.addEventListener('click', () => {
                toggles.forEach(b => {
                    b.classList.remove('bg-indigo-600', 'text-white');
                    b.classList.add('bg-gray-200', 'text-gray-700');
                });
                btn.classList.remove('bg-gray-200', 'text-gray-700');
                btn.classList.add('bg-indigo-600', 'text-white');

                const mode = btn.dataset.mode;
                if (mode === 'question') {
                    navBar.classList.add('hidden');
                    renderQuestionMode();
                } else {
                    if (!question.displayRationalePage) question.displayRationalePage = question.rationalePage || 1;
                    navBar.classList.remove('hidden');
                    renderRationaleMode();
                }
            });
        });

        // Navigation
        item.querySelector('.prev-page-btn').onclick = () => {
            if (question.displayRationalePage > 1) {
                question.displayRationalePage--;
                renderRationaleMode();
            }
        };
        item.querySelector('.next-page-btn').onclick = () => {
            const doc = getCurrentSubjectData().rationalePdfDoc;
            if (doc && question.displayRationalePage < doc.numPages) {
                question.displayRationalePage++;
                renderRationaleMode();
            }
        };
        document.getElementById(`rat-page-input-${question.id}`).addEventListener('change', (e) => {
            const doc = getCurrentSubjectData().rationalePdfDoc;
            const newPage = parseInt(e.target.value, 10);
            if (doc && newPage >= 1 && newPage <= doc.numPages) {
                question.displayRationalePage = newPage;
                renderRationaleMode();
            } else {
                e.target.value = question.displayRationalePage || question.rationalePage || 1;
            }
        });

        // 3. RE-SCAN BUTTON
        item.querySelector('.scan-page-btn').onclick = async () => {
            const doc = getCurrentSubjectData().rationalePdfDoc;
            if (!doc) return;
            
            const btn = item.querySelector('.scan-page-btn');
            const originalText = btn.textContent;
            btn.textContent = "Scanning...";
            
            try {
                const page = await doc.getPage(question.displayRationalePage);
                const textContent = await page.getTextContent();
                const pageText = textContent.items.map(i => i.str).join('\n');
                
                const rationales = parseRationalesText(pageText);
                const qNum = question.id.split('-Q')[1].replace(/^0+/, ''); 
                const found = rationales.find(r => r.number == qNum);
                
                if (found && found.rationaleMap) {
                    question.rationaleMap = { ...question.rationaleMap, ...found.rationaleMap };
                    
                    // Force refresh of the UI elements by re-showing the modal content for this item
                    // Note: In a robust app, we'd update DOM elements individually, but for now, 
                    // alert the user to reopen the modal or just update the inputs if found.
                    
                    Object.keys(found.rationaleMap).forEach(key => {
                        let input = document.getElementById(`rat-input-${question.id}-${key}`);
                        if (input) {
                            input.value = found.rationaleMap[key];
                            input.classList.add('bg-green-100');
                            setTimeout(() => input.classList.remove('bg-green-100'), 1000);
                        }
                    });
                    
                    btn.textContent = "‚úÖ Updated!";
                } else {
                    btn.textContent = "‚ùå Not found";
                }
            } catch (e) {
                console.error(e);
                btn.textContent = "Error";
            }
            setTimeout(() => btn.textContent = originalText, 2000);
        };

        // Standard Listeners 
        item.querySelectorAll('.rationale-input').forEach(input => {
            input.addEventListener('change', (e) => {
                if (!question.rationaleMap) question.rationaleMap = {};
                question.rationaleMap[e.target.dataset.option] = e.target.value;
            });
        });
        document.getElementById(`review-teks-${question.id}`).addEventListener('change', (e) => {
            question.teks = e.target.value; question.needsReview = false; 
        });
document.getElementById(`review-rc-${question.id}`).addEventListener('change', (e) => {
    question.reportingCategory = e.target.value;
    question.needsReview = false;
});
        document.getElementById(`review-answer-${question.id}`).addEventListener('change', (e) => {
            const val = e.target.value;
            const t = question.itemType.toLowerCase();
            if(t.includes('multiple') || t.includes('multipart') || t.includes('multiselect')) {
                question.answerText = val.split(',').map(s => s.trim());
            } else { question.textEntryAnswer = val.trim(); }
            question.needsReview = false;
        });

        if (needsCropSetup) {
            item.querySelector('.manual-crop-btn').addEventListener('click', enterManualCropMode);
            item.querySelector('.auto-crop-btn').addEventListener('click', resetCropToAuto);
            item.querySelector('.full-page-btn').addEventListener('click', resetCropToFullPage);
        }
        if (needsInteractiveSetup) {
            item.querySelector('.add-zone-btn').addEventListener('click', enterLayoutEditorMode);
            item.querySelector('.clear-zones-btn').addEventListener('click', clearInteractiveZones);
            if (type.includes('drag and drop')) {
                setupAnswerKeyEditor(question);
                document.getElementById(`dnd-options-input-${question.id}`).addEventListener('change', updateDraggableOptions);
            }
        }
    }
}
            function showFinishConfirmationModal() {
                showCustomModal(
                    "Finish Quiz?",
                    "You have unanswered questions. Are you sure you want to finish and see your results?",
                    (confirmed) => {
                        if (confirmed) {
                            renderResultsScreen();
                        }
                    },
                    true // Show cancel button
                );
                // Adjust button text for clarity
                setTimeout(() => {
                    const closeBtn = document.getElementById('close-custom-modal');
                    if(closeBtn) closeBtn.textContent = "Finish Anyway";
                }, 0);
            }

            function renderMissedQuestionsGrid(missedQuestions) {
    const missedQuestionsGrid = document.getElementById('missed-questions-grid');
    if (!missedQuestionsGrid) return; // Safety check!

    missedQuestionsGrid.innerHTML = ''; 

    if (missedQuestions.length === 0) {
         missedQuestionsGrid.innerHTML = `
            <div class="col-span-full p-8 text-center bg-green-50 rounded-lg border border-green-100">
                <p class="text-2xl text-green-600 font-bold">üéâ Perfect Score!</p>
                <p class="text-green-800">You achieved full points on all questions. No review needed.</p>
            </div>`;
    } else {
         missedQuestions.forEach(q => {
            if (!q || !q.id) return; 
            
            const card = document.createElement('div');
            card.className = 'border border-gray-200 rounded-lg p-4 bg-white shadow-sm hover:shadow-md transition-shadow flex flex-col justify-between h-full';
            
            card.innerHTML = `
                <div class="mb-4">
                    <div class="flex justify-between items-start">
                        <span class="font-bold text-gray-700 text-lg">${q.id}</span>
                        <span class="text-xs px-2 py-1 bg-gray-100 rounded text-gray-600">${q.difficulty || 'Unrated'}</span>
                    </div>
                    <p class="text-xs text-gray-500 mt-1 line-clamp-2" title="${q.teksDescription}">${q.teks}: ${q.teksDescription || 'No description'}</p>
                </div>
                <button class="review-missed-btn w-full px-4 py-2 bg-indigo-50 text-indigo-700 font-semibold text-sm rounded-md hover:bg-indigo-100 transition-colors border border-indigo-100" data-question-id="${q.id}">
                    Review Question
                </button>
            `;
            
            missedQuestionsGrid.appendChild(card);
        });
    }
}



            /**
             * Starts a new practice pathway for a specific topic cluster from the results screen.
             */
            function startTopicPractice(topic) {
                const practiceQuestions = getCurrentSubjectData().allQuestions.filter(q => q.cluster === topic);
                if (practiceQuestions.length > 0) {
                    startPathway(`Practice: ${topic}`, practiceQuestions, { isQuiz: false });
                }
            }

            /**
             * Starts a new pathway to retry a single question from the results screen.
             */
            function retrySingleQuestion(questionId) {
                const question = getCurrentSubjectData().allQuestions.find(q => q.id === questionId);
                if (question) {
                     startPathway(`Retry: ${question.id}`, [question], { isQuiz: false });
                }
            }


            /**
             * Prints the results page.
             */
            function printResults() {
                window.print();
            }

            /**
             * Downloads the results as a text file.
             */
            function downloadResults() {
                const pathway = AppState.currentPathway;
                const mastery = getCurrentSubjectData().masteryState[pathway.teks];
                const correctCount = Object.values(mastery).filter(s => s === 'correct').length;
                const totalCount = pathway.questions.length;

                let textContent = `Results for Pathway: ${pathway.teks}\n`;
                textContent += `Final Score: ${correctCount} / ${totalCount}\n\n`;
                textContent += "Questions to Review:\n";
                
                pathway.questions.forEach((q, index) => {
                    if (mastery[index] !== 'correct') {
                        textContent += `- Question #${index + 1} (ID: ${q.id})\n`;
                    }
                });

                const blob = new Blob([textContent], { type: 'text/plain' });
                const anchor = document.createElement('a');
                anchor.download = `pathway-results-${pathway.teks}.txt`;
                anchor.href = window.URL.createObjectURL(blob);
                anchor.click();
                window.URL.revokeObjectURL(anchor.href);
            }
            
            /**
             * Toggles the "flagged" state for the current question.
             */
            function toggleFlagCurrentQuestion() {
                const { currentIndex, flagged } = AppState.currentPathway;
                flagged[currentIndex] = !flagged[currentIndex]; 
            }

            /**
             * Toggles the filter in the review modal to show all questions or only those needing review.
             */
            function toggleReviewFilter(event) {
                const btn = event.target;
                const isFiltered = btn.dataset.filtered === 'true';
                const items = reviewModalContent.querySelectorAll('.review-item');
                
                if (isFiltered) {
                    items.forEach(item => item.style.display = 'grid');
                    btn.textContent = 'Show Only Questions Needing Review';
                    btn.dataset.filtered = 'false';
                } else {
                    items.forEach(item => {
                        if (item.dataset.needsReview !== 'true') {
                            item.style.display = 'none';
                        }
                    });
                    btn.textContent = 'Show All Questions';
                    btn.dataset.filtered = 'true';
                }
            }

            // --- Quiz Mode Functions ---
            /**
             * Shows the modal for setting up a quiz (e.g., enabling the timer).
             */
            function showQuizSetupModal(teksName, questions) {
                quizSetupModal.classList.remove('hidden');

                const beginQuizHandler = () => {
                    const timerEnabled = enableTimerToggle.checked;
                    const timePerQuestion = parseInt(timePerQuestionInput.value, 10);
                    
                    const timerSettings = timerEnabled ? { time: timePerQuestion * 60 } : null;

                    quizSetupModal.classList.add('hidden');
                    startPathway(teksName, questions, { isQuiz: true, timerSettings });
                    
                    beginQuizBtn.removeEventListener('click', beginQuizHandler);
                };
                
                beginQuizBtn.addEventListener('click', beginQuizHandler);
            }

            /**
             * Starts the timer for a question in quiz mode.
             */
            function startQuestionTimer() {
                let timeLeft = AppState.currentPathway.timerSettings.time;
                timerDisplay.textContent = `${Math.floor(timeLeft / 60)}:${(timeLeft % 60).toString().padStart(2, '0')}`;

                AppState.questionTimer = setInterval(() => {
                    timeLeft--;
                    timerDisplay.textContent = `${Math.floor(timeLeft / 60)}:${(timeLeft % 60).toString().padStart(2, '0')}`;
                    if (timeLeft <= 0) {
                        clearInterval(AppState.questionTimer);
                        evaluateAndAdvanceQuiz(true); // Timed out
                    }
                }, 1000);
            }

         /**
 * Evaluates the current question and advances to the next one in quiz mode.
 * FIXED: Properly unwraps Multiple Choice arrays and handles partial credit scoring (0, 1, 2).
 */
function evaluateAndAdvanceQuiz(timedOut = false, isFinishing = false) {
    if (AppState.questionTimer) clearInterval(AppState.questionTimer);

    const pathway = AppState.currentPathway;
    const question = pathway.activeQuestion;
    const type = (question.itemType || '').toLowerCase();
    
    // Default Score = 0
    let pointsEarned = 0;
    const pointsPossible = getQuestionPointsPossible(question);

    // Only evaluate if not timed out
    if (!timedOut) {
        // --- 1. MULTIPLE CHOICE / MULTIPART GRADING ---
        if (type.includes('multiple') || type.includes('multipart') || type.includes('multiselect')) {
            const userAnswers = pathway.userSelections; // Array of Arrays: [['A'], ['B']]
            const correctAnswers = question.answerText; // Array of Strings: ['A', 'B']

            if (correctAnswers && userAnswers.length > 0) {
                // Flatten user answers to match correct answers structure if needed
                const flatUserAnswers = userAnswers.flat();
                
                // Compare logic
                let correctCount = 0;
                
                // Special case for "Select Two" (Multi-Select) - Order doesn't matter
                if (type.includes('multiselect') || (correctAnswers.length > 1 && !type.includes('multipart'))) {
                    // Check if every user selection is in the correct answer list
                    const matches = flatUserAnswers.filter(ans => correctAnswers.includes(ans));
                    // Strict grading: Must get ALL correct to get points (or partial logic if you prefer)
                    // Current logic: 1 point per correct selection up to max
                    correctCount = matches.length; 
                    
                    // Cap at points possible
                    if (correctCount > pointsPossible) correctCount = pointsPossible;
                    
                    // Penalty: If they selected too many wrong ones, score might be 0. 
                    // For simplicity in this fix, we just count matches.
                    pointsEarned = (matches.length === correctAnswers.length && flatUserAnswers.length === correctAnswers.length) ? pointsPossible : 0;
                } 
                else {
                    // Standard MC or Multipart (Order Matters/Part-by-Part)
                    correctAnswers.forEach((ans, index) => {
                        // User answer for this part might be inside an array like ['A'] or just 'A'
                        const userAnsForPart = Array.isArray(userAnswers[index]) ? userAnswers[index][0] : userAnswers[index];
                        
                        if (userAnsForPart === ans) {
                            pointsEarned++; // 1 point per correct part
                        }
                    });
                }
            }
        } 
        // --- 2. HOT SPOT GRADING ---
        else if (type.includes('hot spot')) {
            const userClick = pathway.userSelections[0];
            const correctZone = question.interactiveZones && question.interactiveZones[0];
            
            if (userClick && correctZone) {
                const translatedZone = translateZoneCoordinates(correctZone, question);
                if (userClick.x >= translatedZone.x && 
                    userClick.x <= translatedZone.x + translatedZone.width &&
                    userClick.y >= translatedZone.y && 
                    userClick.y <= translatedZone.y + translatedZone.height) {
                    pointsEarned = pointsPossible;
                }
            }
        }
        // --- 3. TEXT ENTRY GRADING ---
        else if (type.includes('text') || type.includes('equation')) {
            const input = document.getElementById('text-entry-input');
            if (input) {
                const val = input.value.trim().toLowerCase();
                const correct = (question.textEntryAnswer || '').trim().toLowerCase();
                if (val === correct && val !== '') pointsEarned = pointsPossible;
            }
        }
    }

    // SAVE THE SCORE (Numerical, not string)
    // This fixes the "Ghost Data" issue where 'incorrect' string broke calculations
    getCurrentSubjectData().masteryState[pathway.teks][pathway.currentIndex] = pointsEarned;

    // Navigation Logic
    if (isFinishing) {
        const hasUnanswered = Object.values(getCurrentSubjectData().masteryState[pathway.teks]).some(s => s === 'not-started');
        if (hasUnanswered) {
            showFinishConfirmationModal();
            return;
        }
    }

    if (pathway.currentIndex >= pathway.questions.length - 1) {
        renderResultsScreen();
    } else {
        pathway.currentIndex++;
        renderProblem(pathway.questions[pathway.currentIndex]);
    }
}

            function resetPathwayProgress(pathwayName, questionCount) {
                showCustomModal(
                    `Reset Progress for ${pathwayName}?`,
                    "This will clear all your answers for this pathway and cannot be undone.",
                    (confirmed) => {
                        if (confirmed) {
                            const subjectData = getCurrentSubjectData();
                            if (subjectData.masteryState[pathwayName]) {
                                for (let i = 0; i < questionCount; i++) {
                                    subjectData.masteryState[pathwayName][i] = 'not-started';
                                }
                            }
                            renderDashboard();
                            saveState();
                        }
                    },
                    true // Show cancel button
                );
            }
            
            // --- NEW Crop Editing Functions ---

            /**
             * Redraws the visual overlay for the crop box in the review modal.
             * @param {Object} question The question object.
             */
            function redrawCropBox(question) {
                const container = document.getElementById(`scalable-content-review-${question.id}`);
                container.querySelector('.crop-box-overlay')?.remove(); 

                if (question.cropBox) {
                    const box = document.createElement('div');
                    box.className = 'crop-box-overlay';
                    box.style.left = `${question.cropBox.x * 100}%`;
                    box.style.top = `${question.cropBox.y * 100}%`;
                    box.style.width = `${question.cropBox.width * 100}%`;
                    box.style.height = `${question.cropBox.height * 100}%`;
                    container.appendChild(box);
                }
            }
            
            /**
             * Enters a mode to manually draw a new crop box.
             * @param {Event} event The click event from the button.
             */
            // REPLACE your current enterManualCropMode function with this one

// REPLACE your current enterManualCropMode function with this one

function enterManualCropMode(event) {
    const questionId = event.target.dataset.questionId;
    const question = getCurrentSubjectData().allQuestions.find(q => q.id === questionId);
    const container = document.getElementById(`scalable-content-review-${question.id}`);

    if (!question || container.querySelector('.layout-editor-overlay')) return;

    const overlay = document.createElement('div');
    overlay.className = 'layout-editor-overlay layout-editor-active';
    container.appendChild(overlay);

    let startX, startY, selectionBox, targetCanvas;

    const getCoords = (e, canvas) => {
        const rect = canvas.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        return {
            x: clientX - rect.left,
            y: clientY - rect.top
        };
    }

    const startDraw = (e) => {
        e.preventDefault();

        // --- THIS IS THE SAME FIX, APPLIED HERE ---
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;

        overlay.style.display = 'none';
        const elementUnderneath = document.elementFromPoint(clientX, clientY);
        overlay.style.display = '';

        if (elementUnderneath && elementUnderneath.classList.contains('review-canvas')) {
            targetCanvas = elementUnderneath;
        } else {
            return;
        }
        // --- END OF FIX ---

        const coords = getCoords(e, targetCanvas);
        startX = coords.x;
        startY = coords.y;
        
        selectionBox = document.createElement('div');
        selectionBox.className = 'selection-box';
        selectionBox.style.left = `${startX}px`;
        selectionBox.style.top = `${startY}px`;
        targetCanvas.parentElement.appendChild(selectionBox);
    };

    const draw = (e) => {
        if (selectionBox) {
            e.preventDefault();
            const coords = getCoords(e, targetCanvas);
            const width = coords.x - startX;
            const height = coords.y - startY;
            selectionBox.style.width = `${Math.abs(width)}px`;
            selectionBox.style.height = `${Math.abs(height)}px`;
            if (width < 0) selectionBox.style.left = `${coords.x}px`;
            if (height < 0) selectionBox.style.top = `${coords.y}px`;
        }
    };

    const endDraw = (e) => {
        if (!selectionBox) {
            overlay.remove();
            return;
        }
        e.preventDefault();
        const rect = targetCanvas.getBoundingClientRect();
        const endCoords = getCoords(e.changedTouches ? e.changedTouches[0] : e, targetCanvas);
        
        const newCropBox = {
            x: Math.min(startX, endCoords.x) / rect.width,
            y: Math.min(startY, endCoords.y) / rect.height,
            width: Math.abs(endCoords.x - startX) / rect.width,
            height: Math.abs(endCoords.y - startY) / rect.height,
        };

        if (newCropBox.width > 0.01 && newCropBox.height > 0.01) {
            question.cropBox = newCropBox;
            question.needsReview = false;
        }

        redrawCropBox(question);
        overlay.remove();
    };

    overlay.addEventListener('mousedown', startDraw);
    overlay.addEventListener('mousemove', draw);
    overlay.addEventListener('mouseup', endDraw);
    overlay.addEventListener('touchstart', startDraw);
    overlay.addEventListener('touchmove', draw);
    overlay.addEventListener('touchend', endDraw);
}
            
     /**
             * Resets a question's crop box to the original automatic detection.
             * @param {Event} event The click event from the button.
             */
            async function resetCropToAuto(event) {
                const questionId = event.target.dataset.questionId;
                const subjectData = getCurrentSubjectData();
                const question = subjectData.allQuestions.find(q => q.id === questionId);
                
                // NEW: Use correct doc based on index
                const pdfIndex = question.pdfIndex || 0;
                const doc = subjectData.pdfDocs[pdfIndex];

                if (!question || !doc) return;

                const page = await doc.getPage(question.pageNum);
                const textContent = await page.getTextContent();
                question.cropBox = detectCropBox(textContent.items, page);
                redrawCropBox(question);
            }
            
            /**
             * Resets a question's crop box to show the full page.
             * @param {Event} event The click event from the button.
             */
            function resetCropToFullPage(event) {
                const questionId = event.target.dataset.questionId;
                const question = getCurrentSubjectData().allQuestions.find(q => q.id === questionId);
                if (question) {
                    question.cropBox = null;
                    redrawCropBox(question);
                }
            }

        function saveState() {
    // Create a serializable version of the state
    const stateToSave = {
        currentSubject: AppState.currentSubject,
        subjects: {}
    };

    for (const subjectName in AppState.subjects) {
        const subjectData = AppState.subjects[subjectName];
        
        // Create a copy of the subject data to modify
        const savedSubject = { ...subjectData };

        // --- FIX START ---
        // You must remove ALL PDF references (singular and plural)
        delete savedSubject.pdfDoc;          // Old single file
        delete savedSubject.pdfDocs;         // <--- ADD THIS LINE (The array of files)
        delete savedSubject.rationalePdfDoc; // Rationale file
        // --- FIX END ---

        // 2. Exclude the massive 'rawItems' from all questions
        savedSubject.allQuestions = subjectData.allQuestions.map(question => {
            const { rawItems, ...questionToSave } = question;
            return questionToSave;
        });
        
        stateToSave.subjects[subjectName] = savedSubject;
    }

    try {
        localStorage.setItem('staarMasteryAppData', JSON.stringify(stateToSave));
    } catch (e) {
        if (e.name === 'QuotaExceededError') {
            console.error("QuotaExceededError: Failed to save state. Data is too large for localStorage.", e);
        } else {
            console.error("Failed to save state:", e);
        }
    }
}

            function loadState() {
                const savedState = localStorage.getItem('staarMasteryAppData');
                if (savedState) {
                    const parsedState = JSON.parse(savedState);
                    AppState.currentSubject = parsedState.currentSubject;
                    for (const subjectName in parsedState.subjects) {
                        if (AppState.subjects[subjectName]) {
                            // Merge saved data with the initial structure (which includes pdfDoc: null)
                            Object.assign(AppState.subjects[subjectName], parsedState.subjects[subjectName]);
                        }
                    }
                }
            }

            function getCurrentSubjectData() {
                return AppState.subjects[AppState.currentSubject];
            }

            

            function renderAppForCurrentSubject() {
                const subjectData = getCurrentSubjectData();
                renderSubjectDropdown();
                if (subjectData.allQuestions.length > 0) {
                    statusDiv.textContent = `Loaded ${subjectData.allQuestions.length} questions from saved session.`;
                    if (!subjectData.pdfDoc) {
                        statusDiv.innerHTML += `<br><span class="font-bold text-red-600">Please re-upload the PDF to start a pathway.</span>`;
                    }
                    renderDashboard();
                    populateCustomFilters();
                    updateReviewAllButton();
                    customPathwayBuilder.classList.remove('hidden');
                } else {
                    resetUI();
                }
            }

        // ==========================================
// 6. UPDATED DROPDOWN (Organized Groups)
// ==========================================
function renderSubjectDropdown() {
    subjectDropdown.innerHTML = '';
    
    // Define Groups
    const groups = {
         'High School (EOC)': [
            'Algebra 1', 'Biology', 'English 1', 'English 2', 'U.S. History'
        ],
        'Elementary School (Grades 3-5)': [
            'Math Grade 3', 'Math Grade 4', 'Math Grade 5',
            'Reading Grade 3', 'Reading Grade 4', 'Reading Grade 5',
            'Science Grade 5'
        ],
        'Middle School (Grades 6-8)': [
            'Math Grade 6', 'Math Grade 7', 'Math Grade 8',
            'Reading Grade 6', 'Reading Grade 7', 'Reading Grade 8',
            'Science Grade 8', 'Social Studies Grade 8'
        ],
        
    };

    // Create OptGroups
    for (const [groupLabel, subjects] of Object.entries(groups)) {
        const optgroup = document.createElement('optgroup');
        optgroup.label = groupLabel;
        optgroup.style.fontWeight = 'bold';
        optgroup.style.color = '#374151'; // Gray-700

        subjects.forEach(subjectName => {
            // Only add if it exists in our AppState (safety check)
            if (AppState.subjects[subjectName]) {
                const option = document.createElement('option');
                option.value = subjectName;
                option.textContent = subjectName;
                if (subjectName === AppState.currentSubject) {
                    option.selected = true;
                }
                optgroup.appendChild(option);
            }
        });

        subjectDropdown.appendChild(optgroup);
    }
}


const RationaleFiles = {
    // High School
    'Biology': [
        'https://raw.githubusercontent.com/MrRamirez123/Staar-mastery/main/assets/pdfs/2019-staar-biology-rationales.pdf',
        'https://raw.githubusercontent.com/MrRamirez123/Staar-mastery/main/assets/pdfs/staar-2021-bio-rationales-tagged-1.pdf',
        'https://raw.githubusercontent.com/MrRamirez123/Staar-mastery/main/assets/pdfs/2022-staar-biology-rationale.pdf',
        'https://raw.githubusercontent.com/MrRamirez123/Staar-mastery/main/assets/pdfs/2023-staar-biology-rationale.pdf',
        'https://raw.githubusercontent.com/MrRamirez123/Staar-mastery/main/assets/pdfs/2024-staar-biology-rationale.pdf',
        'https://raw.githubusercontent.com/MrRamirez123/Staar-mastery/main/assets/pdfs/2025-staar-biology-rationale.pdf'
    ],
    'Algebra 1': [
            'https://raw.githubusercontent.com/MrRamirez123/Staar-mastery/main/assets/pdfs/2023-staar-algebra-i-rationale.pdf',
            'https://raw.githubusercontent.com/MrRamirez123/Staar-mastery/main/assets/pdfs/2024-staar-algebra-i-rationale.pdf',
            'https://raw.githubusercontent.com/MrRamirez123/Staar-mastery/main/assets/pdfs/2025-staar-algebra-1-rationale.pdf'
    ],
    'English 1': [],
    'English 2': [],
    'U.S. History': [
        'https://raw.githubusercontent.com/MrRamirez123/Staar-mastery/main/assets/pdfs/2024-staar-us-history-rationale.pdf',
        'https://raw.githubusercontent.com/MrRamirez123/Staar-mastery/main/assets/pdfs/2025-staar-us-history-rationale.pdf'
    ],

    // Placeholders for Grades 3-8
    'Math Grade 3': ['https://raw.githubusercontent.com/MrRamirez123/Staar-mastery/main/assets/pdfs/2024-staar-3-math-rationale.pdf',
        'https://raw.githubusercontent.com/MrRamirez123/Staar-mastery/main/assets/pdfs/2025-staar-math-3-rationale.pdf'],
         'Math Grade 4': [], 'Math Grade 5': [],
    'Math Grade 6': [], 'Math Grade 7': [], 'Math Grade 8': [],
    
    'Reading Grade 3': ['https://raw.githubusercontent.com/MrRamirez123/Staar-mastery/main/assets/pdfs/2024-staar-3-rla-rationale.pdf',
        'https://raw.githubusercontent.com/MrRamirez123/Staar-mastery/main/assets/pdfs/2025-staar-rla-3-rationale.pdf'],
         'Reading Grade 4': [], 'Reading Grade 5': [],
    'Reading Grade 6': [], 'Reading Grade 7': [], 'Reading Grade 8': [],
    
    'Science Grade 5': [], 'Science Grade 8': [],
    'Social Studies Grade 8': []
};


// ==========================================
// 5. UPDATED THEMES (Paper Mode Patterns)
// ==========================================
const SubjectThemes = {
    // --- HIGH SCHOOL ---
    'Biology': { 
        gradient: 'linear-gradient(90deg, #2e7d32, #4caf50)', 
        primary: '#2e7d32', hover: '#1b5e20', 
        confettiColors: ['#2e7d32', '#81c784'], confettiShape: 'circle',
        // Pattern: Faded DNA Helix
        pattern: `url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M10 10 Q 30 30 50 10 M 10 50 Q 30 30 50 50' stroke='%232e7d32' stroke-width='2' fill='none' opacity='0.05'/%3E%3C/svg%3E")`
    },
    'Algebra 1': { 
        gradient: 'linear-gradient(90deg, #283593, #3f51b5)', 
        primary: '#283593', hover: '#1a237e', 
        confettiColors: ['#283593', '#7986cb'], confettiShape: 'triangle',
        // Pattern: Grid Graph
        pattern: `url("data:image/svg+xml,%3Csvg width='40' height='40' viewBox='0 0 40 40' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M0 0h40v40H0z' fill='none' stroke='%23283593' stroke-width='0.5' opacity='0.05'/%3E%3Cpath d='M0 20h40M20 0v40' stroke='%23283593' stroke-width='1' opacity='0.08'/%3E%3C/svg%3E")`
    },
    'U.S. History': { 
        gradient: 'linear-gradient(90deg, #881337, #be123c)', 
        primary: '#881337', hover: '#4c0519', 
        confettiColors: ['#881337', '#f43f5e'], confettiShape: 'star',
        // Pattern: Quill Pen / Compass
        pattern: `url("data:image/svg+xml,%3Csvg width='80' height='80' viewBox='0 0 80 80' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M10 70 L 40 40 L 50 10 L 45 35 Z' stroke='%23881337' stroke-width='1' fill='none' opacity='0.05'/%3E%3Ccircle cx='40' cy='40' r='30' stroke='%23881337' stroke-width='0.5' fill='none' opacity='0.04'/%3E%3C/svg%3E")`
    },
    'English 1': { 
        gradient: 'linear-gradient(90deg, #78350f, #b45309)', 
        primary: '#78350f', hover: '#451a03', 
        confettiColors: ['#78350f', '#d97706'], confettiShape: 'rect',
        // Pattern: Text Lines
        pattern: `url("data:image/svg+xml,%3Csvg width='100' height='20' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M5 15 h90' stroke='%2378350f' stroke-width='1' stroke-dasharray='5,5' opacity='0.08'/%3E%3C/svg%3E")`
    },
    'English 2': { 
        gradient: 'linear-gradient(90deg, #78350f, #b45309)', 
        primary: '#78350f', hover: '#451a03', 
        confettiColors: ['#78350f', '#d97706'], confettiShape: 'rect',
        pattern: `url("data:image/svg+xml,%3Csvg width='100' height='20' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M5 15 h90' stroke='%2378350f' stroke-width='1' stroke-dasharray='5,5' opacity='0.08'/%3E%3C/svg%3E")`
    }
};

// Fallback logic for Middle/Elementary to map to these patterns
const baseMathTheme = SubjectThemes['Algebra 1'];
const baseReadingTheme = SubjectThemes['English 1'];
const baseScienceTheme = SubjectThemes['Biology'];
const baseSocialTheme = SubjectThemes['U.S. History'];

['Math Grade 3', 'Math Grade 4', 'Math Grade 5', 'Math Grade 6', 'Math Grade 7', 'Math Grade 8'].forEach(s => SubjectThemes[s] = baseMathTheme);
['Reading Grade 3', 'Reading Grade 4', 'Reading Grade 5', 'Reading Grade 6', 'Reading Grade 7', 'Reading Grade 8'].forEach(s => SubjectThemes[s] = baseReadingTheme);
['Science Grade 5', 'Science Grade 8'].forEach(s => SubjectThemes[s] = baseScienceTheme);
['Social Studies Grade 8'].forEach(s => SubjectThemes[s] = baseSocialTheme);

function applyTheme(subject) {
    // Default to Algebra if subject not found
    const theme = SubjectThemes[subject] || SubjectThemes['Algebra 1']; 
    const root = document.documentElement;

    // Apply CSS Variables
    root.style.setProperty('--theme-gradient', theme.gradient);
    // DO NOT set --theme-bg, we want to keep the parchment color constant
    root.style.setProperty('--theme-pattern', theme.pattern || 'none'); // New Pattern Logic
    root.style.setProperty('--theme-primary', theme.primary);
    root.style.setProperty('--theme-hover', theme.hover);
}
 
async function loadRemotePDF(examUrls, rationaleUrls) {
    console.log("üöÄ [Auto-Load] Starting sequence...");
    showLoader("I'm fetching the exam files from the cloud... hang tight!");

    try {
        const subjectData = getCurrentSubjectData();
        const eUrls = Array.isArray(examUrls) ? examUrls : [examUrls];
        
        subjectData.pdfDocs = [];
        subjectData.allQuestions = []; 

        // Loop through ALL exam files
        for (let i = 0; i < eUrls.length; i++) {
            const url = eUrls[i];
            const text = document.getElementById('global-loader-text');
            if(text) text.innerHTML = `"Downloading Exam File ${i+1} of ${eUrls.length}..."`;

            const response = await fetch(url);
            if (!response.ok) throw new Error(`Exam PDF Error: ${response.status}`);
            const arrayBuffer = await response.arrayBuffer();
            
            const newDoc = await pdfjsLib.getDocument(arrayBuffer).promise;
            subjectData.pdfDocs.push(newDoc);
            
            if (i === 0) {
                subjectData.teksToRcMap = await buildTeksToRcMap(newDoc);
            }

            if(text) text.innerHTML = `"Reading File ${i+1}... this is the hard part!"`;
            const newQuestions = await parseAllPages(newDoc, i); 
            subjectData.allQuestions.push(...newQuestions);
        }
        
        // --- STEP 2: RATIONALES (Keep existing logic) ---
        // (I'm abbreviating this part for clarity, it stays the same as before)
        const rUrls = Array.isArray(rationaleUrls) ? rationaleUrls : (rationaleUrls ? [rationaleUrls] : []);
        if (rUrls.length > 0) { /* ... rationale loading logic ... */ }

        // --- STEP 3: FINISH ---
        updateReviewAllButton();
        renderDashboard();
        populateCustomFilters();
        document.getElementById('custom-pathway-builder').classList.remove('hidden');
        saveState();
        
        // --- FIX: UPDATE THE SIDEBAR STATUS ---
        const statusDiv = document.getElementById('status');
        if (statusDiv) {
            statusDiv.innerHTML = `<span class="text-green-600 font-bold">‚úì Ready (${subjectData.allQuestions.length} Qs)</span>`;
        }

        hideLoader();

    } catch (error) {
        console.error("‚ùå [Auto-Load] Failure:", error);
        document.getElementById('status').innerHTML = `<span class="text-red-500">Error loading data.</span>`;
        hideLoader();
    }
}
   
/**
 * SWITCH SUBJECT (Updated to Always Show Ms. Staar)
 */
function switchSubject(subjectName) {
    // 1. Initialize Flag if it doesn't exist yet
    if (typeof AppState.isFetching === 'undefined') AppState.isFetching = false;

    // 2. THE GATEKEEPER: Stop if we are already busy
    if (AppState.isFetching) {
        console.log("‚ö†Ô∏è [Switch] Blocked: Download already in progress.");
        return; 
    }

    // 3. SHOW LOADER IMMEDIATELY (This ensures she pops up every time)
    showLoader(`Let me pull up the ${subjectName} data for you...`);

    console.log("üîÑ [Switch] Switching to:", subjectName);
    AppState.currentSubject = subjectName;
    
    // Sync UI
    renderSubjectDropdown(); 
    applyTheme(subjectName); 

    const fileInput = document.getElementById('pdf-upload');
    if (fileInput) {
        fileInput.addEventListener('change', handleFileSelect);
    }
    
    const subjectData = getCurrentSubjectData();
    const examUrls = SubjectFiles[subjectName];
    const rationaleUrls = RationaleFiles[subjectName];

    // 4. CHECK: Do we need to download files?
    if ((subjectData.allQuestions.length === 0 || (!subjectData.pdfDocs || subjectData.pdfDocs.length === 0)) && examUrls) {
        
        AppState.isFetching = true; 
        
        // loadRemotePDF will take over the loader text and hide it when done
        loadRemotePDF(examUrls, rationaleUrls)
            .finally(() => {
                AppState.isFetching = false;
            });
            
    } else {
        // 5. IF DATA IS ALREADY HERE (The "Instant" Switch)
        // We add a tiny delay (800ms) so the user sees Ms. Staar briefly.
        // This makes the app feel "smoother" instead of glitching instantly to the new view.
        setTimeout(() => {
            renderAppForCurrentSubject();
            hideLoader(); // Hide her after the switch is done
        }, 800);
    }
    
    saveState();
}

function renderResultsScreen() {
    // 1. VIEW SWITCHING
    try {
        const problemView = document.getElementById('problem-view');
        const resultsView = document.getElementById('results-view');
        const dashboardView = document.getElementById('dashboard-view');
        const homeBtn = document.getElementById('home-btn');
        const appContent = document.getElementById('app-content');

        if (problemView) problemView.classList.add('hidden');
        if (dashboardView) dashboardView.classList.add('hidden');
        if (resultsView) {
            if (appContent) appContent.prepend(resultsView);
            resultsView.classList.remove('hidden');
        }
        if (homeBtn) homeBtn.classList.remove('hidden');
        window.scrollTo(0, 0);
    } catch (e) { console.error("View switching failed:", e); }

    // 2. DATA PREPARATION
    const pathway = AppState.currentPathway;
    const subjectData = getCurrentSubjectData();
    
    // --- TIME MACHINE LOGIC ---
    // If we are reviewing history, use the saved snapshot scores.
    // If we are live, use the current global mastery state.
    let mastery = {};
    if (pathway.isHistoryReview && pathway.savedScores) {
        mastery = pathway.savedScores;
    } else {
        mastery = subjectData.masteryState[pathway.teks] || {};
    }

    let totalPointsEarned = 0;
    let totalPointsPossible = 0;
    const snapshotScores = {}; // We will build this to save later

    // Calculate Scores
    pathway.questions.forEach((question, index) => {
        if (!question) return;

        const pointsPossible = getQuestionPointsPossible(question);
        totalPointsPossible += pointsPossible;

        const status = mastery[index];
        let points = 0;

        if (typeof status === 'number') {
            points = status;
        } else if (status === 'correct') {
            points = pointsPossible;
        }
        
        totalPointsEarned += points;
        
        // Capture for history snapshot
        snapshotScores[index] = points;
    });

    const percentage = totalPointsPossible === 0 ? 0 : Math.round((totalPointsEarned / totalPointsPossible) * 100);

    // 3. SAVE HISTORY (Only if this is a LIVE quiz, not a review)
    if (pathway.isQuiz && !pathway.isHistoryReview) {
        if (!subjectData.resultHistory) subjectData.resultHistory = [];
        
        const historyItem = {
            id: Date.now(),
            date: new Date().toLocaleString(),
            title: pathway.teks,
            score: totalPointsEarned,
            total: totalPointsPossible,
            percent: percentage,
            // NEW: Save the "DNA" of this specific attempt
            questionIds: pathway.questions.map(q => q.id),
            savedScores: snapshotScores 
        };
        
        // Prevent duplicate saves (debounce)
        const lastItem = subjectData.resultHistory[subjectData.resultHistory.length - 1];
        if (!lastItem || (Date.now() - lastItem.id > 2000)) {
            subjectData.resultHistory.push(historyItem);
            saveState();
        }
    }

    // 4. UI RENDERING (Banner & Colors)
    const targets = AppState.difficultySettings.targets;
    let statusLabel = "Did Not Meet Grade Level";
    let statusColor = "text-red-600";

    if (percentage >= targets.masters) {
        statusLabel = "Masters Grade Level";
        statusColor = "text-purple-600";
    } else if (percentage >= targets.meets) {
        statusLabel = "Meets Grade Level";
        statusColor = "text-blue-600";
    } else if (percentage >= targets.approaches) {
        statusLabel = "Approaches Grade Level";
        statusColor = "text-green-600";
    }

    const resultsSummary = document.getElementById('results-summary');
    if (resultsSummary) {
        const timeText = pathway.timerSettings && pathway.startTime 
            ? `<div class="text-sm text-gray-500 mt-2 font-mono">Time: ${Math.floor((new Date() - pathway.startTime)/1000/60)}m</div>` 
            : '';
            
        resultsSummary.innerHTML = `
            <div class="text-center mb-8 p-6 bg-gray-50 rounded-xl border border-gray-200">
                <div class="text-3xl sm:text-4xl font-extrabold ${statusColor} mb-2 tracking-tight">${statusLabel}</div>
                <div class="text-xl text-gray-700">
                    Score: <span class="font-bold text-gray-900">${totalPointsEarned.toFixed(0)} / ${totalPointsPossible}</span> 
                    <span class="text-gray-500 ml-1">(${percentage}%)</span>
                </div>
                ${timeText}
                ${pathway.isHistoryReview ? '<div class="mt-2 text-xs font-bold uppercase text-indigo-500 bg-indigo-50 inline-block px-2 py-1 rounded">Viewing Past Result</div>' : ''}
            </div>
        `;
    }

    // 5. RENDER MISSED QUESTIONS LIST
    const missedQuestions = pathway.questions.filter((q, index) => {
        if (!q) return false;
        // Use our local 'mastery' variable which handles the history toggle logic
        const status = mastery[index];
        const pointsPossible = getQuestionPointsPossible(q);
        
        if (status === 'correct') return false; 
        if (status === pointsPossible) return false; 
        return true;
    });

    renderMissedQuestionsGrid(missedQuestions);
    renderResultsAnalysis(pathway, subjectData);
    
}
/**
 * Triggers the "Ms. Staar" Hint System.
 * Eliminates one incorrect distractor and explains why using the rationale.
 */
function triggerHint() {
    const question = AppState.currentPathway.activeQuestion;
    if (!question) return;

    // 1. Identify Buttons
    const buttons = Array.from(document.querySelectorAll('.answer-button'));
    if (buttons.length === 0) {
        showFeedbackMessage("I can only help with Multiple Choice questions right now!", "text-gray-600");
        return;
    }

    // 2. Find Available Distractors (Incorrect options that are not yet crossed out)
    // We assume the button text (A, B, C...) matches the answer key or rationale keys.
    const incorrectButtons = buttons.filter(btn => {
        const choice = btn.textContent.trim();
        const isCorrect = question.answerText && question.answerText.includes(choice);
        const isAlreadyCrossedOut = btn.classList.contains('opacity-25'); // We will use opacity to mark "crossed out"
        return !isCorrect && !isAlreadyCrossedOut;
    });

    if (incorrectButtons.length === 0) {
        showFeedbackMessage("You've eliminated all the wrong answers! The remaining one must be correct.", "text-green-600");
        return;
    }

    // 3. Pick One to Eliminate (Randomly)
    const btnToEliminate = incorrectButtons[Math.floor(Math.random() * incorrectButtons.length)];
    const choice = btnToEliminate.textContent.trim();

    // 4. Apply Visual "Cross Out" Effect
    btnToEliminate.classList.add('opacity-25', 'cursor-not-allowed', 'line-through');
    btnToEliminate.disabled = true;

    // 5. Fetch Rationale for this specific wrong answer
    // We try to look up "Option A", "A", or "PartA_A" depending on data structure
    let explanation = "This option is incorrect.";
    if (question.rationaleMap) {
        // Try common keys
        explanation = question.rationaleMap[choice] || 
                      question.rationaleMap[`Option ${choice}`] || 
                      question.rationaleMap[`Option${choice}`] ||
                      "I don't have a specific note for this one, but we can rule it out.";
    }

    // 6. Show "Ms. Staar" (or whatever name we pick) Speaking
    showHintBubble(choice, explanation);
}

/**
 * Displays the Ms. STAAR bubble at the BOTTOM RIGHT.
 */
function showHintBubble(eliminatedChoice, rationaleText) {
    // We append to body to ensure it floats over everything correctly
    const container = document.body;
    
    const existing = document.getElementById('hint-bubble');
    if (existing) existing.remove();

    const bubbleHtml = `
        <div id="hint-bubble" class="fixed bottom-24 right-4 max-w-sm z-[9999] animate-fade-in-scale">
            <div class="flex items-end gap-4">
                
                <div class="bg-white p-5 rounded-2xl rounded-br-none shadow-2xl border-2 border-indigo-100 relative mb-4">
                    <button onclick="this.parentElement.parentElement.parentElement.remove()" class="absolute top-2 right-2 text-gray-400 hover:text-red-500 font-bold text-lg">&times;</button>
                    <h4 class="text-xs font-bold text-indigo-600 uppercase mb-2 flex items-center gap-1">
                        <span>‚ú®</span> Ms. STAAR says:
                    </h4>
                    <p class="text-sm text-gray-800 leading-relaxed">
                        Let's eliminate <strong class="text-red-600 line-through">Option ${eliminatedChoice}</strong>.
                        <br><br>
                        <span class="italic text-gray-600 bg-gray-50 p-2 rounded block">"${rationaleText}"</span>
                    </p>
                </div>

                <div class="relative flex-shrink-0">
                    <div class="w-20 h-20 rounded-full bg-white border-4 border-indigo-500 overflow-hidden shadow-xl flex items-center justify-center relative z-10">
                        <span class="text-5xl mb-1">üë©‚Äçüè´</span>
                    </div>
                    <div class="absolute -top-1 -right-1 w-6 h-6 bg-green-400 rounded-full border-2 border-white z-20"></div>
                </div>

            </div>
        </div>
    `;
    
    container.insertAdjacentHTML('beforeend', bubbleHtml);
}

// Helper to show simple text feedback if hint fails
function showFeedbackMessage(msg, colorClass) {
    const feedback = document.getElementById('feedback-message');
    if (feedback) {
        feedback.innerHTML = `<span class="${colorClass}">${msg}</span>`;
    }
}

document.getElementById('diagnostic-btn').addEventListener('click', () => {
    showDiagnosticOptionsModal();
});

function showDiagnosticOptionsModal() {
    const modalId = 'diagnostic-options-modal';
    document.getElementById(modalId)?.remove();

    const modalHtml = `
        <div id="${modalId}" class="fixed inset-0 bg-gray-900 bg-opacity-60 flex items-center justify-center p-4 z-50 backdrop-blur-sm">
            <div class="bg-white rounded-xl shadow-2xl w-full max-w-md overflow-hidden p-6">
                <h2 class="text-2xl font-bold text-gray-800 mb-2">Select Diagnostic Version</h2>
                <p class="text-gray-600 mb-6">Choose a test version. Questions cycle automatically.</p>
                
                <div class="space-y-3">
                    <button id="diag-opt-1" class="w-full p-4 border rounded-lg hover:bg-indigo-50 hover:border-indigo-500 transition-all flex justify-between items-center group">
                        <span class="font-bold text-lg text-gray-800 group-hover:text-indigo-700">Test A</span>
                        <span class="text-gray-500 font-medium">Baseline</span>
                    </button>

                    <button id="diag-opt-2" class="w-full p-4 border rounded-lg hover:bg-indigo-50 hover:border-indigo-500 transition-all flex justify-between items-center group">
                        <span class="font-bold text-lg text-gray-800 group-hover:text-indigo-700">Test B</span>
                        <span class="text-gray-500 font-medium">Check-up</span>
                    </button>

                    <button id="diag-opt-3" class="w-full p-4 border rounded-lg hover:bg-indigo-50 hover:border-indigo-500 transition-all flex justify-between items-center group">
                        <span class="font-bold text-lg text-gray-800 group-hover:text-indigo-700">Test C</span>
                        <span class="text-gray-500 font-medium">Final Review</span>
                    </button>
                </div>

                <div class="mt-6 flex justify-end">
                    <button onclick="document.getElementById('${modalId}').remove()" class="px-4 py-2 text-gray-500 font-bold hover:text-gray-800">Cancel</button>
                </div>
            </div>
        </div>
    `;

    document.body.insertAdjacentHTML('beforeend', modalHtml);

    // Attach Listeners with the specific version number
    document.getElementById('diag-opt-1').onclick = () => runDiagnosticGenerator(0, 'A');
    document.getElementById('diag-opt-2').onclick = () => runDiagnosticGenerator(1, 'B');
    document.getElementById('diag-opt-3').onclick = () => runDiagnosticGenerator(2, 'C');
}


/**
 * Generates the diagnostic based on the selected version offset.
 * @param {number} offsetIndex - 0 for Test A, 1 for Test B, 2 for Test C.
 * @param {string} label - 'A', 'B', or 'C' for the title.
 */
function runDiagnosticGenerator(offsetIndex, label) {
    document.getElementById('diagnostic-options-modal')?.remove();
    
    const subjectData = getCurrentSubjectData();
    const allQuestions = subjectData.allQuestions;

    if (!allQuestions || allQuestions.length === 0) {
        showCustomModal("No Data", "Please upload a PDF first.", null);
        return;
    }

    showLoader(`Building Diagnostic Test ${label}...`);

    setTimeout(() => {
        // 1. Group by TEKS
        const questionsByTeks = {};
        allQuestions.forEach(q => {
            if (!questionsByTeks[q.teks]) questionsByTeks[q.teks] = [];
            questionsByTeks[q.teks].push(q);
        });

        // 2. Select Questions (Double Dip Logic)
        const diagnosticSet = [];
        
        Object.keys(questionsByTeks).sort().forEach(teksKey => {
            const group = questionsByTeks[teksKey];
            
            // Sort group by difficulty or ID to ensure consistent order
            // We reuse your logicalSortComparator to keep it stable
            group.sort(logicalSortComparator);

            // LOGIC: Use Modulo (%) to cycle if we run out of questions
            // Example: If offset is 2 (Test C) but we only have 1 question (length 1):
            // 2 % 1 = 0. We grab question [0]. (Double Dip!)
            const targetIndex = offsetIndex % group.length;
            
            const selectedQ = group[targetIndex];
            
            if (selectedQ) diagnosticSet.push(selectedQ);
        });

        // 3. Unique ID to fix "Ghost Data"
        const timestamp = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        const title = `ü©∫ Diagnostic ${label} (${diagnosticSet.length} Qs) - ${timestamp}`;

        hideLoader();
        
        startPathway(title, diagnosticSet, { 
            isQuiz: true, 
            timerSettings: null 
        });

    }, 500);
}

/**
 * Shows the Ms. Staar loading screen with a custom message.
 */
function showLoader(message = "Analyzing data...") {
    const loader = document.getElementById('global-loader');
    const text = document.getElementById('global-loader-text');
    
    // Set the text (with quotes for character voice)
    if (text) text.innerHTML = `"${message}"`;
    
    if (loader) {
        loader.classList.remove('hidden');
        // Force a tiny layout reflow to ensure the transition plays (optional polish)
        void loader.offsetWidth; 
        loader.classList.remove('opacity-0');
    }
}

/**
 * Hides the loading screen.
 */
function hideLoader() {
    const loader = document.getElementById('global-loader');
    if (loader) {
        loader.classList.add('opacity-0');
        // Wait for fade out to finish before hiding display
        setTimeout(() => {
            loader.classList.add('hidden');
        }, 300);
    }
}
        
    </script>
</body>
</html>

